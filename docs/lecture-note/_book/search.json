[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "Preface\nWelcome to Advanced Topics in Network Science! This book provides a comprehensive introduction to the mathematical foundations and computational methods for analyzing complex networks.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#about-this-book",
    "href": "index.html#about-this-book",
    "title": "Advanced Topics in Network Science",
    "section": "About This Book",
    "text": "About This Book\nThis interactive textbook covers advanced topics in network science, including:\n\nNetwork structure and topology\nRandom walks and diffusion processes\n\nCommunity detection and clustering\nNetwork centrality measures\nGraph embeddings and neural networks\nRobustness and percolation\n\nEach module combines theoretical foundations with hands-on computational exercises using Python and popular network analysis libraries.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Advanced Topics in Network Science",
    "section": "Getting Started",
    "text": "Getting Started\nTo get the most out of this book, you should have:\n\nBasic knowledge of Python programming\nFamiliarity with linear algebra and probability\nUnderstanding of graph theory fundamentals",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#interactive-features",
    "href": "index.html#interactive-features",
    "title": "Advanced Topics in Network Science",
    "section": "Interactive Features",
    "text": "Interactive Features\nThis Quarto book includes:\n\nCode folding: Click to show/hide code blocks\nCopy code: Hover over code blocks to copy\nLive computation: All examples use real data and can be executed\nSearch: Use the search box to find specific topics",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "Advanced Topics in Network Science",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nThis material was developed for the Advanced Topics in Network Science course. Special thanks to all contributors and students who helped improve this content.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro/why-networks.html",
    "href": "intro/why-networks.html",
    "title": "1¬† Why should we care networks?",
    "section": "",
    "text": "1.1 Zoo of networks\nFrom the vast expanse of the Internet to social networks and protein-protein interactions, networks are all around us in nature and society. And, their connections do matter in our daily lives. A virus goes viral by going through the physical contacts of people. The economics are driven by trades between companies. Proteins function by interacting with each other. Networks are the key drivers of many interesting phenomena that do not arise without the networks!\nCan you find networks around you? Find out what networks are like in nature and society.\nZoo üêÜüêòü¶Ü of networks",
    "crumbs": [
      "Intro",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Why should we care networks?</span>"
    ]
  },
  {
    "objectID": "intro/zoo-of-networks.html",
    "href": "intro/zoo-of-networks.html",
    "title": "2¬† Zoo of networks",
    "section": "",
    "text": "Plant pollinator network\n\n\n\n\n\nFood web\n\n\n\n\n\nBrain network\n\n\n\n\n\nNetwork of medicine\n\n\n\n\n\nProtein-protein interaction\n\n\n\n\n\nSocial network\n\n\n\n\n\nInternational financial network\n\n\n\n\n\nUS airport network\n\n\n\n\n\nPower grid network\n\n\n\n\n\nNetwork of rivers\n\n\n\n\n\nInternet\n\n\n\n\n\nKnowledge graph\n\n\n\n\n\nFlavor Network\n\n\n\n\n\nFlavor Network\n\n\n\n\n\nCitation Cartels\n\n\n\n\n\nCitation Cartels\n\n\n\n\n\nVirus spreading network",
    "crumbs": [
      "Intro",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zoo of networks</span>"
    ]
  },
  {
    "objectID": "intro/setup.html",
    "href": "intro/setup.html",
    "title": "3¬† Trouble shooting",
    "section": "",
    "text": "3.1 Cannot plot a graph with igraph on Google Colab\nGoogle Colab has many packages pre-installed. However, they do not include some pacages for network analysis like igraph and graph-tool.\nInstalling igraph Create a cell on top of the notebook and run the following code to install the igraph.\nInstalling graph-tool Create a cell on top of the notebook and run the following code to install the graph-tool.",
    "crumbs": [
      "Intro",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Trouble shooting</span>"
    ]
  },
  {
    "objectID": "intro/setup.html#cannot-plot-a-graph-with-igraph-on-google-colab",
    "href": "intro/setup.html#cannot-plot-a-graph-with-igraph-on-google-colab",
    "title": "3¬† Trouble shooting",
    "section": "",
    "text": "!sudo apt install libcairo2-dev pkg-config python3-dev\n!pip install pycairo cairocffi\n!pip install igraph\n\n!wget https://downloads.skewed.de/skewed-keyring/skewed-keyring_1.0_all_$(lsb_release -s -c).deb\n!dpkg -i skewed-keyring_1.0_all_$(lsb_release -s -c).deb\n!echo \"deb [signed-by=/usr/share/keyrings/skewed-keyring.gpg] https://downloads.skewed.de/apt $(lsb_release -s -c) main\" &gt; /etc/apt/sources.list.d/skewed.list\n!apt-get update\n!apt-get install python3-graph-tool python3-matplotlib python3-cairo\n\n# Colab uses a Python install that deviates from the system's! Bad colab! We need some workarounds.\n!apt purge python3-cairo\n!apt install libcairo2-dev pkg-config python3-dev\n!pip install --force-reinstall pycairo\n!pip install zstandar",
    "crumbs": [
      "Intro",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Trouble shooting</span>"
    ]
  },
  {
    "objectID": "m01-euler_tour/what-to-learn.html",
    "href": "m01-euler_tour/what-to-learn.html",
    "title": "4¬† Module 1: Euler Tour",
    "section": "",
    "text": "4.1 What to learn in this module\nIn this module, we will learn a historical example that leads to the genesis of graph theory in mathematics and modern network science. Through this example, we will learn: - How to describe a network using mathematical language - How to code a network in Python - Keywords: network, degree, Euler walk",
    "crumbs": [
      "M01: Euler Tour",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Module 1: Euler Tour</span>"
    ]
  },
  {
    "objectID": "m01-euler_tour/puzzle.html",
    "href": "m01-euler_tour/puzzle.html",
    "title": "5¬† A puzzle",
    "section": "",
    "text": "5.1 Pen-and-paper worksheet\nBack in 18th century, there was a city called K√∂nigsberg situated on the Pregel River in a historical region of Germany. The city had two large islands connected to each other and the mainland by seven bridges. The citizens of K√∂nigsberg pondered a puzzle during their Sunday walks:\nLeonard Euler worked out the solution to this puzzle in 1736. He first simplified the city into a network of landmasses connected by bridges, by noting that the landareas, the positions of the islands and the bridges are nothing to do with the puzzle, and that the only thing that matters is the connections between the landmasses.\nLet‚Äôs follow the worksheet to solve the puzzle step by step.",
    "crumbs": [
      "M01: Euler Tour",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>A puzzle</span>"
    ]
  },
  {
    "objectID": "m01-euler_tour/puzzle.html#pen-and-paper-worksheet",
    "href": "m01-euler_tour/puzzle.html#pen-and-paper-worksheet",
    "title": "5¬† A puzzle",
    "section": "",
    "text": "Worksheet (Moro 2017)",
    "crumbs": [
      "M01: Euler Tour",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>A puzzle</span>"
    ]
  },
  {
    "objectID": "m01-euler_tour/puzzle.html#references",
    "href": "m01-euler_tour/puzzle.html#references",
    "title": "5¬† A puzzle",
    "section": "5.2 References",
    "text": "5.2 References\n\n\nMoro, Esteban. 2017. ‚ÄúNetwork Science for Kids!‚Äù http://estebanmoro.org/2017/03/network-science-for-kids.",
    "crumbs": [
      "M01: Euler Tour",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>A puzzle</span>"
    ]
  },
  {
    "objectID": "m01-euler_tour/euler-path.html",
    "href": "m01-euler_tour/euler-path.html",
    "title": "6¬† Euler‚Äôs solution",
    "section": "",
    "text": "Euler consider two cases: - a node has an even number of edges, or - a node has an odd number of edges.\nWhen a node has an even number 2k of edges, one can enter and leave the node k times by crossing different edges.\nWhen a node has an odd number 2k+1 of edges, one can enter and leave the node k times by crossing different edges but leave one last edge to cross. The only way to cross this last edge is that one starts or ends at the node.\nBased up on the above reasoning, Euler leads to the following necessary (and later shown as sufficient) conditions:\n\n\n\n\n\n\nEuler‚Äôs path\n\n\n\nThere exists a walk that crosses all edges exactly once if and only if all nodes have even number of edges, or exactly two nodes have an odd number of edges.\n\n\n\n\n\nalt text\n\n\nBack to the Konigsberg bridge problem, every node has an odd number of edges, meaning that there is no way to cross all edges exactly once. What a sad story for the citizens of Konigsberg. But the problem was solved during World War II, where Koingberg was bombarded by Soviet Union, losing two of the seven bridges ü´†.\n\n\n\nTwo bridges were bombed by Soviet Union, which allows the Euler path to exist. {#fig-markdown-fig}",
    "crumbs": [
      "M01: Euler Tour",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Euler's solution</span>"
    ]
  },
  {
    "objectID": "m01-euler_tour/how-to-code-network.html",
    "href": "m01-euler_tour/how-to-code-network.html",
    "title": "7¬† Compute with networks",
    "section": "",
    "text": "7.1 Network representation\nSo far we worked out the network of bridges of Konigsberg by illustrating the network with points and lines. From now, we will work with a representation of the network that can be easily computed with code.\nAn atomic element of a network is a node, i.e., a network is a collection of edges which are pairs of nodes. We label a unique integer as an identifier for each node. For instance, the bridges of Konigsberg has 4 nodes, and we assign the number 0 to 3 to the nodes. An edge can be represented by a pair of nodes. For instance, the edge between node 0 and node 1 can be represented by the pair (0, 1).\n```fbtaszlgvxd numbered-koningsberg-graph\nLabeled Knigsberg graph\n:::\nAnother, more convenient format is the adjacency matrix. In this form, one regard the node index as a coordinate in the matrix. For instance, edge (1,3) is represented by the entry in the second row and fourth column. The entry of the matrix represents the number of edges between two nodes. Thus, the zeros in the matrix represent the absence of edges.\nCode\nA = [[0, 2, 0, 1],\n     [2, 0, 2, 1],\n     [0, 2, 0, 1],\n     [1, 1, 1, 0]]\nor equivalently, using for loops:\nCode\nimport numpy as np\n\nA = np.zeros((4, 4))\nfor i, j in edges:\n    A[i][j] += 1\n    A[j][i] += 1",
    "crumbs": [
      "M01: Euler Tour",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Compute with networks</span>"
    ]
  },
  {
    "objectID": "m01-euler_tour/how-to-code-network.html#network-representation",
    "href": "m01-euler_tour/how-to-code-network.html#network-representation",
    "title": "7¬† Compute with networks",
    "section": "",
    "text": "file\n\n\n\n\n::: {.callout-note}\nWe label nodes starting from 0 with consecutive numbers, which is convenient for Python. However, this is *not the only way* to label nodes.\n:::\n\nThe Konigsberg graph can be represented by a list of edges.\n\n::: {#fa6c5858 .cell}\n``` {.python .cell-code}\nedges = [(0,1), (0, 1), (0, 3), (1, 2), (1, 2), (1, 3), (2, 3)]\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the Konigsberg graph, the edges are undirected, meaning edge (i,j) is the same as edge (j,i), which is why we increment both entries (i,j) and (j,i) in the for loop. If the edges are directed, we treat (i,j) and (j,i) as two different edges, and increment only (i,j).",
    "crumbs": [
      "M01: Euler Tour",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Compute with networks</span>"
    ]
  },
  {
    "objectID": "m01-euler_tour/how-to-code-network.html#edge-counting",
    "href": "m01-euler_tour/how-to-code-network.html#edge-counting",
    "title": "7¬† Compute with networks",
    "section": "7.2 Edge counting",
    "text": "7.2 Edge counting\nLet us showcase the convenience of the adjacency matrix by counting the number of edges in the network.\nThe total number of edges in the network is the sum of the entities in the\n\n\nCode\nnp.sum(A) / 2\n\n\nWe divide by 2 because an edge corresponds to two entries in the matrix. Now, let us consider\nIt is also easy to compute the number of edges pertained to individual nodes by taking the row or column sum of the matrix.\n\n\nCode\nnp.sum(A, axis = 1)\n\n\nThe result is an array of length 4, where the i-th entry is the number of edges connected to node i.\n\n\n\n\n\n\nImportant\n\n\n\nThe number of edges connected to a node is called the degree of the node.\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe np.sum(A, axis = 1) is the column sum of A. Alternatively, np.sum(A, axis = 0) is the row sum of A. Check out the numpy documentation for more details.\n\n\n\n\n\n\n\n\nTip\n\n\n\nIf the adjacency matrix is scipy CSR format (or CSC format), you can instead use A_csr.sum(axis=1), A_csr.sum(axis=0), and A_csr.sum(). Check out the scipy documentation for more details.\n\n\nWe can check the number of nodes with odd degree by taking the modulus of the degree by 2.\n\n\nCode\ndeg = np.sum(A, axis = 1)\nis_odd = deg % 2 == 1\nis_odd\n\n\n\n\nCode\nif np.sum(is_odd) == 2 or np.sum(is_odd) == 0:\n    print(\"The graph has a Euler path.\")\nelse:\n    print(\"The graph does not have a Euler path.\")",
    "crumbs": [
      "M01: Euler Tour",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Compute with networks</span>"
    ]
  },
  {
    "objectID": "m01-euler_tour/coding-exercise.html",
    "href": "m01-euler_tour/coding-exercise.html",
    "title": "8¬† Exercise",
    "section": "",
    "text": "8.1 Exercise 01\nCode\n# If you are using colab, uncomment the following line\n# !sudo apt install libcairo2-dev pkg-config python3-dev\n# !pip install pycairo cairocffi\n# !pip install igraph\nDefine the edges\nCode\n# This is a placeholder for your code for the exercise\nedges = ...\nDefine the adjacnecy matrix (without for loops!)\nCode\nA = ...\nVisualize the graph\nCode\nimport igraph\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef visualize_graph(A, **params):\n  A = np.array(A)\n  src, trg = np.where(A)\n  g = igraph.Graph(directed=False)\n  g.add_vertices(A.shape[0])\n  for s, t in zip(src, trg):\n    for _ in range(A[s, t]):\n      g.add_edge(s, t)\n  return igraph.plot(g, **params)\n\nvisualize_graph(A)\nCheck if the graph has an Euler path",
    "crumbs": [
      "M01: Euler Tour",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Exercise</span>"
    ]
  },
  {
    "objectID": "m01-euler_tour/coding-exercise.html#exercise-01",
    "href": "m01-euler_tour/coding-exercise.html#exercise-01",
    "title": "8¬† Exercise",
    "section": "",
    "text": "Create a network of landmasses and bridges of Binghamton, NY.\nFind an Euler path that crosses all the bridges of Binghamton, NY exactly once.\n\n\n\n\nBinghamton Map",
    "crumbs": [
      "M01: Euler Tour",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Exercise</span>"
    ]
  },
  {
    "objectID": "m01-euler_tour/coding-exercise.html#exercise-02",
    "href": "m01-euler_tour/coding-exercise.html#exercise-02",
    "title": "8¬† Exercise",
    "section": "8.2 Exercise 02",
    "text": "8.2 Exercise 02\nLet‚Äôs create a network from pre-existing data and check if it has an Euler path.\n\nSelect a network of your choice from Netzschleuder. For convenience, choose a network of nodes less than 5000.\nDownload the csv version of the data by clicking something like ‚Äú3KiB‚Äù under csv column.\nUnzip the file and find ‚Äúedges.csv‚Äù, open it with a text editor to familiarize yourself with the format.\nLoad the data using pandas.\nGet the source and target nodes from the data to create an edge list.\nConstruct the adjacency matrix from the edge list.\nDraw the graph using igraph.\nCheck if the graph has an Euler path.\n\nLoad the data by\n\n\nCode\nimport pandas as pd\ndf = pd.read_csv('edges.csv') # load the data\ndisplay(df)\n\n\nThen, get the srce and target nodes to compose an edge list\n\n\nCode\nsrc = ...\ntrg = ...\nedges = ...\n\n\nCreate the adjacency matrix from the edge list\nGet the degree of each node tchubpqewzc ipython3 deg = ...\nVisualize the graph\n\n\nCode\nvisualize_graph(A)\n\n\nCheck if the graph has an Euler path tchubpqewzc ipython3",
    "crumbs": [
      "M01: Euler Tour",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Exercise</span>"
    ]
  },
  {
    "objectID": "m02-small-world/what-to-learn.html",
    "href": "m02-small-world/what-to-learn.html",
    "title": "9¬† Module 2: Small-world",
    "section": "",
    "text": "9.1 What to learn in this module\nIn this module, we will learn small-world experiments and conduct a small small-world experiment . We will learn: - Small-world experiment by Milgram - Different concepts of distance: path, walks, circuits, cycles, connectedness - How to load a large sparse network efficiently into memory - How to measure a distance between two nodes using igraph - Keywords: small-world experiment, six degrees of separation, path, walks, circuits, cycles, connectedness, connected component, weakly connected component, strongly connected component, compressed sparse row format.",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Module 2: Small-world</span>"
    ]
  },
  {
    "objectID": "m02-small-world/small-world-experiment.html",
    "href": "m02-small-world/small-world-experiment.html",
    "title": "10¬† Small-world experiment",
    "section": "",
    "text": "How far are two people in a social network? Milgram and his colleagues conducted a series of expriment to find out in the 1960s.\n:::{figure-md} milgram-small-world-experiment\n\nMilgram‚Äôs small world experiment.\n:::\nThe experiment went as follows: 1. Milgram first sent out packets to randomly selected people in Omaha, Nebraska, and Wichita, Kansas. 2. The recipient was asked to send the packet to the target person in Boston if they knew them. If not, they were to forward it to someone they knew on a first-name basis who might know the target. 3. The recipient continued to forward the packet to their acquaintances until it reached the target.\nThe results were surprising: out of the 160 letters sent, 64 successfully reached the target person by the chain of nearly six people, which was later called six degrees of separation. The results imply that, despite the fact that there were hundreds of millions of people in the United States, their social network was significantly compact, with two random people being connected to each other in only a few steps.\n\n\n\n\n\n\nTip\n\n\n\nThe term ‚ÄúSix degrees of separation‚Äù is commonly associated with Milgram‚Äôs experiment, but Milgram never used it. John Guare coined the term for his 1991 play and movie ‚ÄúSix Degrees of Separation.‚Äù\n\n\nThe results were later confirmed independently.\n\nYahoo research replicate the Milgram‚Äôs experiment by using emails. Started from more than 24,000 people, only 384 people reached the one of the 18 target person in 13 countries. Among the successful ones, the average length of the chain was about 4. When taken into account the broken chain, the average length was estimated between 5 and 7.{footcite}goel2009social\nResearchers in Facebook and University of Milan analyzed the social network n Facebook, which consisted of 721 million active users and 69 billion friendships. The average length of the shortest chain was found to be 4.74. {footcite}backstrom2012four",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Small-world experiment</span>"
    ]
  },
  {
    "objectID": "m02-small-world/wikirace.html",
    "href": "m02-small-world/wikirace.html",
    "title": "11¬† Wikirace",
    "section": "",
    "text": "11.0.1 What‚Äôs next\nLet us feel how small a large network can be by playing the Wikirace game.\nAt the end of the module, we will measure the average path length in a social network. Before jumping on, let us arm with some coding techniques to handle the network in the next two sections.",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Wikirace</span>"
    ]
  },
  {
    "objectID": "m02-small-world/wikirace.html#references",
    "href": "m02-small-world/wikirace.html#references",
    "title": "11¬† Wikirace",
    "section": "11.1 References",
    "text": "11.1 References",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Wikirace</span>"
    ]
  },
  {
    "objectID": "m02-small-world/pen-and-paper.html",
    "href": "m02-small-world/pen-and-paper.html",
    "title": "12¬† Why is our social network small world?",
    "section": "",
    "text": "‚úçÔ∏è It‚Äôs a small world!! 6 degrees of separation {footcite}esteban-moro-worksheet",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Why is our social network small world?</span>"
    ]
  },
  {
    "objectID": "m02-small-world/connectedness.html",
    "href": "m02-small-world/connectedness.html",
    "title": "13¬† Walks, Trails, Paths, and Connectedness",
    "section": "",
    "text": "13.1 Walks, Trails, Paths\nWhile we have already used the term path, let us make clear its definition, together with other related terms.\nQuestion: Is a path always a trail, and is a trail always a path?\n:::{figure-md} numbered-koningsberg-graph2\nLabeled Knigsberg graph\n:::\n:::{note} Are there shortest trails and shortest walks? Shortest trails and shortest walks are fundamentally equivalent to shortest paths. A shortest trail must visit each node only once (otherwise it would not be the shortest), and similarly, a shortest walk does not repeat nodes (otherwise it would not be the shortest), both forming a shortest path. :::",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Walks, Trails, Paths, and Connectedness</span>"
    ]
  },
  {
    "objectID": "m02-small-world/connectedness.html#walks-trails-paths",
    "href": "m02-small-world/connectedness.html#walks-trails-paths",
    "title": "13¬† Walks, Trails, Paths, and Connectedness",
    "section": "",
    "text": "A walk is a sequence of nodes that are connected to form a continous route in a network. For instance, walk (0, 1, 2, 3) is a walk in the graph of the bridges of Konigsberg. But the sequence (0,2,3,1) is not a walk, because the node 0 is not directly connected to node 2.\nA trail is a walk with no repeated edge. For instance, walk (0, 1, 2, 3) is also a trail as it does not cross the same edge twice. But walk (0,2,3,1,3) is not a trail due to the repeated edge (1,3).\nA path is a walk without repeated node. For instance, walk (0,1,2,3) is a path. But walk (0, 1, 2, 1, 2, 3) is not a path due to the repeated node 1 and 2.\nWhen a walk starts and ends at the same node, it is called a **loop*. If the loop is a trail, it is called a circuit. If the loop is a path, it is called a cycle.\n\n\n\n\n\n\n\nShortest Path is the path with the smallest number of edges (or nodes) between two nodes. A shortest path from node 0 to 2 is (0, 1, 2). Two nodes can have multiple shortest paths e.g., (0, 3, 2).\nThe shortest path length is the number of edges in the shortest path, not the number of nodes! üëàüëà",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Walks, Trails, Paths, and Connectedness</span>"
    ]
  },
  {
    "objectID": "m02-small-world/connectedness.html#connectedness",
    "href": "m02-small-world/connectedness.html#connectedness",
    "title": "13¬† Walks, Trails, Paths, and Connectedness",
    "section": "13.2 Connectedness",
    "text": "13.2 Connectedness\n\nA network is connected if there is a path between every pair of nodes.\nA network is disconnected if there is no path between some pairs of nodes.\nA connected component of a network is a set of nodes that are connected to each other.\nThe giant component of a network is the largest connected component that contains a significant fraction of nodes in the network (in order of the number of nodes).\n\n:::{figure-md} connected-components\n\nconnected components of a network. the nodes with the same color form a connected component.\n:::",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Walks, Trails, Paths, and Connectedness</span>"
    ]
  },
  {
    "objectID": "m02-small-world/connectedness.html#connectedness-in-directed-networks",
    "href": "m02-small-world/connectedness.html#connectedness-in-directed-networks",
    "title": "13¬† Walks, Trails, Paths, and Connectedness",
    "section": "13.3 Connectedness in directed networks",
    "text": "13.3 Connectedness in directed networks\nWe call a network is directed if the edges have a direction. Example directed networks include the network of Web pages, the network of friendships on X, the network of citations on academic papers.\nIn a directed network, a walk must follow the edge directions. Paths, trails, and loops extend similarly to directed networks. But one thing to keep in mind: a walk may not be reversible, meaning there can be a walk from one node to another but not vice versa.\nThis leads to two different types of connectedness as follows:\n\nStrong connectedness: A directed network is said to be strongly connected if there is a path from every node to every other node.\nWeak connectedness: A directed network is said to be weakly connected if there is a path from every node to every other node on its undirected counterpart.\n\n:::{figure-md} connected-components-directed\n\nconnected components of a network. the nodes with the same color form a connected component.\n:::\nQuestion: Is a strongly-connected component always a weakly-connected component?\nIn the next section, we will learn how to compute the shortest paths and connected components of a network using a library igraph.",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Walks, Trails, Paths, and Connectedness</span>"
    ]
  },
  {
    "objectID": "m02-small-world/which-tools.html",
    "href": "m02-small-world/which-tools.html",
    "title": "14¬† Toolbox for network analysis",
    "section": "",
    "text": "Here are some useful tools for network analysis in Python:\n\nPython built-in data structures (list, tuple, dict)\nnetworkx - a beginner-friendly library for network analysis\nigraph - a mature library with a wide range of algorithms\ngraph-tool - for stochastic block models\nscipy - for analyzing large networks\npytorch-geometric - for graph neural networks\n\nWhile networkx is a popular and beginner-friendly library for network analysis in Python, we‚Äôll be using igraph in this course. igraph is a mature library with a wide range of algorithms, originally developed for R. Why igraph instead of networkx? Because networkx has some persistent bugs in the implementations of some algorithms (e.g., LFR benchmark and weighted degree assortativity), which can skew the analysis. igraph offers more reliable implementations.\nWe‚Äôll also use scipy for scientific computing. scipy is one of the most popular Python libraries and also a powerful network analysis tool, especially for large networks. While it requires a bit more effort to learn, once you get the hang of it, you‚Äôll find it‚Äôs a powerful tool for your network analysis projects.",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Toolbox for network analysis</span>"
    ]
  },
  {
    "objectID": "m02-small-world/compressed-sparse-row.html",
    "href": "m02-small-world/compressed-sparse-row.html",
    "title": "15¬† Efficient representation for large sparse networks",
    "section": "",
    "text": "An adjacency matrix is a convenient way to represent a network. A challenge of handling large networks is that the adjacency matrix can be too large to fit in memrory. For example, a network with 10^5 nodes requires a 10^5 \\times 10^5 matrix, totaling 10 billion entries! A good news is that we do not need to hold all these entries in memory, if we know the network is sparse.\nMany networks in real-world are sparse, meaning most nodes connect to only a few others. The result is that the adjacency matrix often contains many zeros. This is where we can save significant memory by storing only the non-zero entries.\nCompressed Sparse Row (CSR) is an efficient way to store sparse networks by treating the adjacency matrix like a scatter plot. Instead of storing all entries, CSR only keeps track of the ‚Äúcoordinates‚Äù (row and column indices) of non-zero entries, along with their values.\n\n\n\n\n\n\nOptional Exercise\n\n\n\n:class: tip For those who are interested in the details of CSR format, please do the following: - üìù Pen and paper exercise here - üíª (Advanced) Coding exercise in the Appendix.\n\n\n:::{figure-md} csr_matirx\n\nCompressed Sparse Row (CSR) matrix. Source: Medium: Sparse GEMM and Tensor Core‚Äôs Structured Sparsity :::\nThe CSR format is implemented in the scipy library. It is straightforward to convert the CSR matrix from the dense adjacency matrix.\n\n\nCode\nfrom scipy.sparse import csr_matrix\n\nA = [[0, 2, 0, 1],\n     [2, 0, 2, 1],\n     [0, 2, 0, 1],\n     [1, 1, 1, 0]]\n\nA_csr = csr_matrix(A)\nA_csr\n\n\nIf you have an edge list, you can directly generate the CSR matrix without creating the dense matrix first.\n\n\nCode\nfrom scipy.sparse import csr_matrix\n\nedges = [(0,1), (0, 1), (0, 3), (1, 2), (1, 2), (1, 3), (2, 3)]\n\nsrc = [edge[0] for edge in edges]\ntrg = [edge[1] for edge in edges]\nvalues = [1 for _ in edges]\nA_csr = csr_matrix((values, (src, trg)), shape=(4, 4))\nA_csr\n\n\nwhere src, trg, and values are lists of the source nodes, target nodes, and edge weights, respectively.",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Efficient representation for large sparse networks</span>"
    ]
  },
  {
    "objectID": "m02-small-world/connectedness-hands-on.html",
    "href": "m02-small-world/connectedness-hands-on.html",
    "title": "16¬† Computing the Shortest Paths and Connected Components",
    "section": "",
    "text": "16.1 igraph\nLet‚Äôs use igraph to compute the shortest paths and connected components. We will then use scipy to compute them.",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Computing the Shortest Paths and Connected Components</span>"
    ]
  },
  {
    "objectID": "m02-small-world/connectedness-hands-on.html#igraph",
    "href": "m02-small-world/connectedness-hands-on.html#igraph",
    "title": "16¬† Computing the Shortest Paths and Connected Components",
    "section": "",
    "text": "16.1.1 Create a graph\nLet us create a graph of 4 nodes and 4 edges. Our edge list is given by\n\n\nCode\nedge_list = [(0, 1), (1, 2), (0, 2), (0, 3)]\n\n\nigraph has an object Graph that stores a graph and provides methods to manipulate and analyze the graph. To create a graph from an edge list, we can use the add_edges method.\n\n\nCode\nimport igraph\n\ng = igraph.Graph() # Create an empty graph\ng.add_vertices(4) # Add 4 vertices\ng.add_edges(edge_list) # Add edges to the graph\n\n# Plot the graph\nigraph.plot(g, bbox=(150, 150), vertex_label=list(range(4)))\n\n\n\n\n16.1.2 Shortest Paths\nLet‚Äôs compute the paths between nodes 2 and 3.\n\n\nCode\ng.get_all_simple_paths(2, to=3)\n\n\nThis method enumerates all possible simple paths between two nodes. This is OK for small networks but quickly becomes impractical for larger networks, as the number of paths increases exponentially with the size of the network.\nOften, we are interested in the shortest path, which is the path with the smallest number of edges. The shortest path can be computed by using the get_shortest_paths method.\n\n\nCode\ng.get_shortest_paths(2, to=3)\n\n\nNote that there can be multiple shortest paths between two nodes. If we are interested in the ‚Äúlength‚Äù instead of the path itself, there is a more efficient function distances.\n\n\nCode\ng.distances(2, 3)\n\n\n\n\n16.1.3 Connected Components\nIn the simple network above, we can see that for every pair of nodes, we can find a path connecting them. This is the definition of a connected graph. We can check this property for a given graph:\n\n\nCode\ncomponents = g.connected_components()\n\n\nThe components is a special object called VertexClustering in igraph. It has the following useful functions and attributes:\n\n\nCode\nprint(\"membership: \", components.membership)  # the IDs of the component each node belongs to.\nprint(\"sizes: \", list(components.sizes()))  # the number of nodes in each component.\nprint(\"giant: \", components.giant())  # a subgraph of the largest connected component.\n\n\n\n16.1.3.1 Exercise 01 üèãÔ∏è‚Äç‚ôÄÔ∏èüí™üß†\n\nNow, let us add two nodes that are not connected to the existing graph, and call connected_components again. üîó‚ûï\nCall get_shortest_paths between the two new nodes in different connected components. üõ£Ô∏èüîç\nGet the largest connected component. üåêüèÜ\n\n\n\n\n16.1.4 Directed networks\nLet‚Äôs extend these ideas about paths and connected components to directed graphs.\n\n\nCode\nedge_list =[(0, 1), (1, 2), (2, 1), (2, 3), (2, 5), (3, 1), (3, 4), (3, 5), (4, 5), (5, 3)]\ng = igraph.Graph(directed=True)\ng.add_vertices(6)\ng.add_edges(edge_list)\nigraph.plot(g, bbox=(250, 250), vertex_label=list(range(6)))\n\n\nIn directed graphs, edges and paths can be one-way. For instance, in our graph, you can go from node 0 to node 3, but not from 3 to 0.\n\n\nCode\nprint(\"From 0 to 3\", g.get_all_simple_paths(0, to=3))\nprint(\"From 3 to 0\", g.get_all_simple_paths(3, to=0))\n\n\nThe shortest path from 4 to 1 must take a longer route due to edge directions.\n\n\nCode\ng.get_shortest_paths(4, 1)\n\n\nDirected networks have two kinds of connected components.\n\nStrongly connected components: Strongly connected means that there exists a direct path between every pair of nodes, i.e., that from any node to any other nodes while respecting the edge directionality.\nWeakly connected components: Weakly connected means that there exists a path between every pair of nodes when ignoring the edge directionality.\n\n\n\nCode\nprint(list(g.connected_components(mode=\"strong\")))\nprint(list(g.connected_components(mode=\"weak\")))",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Computing the Shortest Paths and Connected Components</span>"
    ]
  },
  {
    "objectID": "m02-small-world/connectedness-hands-on.html#scipy",
    "href": "m02-small-world/connectedness-hands-on.html#scipy",
    "title": "16¬† Computing the Shortest Paths and Connected Components",
    "section": "16.2 Scipy",
    "text": "16.2 Scipy\nWe can create a graph, compute the shortest paths, and connected components using scipy.\n\n16.2.1 Create a graph\nWith scipy, we represent a network by an adjacency matrix using something called a Compressed Sparse Row (CSR) matrix. CSR matrices are efficient format for storing and manipulating sparse matrices. Why sparse is highlighed here? Because in many networks, the adjacency matrix is sparse, i.e., most of the entries are zero. For example, here is the adjacency matrix of a real-world network:\n\nMost of the entries in this adjacency matrix are white, and white means that the value of the entry is zero. And the adjacency matrix looks very white! This is pretty common in real-world networks. We call these matrices ‚Äúsparse‚Äù because they are mostly empty. And CSR matrices are a way to store these sparse matrices efficiently. Don‚Äôt worry too much about the technical details for now. If you‚Äôre curious to learn more, you can check out the Appendix.\nThe great thing is, scipy (especially the scipy.sparse module) provides efficient tools for working with these sparse matrices. This comes in really handy when we‚Äôre working with large networks.\nLet create a graph using scipy.\n\n\nCode\nfrom scipy import sparse # We will use sparse module in scipy\n\nedge_list = [(0, 1), (1, 2), (0, 2), (0, 3)]\n\nsrc = [src for src, dst in edge_list]\ntrg = [dst for src, dst in edge_list]\nweight = [1 for src, dst in edge_list]\n\nA = sparse.csr_matrix((weight, (src, trg)), shape=(4, 4))\nA = A + A.T # Make the adjacency matrix symmetric\nA\n\n\nLet‚Äôs break down the code. - src and trg are the source and target nodes of the edges. - weight is the weight of the edges. - sparse.csr_matrix((weight, (src, trg))) creates a sparse matrix, filling weight into the positions specified by (src, trg). - A.T is the transpose of A and A + A.T makes the adjacency matrix symmetric.\nThe CSR matrix does not print nicely. But you can see it by converting to a numpy array and printing it.\n\n\nCode\nA.toarray()",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Computing the Shortest Paths and Connected Components</span>"
    ]
  },
  {
    "objectID": "m02-small-world/connectedness-hands-on.html#shortest-paths-1",
    "href": "m02-small-world/connectedness-hands-on.html#shortest-paths-1",
    "title": "16¬† Computing the Shortest Paths and Connected Components",
    "section": "16.3 Shortest Paths",
    "text": "16.3 Shortest Paths\nThe sparse module has a submodule csgraph that provides APIs for network analysis.\nFor example, csgraph.shortest_path computes the shortest path length from a specific node to all other nodes.\n\n\nCode\nfrom scipy.sparse import csgraph\n\n# `indices` is the node to compute the shortest path from.\nD = csgraph.shortest_path(A, indices=2, directed=False)\nD\n\n\nAdvanced: If you want to get the actual paths (i.e., list of nodes in the path), you can pass return_predecessors=True to csgraph.shortest_path.\n\n\nCode\nD, predecessors = csgraph.shortest_path(A, indices=2, directed=False, return_predecessors=True)",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Computing the Shortest Paths and Connected Components</span>"
    ]
  },
  {
    "objectID": "m02-small-world/connectedness-hands-on.html#connected-components-1",
    "href": "m02-small-world/connectedness-hands-on.html#connected-components-1",
    "title": "16¬† Computing the Shortest Paths and Connected Components",
    "section": "16.4 Connected Components",
    "text": "16.4 Connected Components\nConnected components can be computed by csgraph.connected_components.\n\n\nCode\nn_components, labels = csgraph.connected_components(A, directed=False, return_labels=True)\n\nprint(\"Number of connected components:\", n_components)\nprint(\"Labels:\", labels)\n\n\n\nn_components is the number of connected components.\nlabels is an array of length n_nodes where each element is the ID of the connected component the node belongs to.",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Computing the Shortest Paths and Connected Components</span>"
    ]
  },
  {
    "objectID": "m02-small-world/connectedness-hands-on.html#exercise-02",
    "href": "m02-small-world/connectedness-hands-on.html#exercise-02",
    "title": "16¬† Computing the Shortest Paths and Connected Components",
    "section": "16.5 Exercise 02 üèãÔ∏è‚Äç‚ôÄÔ∏èüí™üß†",
    "text": "16.5 Exercise 02 üèãÔ∏è‚Äç‚ôÄÔ∏èüí™üß†\nLet‚Äôs compute the average path length of a network from pre-existing data and check if how long on average it takes to go from any node to any other node.\n\nSelect a network of your choice from Netzschleuder. For convenience, choose a network of nodes less than 5000.\nDownload the csv version of the data by clicking something like ‚Äú3KiB‚Äù under csv column.\nUnzip the file and find ‚Äúedges.csv‚Äù, open it with a text editor to familiarize yourself with the format.\nLoad the data using pandas.\nGet the source and target nodes from the data to create an edge list.\nConstruct a graph from the edge list, either using igraph or scipy.\nCompute the average path length\n\nHint: Finding all shortest paths is a qubic time operation with respect to the number of nodes, or simply put, it takes a long time to compute. So compute the ‚Äúestimate‚Äù by sampling many pairs of nodes uniformly at random and computing the average path length.",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>16</span>¬† <span class='chapter-title'>Computing the Shortest Paths and Connected Components</span>"
    ]
  },
  {
    "objectID": "m02-small-world/assignment.html",
    "href": "m02-small-world/assignment.html",
    "title": "17¬† Assignment",
    "section": "",
    "text": "We will compute the average path length of a network of scientists. The network is constructed from {footcite:p}sinatra2016quantifying, where each node represents a scientist and two scientists are connected if they have co-authored a paper in Physical Review Journals from American Physical Society.\n\nFor students enrolled in SSIE 641\n\nYou will receive a dedicated link to the assignment repository from the instructor.\n\nFor those who are not enrolled in SSIE 641\n\nYou can access the assignment repository at Github.\nThis repository does not offer auto-grading. But you can grade the assignment by yourself by\n\nbash grading-toolkit/grade_notebook.sh tests/test_01.py assignment/assignment.ipynb\nbash grading-toolkit/grade_notebook.sh tests/test_02.py assignment/assignment.ipynb",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>17</span>¬† <span class='chapter-title'>Assignment</span>"
    ]
  },
  {
    "objectID": "m02-small-world/appendix.html",
    "href": "m02-small-world/appendix.html",
    "title": "18¬† Appendix",
    "section": "",
    "text": "18.1 Compressed Sparse Row (CSR) format\nCSR format is implemented in scipy. This consists of three arrays called indptr, indices, and data. For example,\nCode\nimport networkx as nx\nfrom scipy import sparse\n\nG = nx.karate_club_graph()\nA = sparse.csr_matrix(nx.adjacency_matrix(G))\n\nprint(\"A.indices:\", A.indices[:5])\nprint(\"A.indptr:\", A.indptr[:5])\nprint(\"A.data:\", A.data[:5])\nWe will walk you through what these arrays mean, how they are generated, and how we can leverage them for efficient computations.",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Appendix</span>"
    ]
  },
  {
    "objectID": "m02-small-world/appendix.html#compressed-sparse-row-csr-format",
    "href": "m02-small-world/appendix.html#compressed-sparse-row-csr-format",
    "title": "18¬† Appendix",
    "section": "",
    "text": "18.1.1 How to generate CSR format from an adjacency matrix\nLet‚Äôs walk you through how to store an example adjacency matrix in Compressed Sparse Row (CSR) format. Our example adjacency matrix is as follows.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n0\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1\n\n\n1\n\n\n\n\n\n\n\n1\n\n\n2\n\n1\n\n1\n\n\n\n\n\n\n1\n\n\n3\n\n\n1\n\n1\n1\n1\n\n\n\n\n\n\n4\n\n\n\n1\n\n\n\n1\n\n\n\n\n\n5\n\n\n\n1\n\n\n\n\n\n\n\n\n\n6\n\n\n\n1\n\n\n\n\n1\n1\n\n\n\n7\n\n\n\n\n1\n\n\n\n\n\n\n\n\n8\n\n\n\n\n\n\n1\n\n\n\n1\n\n\n9\n\n\n\n\n\n\n1\n\n\n\n1\n\n\n10\n1\n1\n1\n\n\n\n\n\n1\n1\n\n\n\n\n\nWe will first create adjacency list, which is a dictionary consisting of the row IDs and column IDs for the non-zero entries in the adjacency matrix.\n\n\n\\{\\text{Row ID}: (\\text{Column ID}, \\text{Value})\\}\n\n\nConcretely, in Python,\n\n\nCode\nadj_list = {\n  0:[(10,1)],\n  1:[(2,1), (10, 1)],\n  2:[(1,1), (3,1), (10, 1)],\n  3:[(2,1), (4,1), (5,1), (6,1)],\n  #...\n}\n\n\nCSR format is a concatenation of the keys and values of the adjacency list, respectively. The CSR format has a concatenated array of the values, one for column IDs and one for the values, called indices and data, respectively.\n\n\nCode\nimport numpy as np\n\nindices = np.array([vv[0] for k, v in adj_list.items() for vv in v])\nindices\n\n\n\n\nCode\ndata = np.array([vv[1] for k, v in adj_list.items() for vv in v])\ndata\n\n\nAdditionally, the CSR format has another array called indptr, which stores the Row IDs of the non-zero entries in the adjacency matrix. This indptr array has a value such that indptr[i] is the first index of indices that corresponds to the i-th row of the adjacency matrix. This can be generated by\n\n\nCode\nindptr = np.cumsum([0] + [len(adj_list[i]) for i in range(len(adj_list))])\nindptr\n\n\nwhere we added 0 at the beginning of the array to represent the first non-zero entry in the first row. The first row ends at index len(adj_list[0])-1, and the second row starts at index len(adj_list[0]) and ends at index len(adj_list[0])+len(adj_list[1])-1, and so on.\nNow we have three compressed vectors indptr, indices, and data, that together form the CSR format for the adjacency matrix.\n\n\n18.1.2 How to use CSR format for efficient computations\nThe key advantage of the CSR representation is the memory efficiency. But you can leverage the CSR format for more efficient computations, if you know the semantics of indptr, indices, and data arrays.\nFor instance, one can compute the degree of a node by using\n\n\nCode\nnode = 1\ndegree = indptr[node+1] - indptr[node]\ndegree\n\n\nLet us break down the above code. - indptr[node] is the first index of the indices array that corresponds to the node-th row of the adjacency matrix. - indptr[node+1] is the first index of the indices array that corresponds to the (node+1)-th row of the adjacency matrix. - Thus, indptr[node+1] - indptr[node] is the number of non-zero entries in the node-th row of the adjacency matrix, which is the degree of the node-th node.\nUsing indices, it is easy to identify the neighbors of a given node by using\n\n\nCode\nneighbors = indices[indptr[node]:indptr[node+1]]\nneighbors\n\n\nwhere indices[indptr[node]:indptr[node+1]] is the corresponding column IDs of the non-zero entries in the node-th row of the adjacency matrix, which corresponds to the node IDs connected to the node-th node.\nThe edge weights to the neighbors can be obtained by using\n\n\nCode\nedge_weights = data[indptr[node]:indptr[node+1]]\nedge_weights",
    "crumbs": [
      "M02: Small World",
      "<span class='chapter-number'>18</span>¬† <span class='chapter-title'>Appendix</span>"
    ]
  }
]