{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "jupyter:\n",
        "  jupytext:\n",
        "    text_representation:\n",
        "      extension: .md\n",
        "      format_name: markdown\n",
        "      format_version: '1.3'\n",
        "      jupytext_version: 1.16.3\n",
        "  kernelspec:\n",
        "    display_name: Python 3\n",
        "    language: python\n",
        "    name: python3\n",
        "---\n",
        "\n",
        "<a target=\"_blank\" href=\"https://colab.research.google.com/github/skojaku/adv-net-sci/blob/main/notebooks/exercise-m06-centrality.ipynb\">\n",
        "  <img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/>\n",
        "</a>\n",
        "\n",
        "# Computing centrality with Python\n",
        "\n",
        "## Network of university students\n",
        "\n",
        "Let's compute the centrality of the network using Python igraph.\n",
        "\n",
        "```python\n",
        "# Uncomment if you use Colab\n",
        "#!pip install igraph\n",
        "```\n",
        "\n",
        "```python\n",
        "import igraph\n",
        "names  = ['Sarah', 'Mike', 'Emma', 'Alex', 'Olivia', 'James', 'Sophia', 'Ethan', 'Ava', 'Noah', 'Lily', 'Lucas', 'Henry']\n",
        "edge_list = [(0, 1), (0, 2), (1, 2), (2, 3), (3, 4), (3, 5), (3, 6), (4, 5), (6, 7), (6, 8), (6, 9), (7, 8), (7, 9), (8, 9), (9, 10), (9, 11), (9, 12)]\n",
        "g = igraph.Graph()\n",
        "g.add_vertices(13)\n",
        "g.vs[\"name\"] = names\n",
        "g.add_edges(edge_list)\n",
        "igraph.plot(g, vertex_label=g.vs[\"name\"])\n",
        "```\n",
        "\n",
        "`igraph` offers a wide range of centrality measures as methods of the `igraph.Graph` class.\n",
        "\n",
        "- **Degree centrality**: `igraph.Graph.degree()`\n",
        "- **Closeness centrality**: `igraph.Graph.closeness()`\n",
        "- **Betweenness centrality**: `igraph.Graph.betweenness()`\n",
        "- **Harmonic centrality**: `igraph.Graph.harmonic_centrality()`\n",
        "- **Eccentricity**: `igraph.Graph.eccentricity()`\n",
        "- **Eigenvector centrality**: `igraph.Graph.eigenvector_centrality()`\n",
        "- **PageRank centrality**: `igraph.Graph.personalized_pagerank()`\n",
        "\n",
        "For example, the closeness centrality is computed by\n",
        "\n",
        "```python\n",
        "g.closeness()\n",
        "```\n",
        "\n",
        "### Computing Katz centrality\n",
        "\n",
        "Let's compute the Katz centrality without using igraph.\n",
        "Let us first define the adjacency matrix of the graph\n",
        "\n",
        "```python\n",
        "A = g.get_adjacency_sparse()\n",
        "```\n",
        "\n",
        "which is the scipy CSR sparse matrix. The Katz centrality is given by\n",
        "\n",
        "$$\n",
        "\n",
        "\\mathbf{c} = \\beta \\mathbf{1} + \\alpha \\mathbf{A} \\mathbf{c}\n",
        "\n",
        "$$\n",
        "\n",
        "So, how do we solve this? We can use a linear solver but here we will use a simple method:\n",
        "\n",
        "1. Initialize $\\mathbf{c}$ with a random vector.\n",
        "2. Compute the right hand side of the equation and update $\\mathbf{c}$.\n",
        "3. Repeat the process until $\\mathbf{c}$ converges.\n",
        "\n",
        "Let's implement this.\n",
        "\n",
        "```python\n",
        "import numpy as np\n",
        "\n",
        "alpha, beta = 0.1, 0.05 # Hyperparameters\n",
        "n_nodes = g.vcount() # number of nodes\n",
        "c = np.random.rand(n_nodes, 1) # column random vector\n",
        "\n",
        "for _ in range(100):\n",
        "    c_next = beta * np.ones((n_nodes, 1)) + alpha * A * c\n",
        "    if np.linalg.norm(c_next - c) < 1e-6:\n",
        "        break\n",
        "    c = c_next\n",
        "print(c)\n",
        "```\n",
        "\n",
        "- Does the centrality converge?\n",
        "- Change the hyperparameter and see how the result changes 😉\n",
        "If the centrality diverges, think about why it diverges.\n",
        "\n",
        "*Hint*: Katz centrality can be analytically computed by\n",
        "\n",
        "$$\n",
        "\n",
        "\\mathbf{c} = \\beta \\left(\\mathbf{I} -  \\alpha \\mathbf{A} \\right)^{-1} \\mathbf{1}\n",
        "\n",
        "$$\n",
        "\n",
        "### Exercise (Optional)\n",
        "\n",
        "Compute the PageRank centrality of this graph\n",
        "\n",
        "```python\n",
        "\n",
        "```\n",
        "\n",
        "## Network of ancient Roman roads\n",
        "\n",
        "### Load the data & construct the network\n",
        "\n",
        "```python\n",
        "import pandas as pd\n",
        "\n",
        "root = \"https://raw.githubusercontent.com/skojaku/adv-net-sci/main/data/roman-roads\"\n",
        "node_table = pd.read_csv(f\"{root}/node_table.csv\")\n",
        "edge_table = pd.read_csv(f\"{root}/edge_table.csv\")\n",
        "```\n",
        "\n",
        "The node table:\n",
        "\n",
        "```python\n",
        "node_table.head(3)\n",
        "```\n",
        "\n",
        "The edge table:\n",
        "\n",
        "```python\n",
        "edge_table.head(3)\n",
        "```\n",
        "\n",
        "Let's construct a network from the node and edge tables.\n",
        "\n",
        "```python\n",
        "import igraph\n",
        "\n",
        "g = igraph.Graph() # create an empty graph\n",
        "g.add_vertices(node_table[\"node_id\"].values) # add nodes\n",
        "g.add_edges(list(zip(edge_table[\"src\"].values, edge_table[\"trg\"].values))) # add edges\n",
        "```\n",
        "\n",
        "which looks like this:\n",
        "\n",
        "```python\n",
        "coord = list(zip(node_table[\"lon\"].values, -node_table[\"lat\"].values))\n",
        "igraph.plot(g, layout = coord, vertex_size = 5)\n",
        "```\n",
        "\n",
        "### Exercise 🏛️\n",
        "\n",
        "1. Compute the following centrality measures:\n",
        "    - Degree centrality 🔢\n",
        "    - Eigenvector centrality\n",
        "    - PageRank centrality\n",
        "    - Katz centrality\n",
        "    - Betweenness centrality\n",
        "    - Closeness centrality\n",
        "2. Plot the centrality measures on the map and see in which centrality Rome is the most important node. 🗺️🏛️ (as beautiful as possible!!)\n"
      ],
      "id": "e3fb7084"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "jupytext": {
      "text_representation": {
        "extension": ".md",
        "format_name": "markdown",
        "format_version": "1.3",
        "jupytext_version": "1.16.3"
      }
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}