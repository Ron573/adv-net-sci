{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<a target=\"_blank\" href=\"https://colab.research.google.com/github/skojaku/adv-net-sci/blob/main/notebooks/exercise-m02-small-world.ipynb\">\n",
        "  <img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/>\n",
        "</a>\n",
        "\n",
        "# Efficient Network Representation and Computing Paths\n",
        "\n",
        "## Efficient representation for large sparse networks\n",
        "\n",
        "An adjacency matrix is a convenient way to represent a network.\n",
        "A challenge of handling large networks is that the adjacency matrix can be too large to fit in memrory.\n",
        "For example, a network with $10^5$ nodes requires a $10^5 \\times 10^5$ matrix, totaling $10$ billion entries!\n",
        "A good news is that we do not need to hold all these entries in memory, if we know the network is *sparse*.\n",
        "\n",
        "Many networks in real-world are sparse, meaning most nodes connect to only a few others.\n",
        "The result is that the adjacency matrix often contains many zeros.\n",
        "This is where we can save significant memory by storing only the non-zero entries.\n",
        "\n",
        "**Compressed Sparse Row (CSR)** is an efficient way to store sparse networks by treating the adjacency matrix like a scatter plot. Instead of storing all entries, CSR only keeps track of the \"coordinates\" (row and column indices) of non-zero entries, along with their values.\n",
        "\n",
        "::: {.callout-note title=\"Optional Exercise\"}\n",
        ":class: tip\n",
        "For those who are interested in the details of CSR format, please do the following:\n",
        "- üìù Pen and paper exercise [here](./pen-paper-csr/exercise.pdf)\n",
        "- üíª (Advanced) Coding exercise in the [Appendix](./appendix.qmd).\n",
        "\n",
        ":::\n",
        "\n",
        "\n",
        "::: {#fig-csr_matirx}\n",
        "\n",
        "<img src=\"https://miro.medium.com/v2/resize:fit:1100/format:webp/0*zWhtdW4nYTSO3nya.gif\" width=\"100%\">\n",
        "\n",
        "Compressed Sparse Row (CSR) matrix. Source: [Medium: Sparse GEMM and Tensor Core's Structured Sparsity](https://medium.com/@hxu296/exploring-spgemm-and-nvidias-leap-in-deep-neural-network-efficiency-d367adc68791)\n",
        ":::\n",
        "\n",
        "The CSR format is implemented in the [scipy](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html) library. It is straightforward to convert the CSR matrix from the *dense* adjacency matrix."
      ],
      "id": "67799bde"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from scipy.sparse import csr_matrix\n",
        "\n",
        "A = [[0, 2, 0, 1],\n",
        "     [2, 0, 2, 1],\n",
        "     [0, 2, 0, 1],\n",
        "     [1, 1, 1, 0]]\n",
        "\n",
        "A_csr = csr_matrix(A)\n",
        "A_csr"
      ],
      "id": "532e50af",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "If you have an *edge list*, you can directly generate the CSR matrix without creating the dense matrix first."
      ],
      "id": "8a564f7e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from scipy.sparse import csr_matrix\n",
        "\n",
        "edges = [(0,1), (0, 1), (0, 3), (1, 2), (1, 2), (1, 3), (2, 3)]\n",
        "\n",
        "src = [edge[0] for edge in edges]\n",
        "trg = [edge[1] for edge in edges]\n",
        "values = [1 for _ in edges]\n",
        "A_csr = csr_matrix((values, (src, trg)), shape=(4, 4))\n",
        "A_csr"
      ],
      "id": "32849a77",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "where `src`, `trg`, and `values` are lists of the source nodes, target nodes, and edge weights, respectively.\n",
        "\n",
        "## Computing Shortest Paths and Connected Components\n",
        "\n",
        "Let's use `igraph` to compute the shortest paths and connected components. We will then use `scipy` to compute them."
      ],
      "id": "4e0e796f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# If you are using Google Colab, uncomment the following line to install igraph\n",
        "# !sudo apt install libcairo2-dev pkg-config python3-dev\n",
        "# !pip install pycairo cairocffi\n",
        "# !pip install igraph"
      ],
      "id": "6fdd0055",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### igraph\n",
        "\n",
        "### Create a graph\n",
        "\n",
        "Let us create a graph of 4 nodes and 4 edges. Our edge list is given by"
      ],
      "id": "deaa8210"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "edge_list = [(0, 1), (1, 2), (0, 2), (0, 3)]"
      ],
      "id": "cfa69d6f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "`igraph` has an object `Graph` that stores a graph and provides methods to manipulate and analyze the graph. To create a graph from an edge list, we can use the `add_edges` method."
      ],
      "id": "e4e29298"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import igraph\n",
        "\n",
        "g = igraph.Graph() # Create an empty graph\n",
        "g.add_vertices(4) # Add 4 vertices\n",
        "g.add_edges(edge_list) # Add edges to the graph\n",
        "\n",
        "# Plot the graph\n",
        "igraph.plot(g, bbox=(150, 150), vertex_label=list(range(4)))"
      ],
      "id": "6109325d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Shortest Paths\n",
        "\n",
        "Let's compute the paths between nodes 2 and 3."
      ],
      "id": "5a8d71c6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "g.get_all_simple_paths(2, to=3)"
      ],
      "id": "4f097dd8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This method enumerates all possible simple paths between two nodes. This is OK for small networks but quickly becomes impractical for larger networks, as the number of paths increases exponentially with the size of the network.\n",
        "\n",
        "Often, we are interested in the shortest path, which is the path with the smallest number of edges. The shortest path can be computed by using the `get_shortest_paths` method."
      ],
      "id": "b0554e89"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "g.get_shortest_paths(2, to=3)"
      ],
      "id": "ca16809c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note that there can be multiple shortest paths between two nodes. If we are interested in the \"length\" instead of the path itself, there is a more efficient function `distances`."
      ],
      "id": "bbf8dfcb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "g.distances(2, 3)"
      ],
      "id": "0cd07f99",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Connected Components\n",
        "\n",
        "In the simple network above, we can see that for every pair of nodes, we can find a path connecting them. This is the definition of a connected graph. We can check this property for a given graph:"
      ],
      "id": "7563553d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "components = g.connected_components()"
      ],
      "id": "cdefa706",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The `components` is a special object called [VertexClustering](https://python.igraph.org/en/0.11.6/api/igraph.VertexClustering.html) in `igraph`.\n",
        "It has the following useful functions and attributes:"
      ],
      "id": "603c9b51"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(\"membership: \", components.membership)  # the IDs of the component each node belongs to.\n",
        "print(\"sizes: \", list(components.sizes()))  # the number of nodes in each component.\n",
        "print(\"giant: \", components.giant())  # a subgraph of the largest connected component."
      ],
      "id": "5070a620",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### Exercise 01 üèãÔ∏è‚Äç‚ôÄÔ∏èüí™üß†\n",
        "\n",
        "1. Now, let us add two nodes that are not connected to the existing graph, and call `connected_components` again. üîó‚ûï\n",
        "\n",
        "2. Call `get_shortest_paths` between the two new nodes in different connected components. üõ£Ô∏èüîç\n",
        "\n",
        "3. Get the largest connected component. üåêüèÜ"
      ],
      "id": "4d067f7f"
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Directed networks\n",
        "Let's extend these ideas about paths and connected components to directed graphs."
      ],
      "id": "cc392bb9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "edge_list =[(0, 1), (1, 2), (2, 1), (2, 3), (2, 5), (3, 1), (3, 4), (3, 5), (4, 5), (5, 3)]\n",
        "g = igraph.Graph(directed=True)\n",
        "g.add_vertices(6)\n",
        "g.add_edges(edge_list)\n",
        "igraph.plot(g, bbox=(250, 250), vertex_label=list(range(6)))"
      ],
      "id": "6bc85777",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "In directed graphs, edges and paths can be one-way. For instance, in our graph, you can go from node 0 to node 3, but not from 3 to 0."
      ],
      "id": "8f8074b7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(\"From 0 to 3\", g.get_all_simple_paths(0, to=3))\n",
        "print(\"From 3 to 0\", g.get_all_simple_paths(3, to=0))"
      ],
      "id": "6d79815b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The shortest path from 4 to 1 must take a longer route due to edge directions."
      ],
      "id": "bf977517"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "g.get_shortest_paths(4, 1)"
      ],
      "id": "ad07f4ed",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Directed networks have two kinds of connected components.\n",
        "\n",
        "- **Strongly connected components:** Strongly connected means that there exists a direct path between every pair of nodes, i.e., that from any node to any other nodes while respecting the edge directionality.\n",
        "- **Weakly connected components:** Weakly connected means that there exists a path between every pair of nodes when ignoring the edge directionality."
      ],
      "id": "4bfa2ab1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(list(g.connected_components(mode=\"strong\")))\n",
        "print(list(g.connected_components(mode=\"weak\")))"
      ],
      "id": "f3da9fe4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Scipy\n",
        "\n",
        "We can create a graph, compute the shortest paths, and connected components using `scipy`.\n",
        "\n",
        "### Create a graph\n",
        "\n",
        "\n",
        "With scipy, we represent a network by an adjacency matrix using something called a *Compressed Sparse Row (CSR) matrix*. CSR matrices are efficient format for storing and manipulating *sparse* matrices. Why *sparse* is highlighed here? Because in many networks, the adjacency matrix is sparse, i.e., most of the entries are zero. For example, here is the adjacency matrix of a real-world network:\n",
        "\n",
        "![](https://www.researchgate.net/publication/263506932/figure/fig1/AS:392539896074252@1470600212952/Scale-free-Network-left-its-adjacency-matrix-upper-right-and-degree-distribution.png)\n",
        "\n",
        "Most of the entries in this adjacency matrix are white, and white means that the value of the entry is zero. And the adjacency matrix looks very white! This is pretty common in real-world networks. We call these matrices \"sparse\" because they are mostly empty. And CSR matrices are a way to store these sparse matrices efficiently. Don't worry too much about the technical details for now. If you're curious to learn more, you can check out the [Appendix](appendix.qmd).\n",
        "\n",
        "The great thing is, `scipy` (especially the `scipy.sparse` module) provides efficient tools for working with these sparse matrices. This comes in really handy when we're working with large networks.\n",
        "\n",
        "Let create a graph using scipy."
      ],
      "id": "dc532f29"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from scipy import sparse # We will use sparse module in scipy\n",
        "\n",
        "edge_list = [(0, 1), (1, 2), (0, 2), (0, 3)]\n",
        "\n",
        "src = [src for src, dst in edge_list]\n",
        "trg = [dst for src, dst in edge_list]\n",
        "weight = [1 for src, dst in edge_list]\n",
        "\n",
        "A = sparse.csr_matrix((weight, (src, trg)), shape=(4, 4))\n",
        "A = A + A.T # Make the adjacency matrix symmetric\n",
        "A"
      ],
      "id": "011a2226",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Let's break down the code.\n",
        "- `src` and `trg` are the source and target nodes of the edges.\n",
        "- `weight` is the weight of the edges.\n",
        "- `sparse.csr_matrix((weight, (src, trg)))` creates a sparse matrix, filling `weight` into the positions specified by `(src, trg)`.\n",
        "- `A.T` is the transpose of `A` and `A + A.T` makes the adjacency matrix symmetric.\n",
        "\n",
        "The CSR matrix does not print nicely. But you can see it by converting to a numpy array and printing it."
      ],
      "id": "dec96bde"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "A.toarray()"
      ],
      "id": "4e1e6e81",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Shortest Paths\n",
        "\n",
        "The `sparse` module has a submodule `csgraph` that provides APIs for network analysis.\n",
        "\n",
        "For example, `csgraph.shortest_path` computes the shortest path length from a specific node to all other nodes."
      ],
      "id": "25a5fff2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from scipy.sparse import csgraph\n",
        "\n",
        "# `indices` is the node to compute the shortest path from.\n",
        "D = csgraph.shortest_path(A, indices=2, directed=False)\n",
        "D"
      ],
      "id": "f57c506d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Advanced:** If you want to get the actual paths (i.e., list of nodes in the path), you can pass `return_predecessors=True` to `csgraph.shortest_path`."
      ],
      "id": "fd08ad33"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "D, predecessors = csgraph.shortest_path(A, indices=2, directed=False, return_predecessors=True)"
      ],
      "id": "3156b1c3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Connected Components\n",
        "\n",
        "Connected components can be computed by `csgraph.connected_components`."
      ],
      "id": "a66a0a47"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "n_components, labels = csgraph.connected_components(A, directed=False, return_labels=True)\n",
        "\n",
        "print(\"Number of connected components:\", n_components)\n",
        "print(\"Labels:\", labels)"
      ],
      "id": "789bea1d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "- `n_components` is the number of connected components.\n",
        "- `labels` is an array of length `n_nodes` where each element is the ID of the connected component the node belongs to.\n",
        "\n",
        "\n",
        "## Exercise 02 üèãÔ∏è‚Äç‚ôÄÔ∏èüí™üß†\n",
        "\n",
        "Let's compute the average path length of a network from pre-existing data and check if how long on average it takes to go from any node to any other node.\n",
        "\n",
        "1. Select a network of your choice from [Netzschleuder](https://networks.skewed.de/). For convenience, choose a network of nodes less than 5000.\n",
        "2. Download the csv version of the data by clicking something like \"3KiB\" under `csv` column.\n",
        "3. Unzip the file and find \"edges.csv\", open it with a text editor to familiarize yourself with the format.\n",
        "4. Load the data using `pandas`.\n",
        "5. Get the source and target nodes from the data to create an edge list.\n",
        "6. Construct a graph from the edge list, either using `igraph` or `scipy`.\n",
        "7. Compute the average path length\n",
        "\n",
        "**Hint:** Finding all shortest paths is a qubic time operation with respect to the number of nodes, or simply put, it takes a long time to compute. So compute the \"estimate\" by sampling many pairs of nodes uniformly at random and computing the average path length."
      ],
      "id": "e9b889b2"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "netdatasci",
      "language": "python",
      "display_name": "netdatasci",
      "path": "/Users/skojaku-admin/Library/Jupyter/kernels/netdatasci"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}