[
  {
    "objectID": "m02-small-world/00-preparation.html",
    "href": "m02-small-world/00-preparation.html",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "Before studying small-world networks, you should understand these concepts from the Euler Tour module: - Basic graph representations (adjacency matrix, edge lists) - Node degree calculations - Graph connectivity - Path, walks, and trails",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "m02-small-world/00-preparation.html#required-knowledge-from-module-1",
    "href": "m02-small-world/00-preparation.html#required-knowledge-from-module-1",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "Before studying small-world networks, you should understand these concepts from the Euler Tour module: - Basic graph representations (adjacency matrix, edge lists) - Node degree calculations - Graph connectivity - Path, walks, and trails",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "intro/setup.html",
    "href": "intro/setup.html",
    "title": "Setup",
    "section": "",
    "text": "We’ll use Python to work with data throughout this course. Python is an excellent choice for network science for its rich ecosystem of libraries, readable and intuitive syntax, and well-documented documentation.\nWe strongly recommend using virtual environments to manage your Python packages. Virtual environments create isolated Python installations for each project, avoiding dependency hell and providing several key benefits:\n\n\nDon’t confuse Python virtual environments with virtual machines (VMs). Python virtual environments are lightweight isolation tools that only separate Python packages and dependencies within the same operating system. Virtual machines, on the other hand, create complete isolated operating systems.\n\nReproducibility: Your code will work consistently across different machines and over time\nFlexibility: You can use different versions of packages for different projects without conflicts\nPrevent project interference: Changes to one project won’t break another project’s dependencies\n\n\n\n\n\n\n\nFigure 1: Without virtual environments, you risk dependency hell where package conflicts make your projects unusable.\n\n\n\nWe recommend using mamba and uv. Mamba is a tool for quickly installing Python and other packages, and for creating isolated environments for your projects. uv is a fast Python package and project manager. While we won’t be running uv commands directly in this course, you’ll need uv to properly run Marimo notebooks, which provides a much better development experience. See here for installation instructions.\nFollow the following steps to install mamba, uv, along with the minimum Python packages required for this course.\n\n[Install mamba] (https://github.com/conda-forge/miniforge)\nRun the following command to create a new environment with the minimum Python packages required for this course.\n\nmamba create -n advnetsci python==3.11 matplotlib scipy numpy pandas seaborn uv\n\nActivate the environment.\n\nmamba activate advnetsci\n\nPip install marimo.\n\npip install marimo\n\n\n\n\n\n\nIf you prefer tools other than uv, here are some alternatives:\n\nvenv: The standard library for creating virtual environments;\npyenv: Great for managing multiple Python versions;\nConda: Popular in data science, includes non-Python packages;\nMamba: Faster drop-in replacement for conda;\nMiniforge: Community-driven conda distribution with mamba included;",
    "crumbs": [
      "Home",
      "Introduction",
      "Setup"
    ]
  },
  {
    "objectID": "intro/setup.html#python-and-virtual-environments",
    "href": "intro/setup.html#python-and-virtual-environments",
    "title": "Setup",
    "section": "",
    "text": "We’ll use Python to work with data throughout this course. Python is an excellent choice for network science for its rich ecosystem of libraries, readable and intuitive syntax, and well-documented documentation.\nWe strongly recommend using virtual environments to manage your Python packages. Virtual environments create isolated Python installations for each project, avoiding dependency hell and providing several key benefits:\n\n\nDon’t confuse Python virtual environments with virtual machines (VMs). Python virtual environments are lightweight isolation tools that only separate Python packages and dependencies within the same operating system. Virtual machines, on the other hand, create complete isolated operating systems.\n\nReproducibility: Your code will work consistently across different machines and over time\nFlexibility: You can use different versions of packages for different projects without conflicts\nPrevent project interference: Changes to one project won’t break another project’s dependencies\n\n\n\n\n\n\n\nFigure 1: Without virtual environments, you risk dependency hell where package conflicts make your projects unusable.\n\n\n\nWe recommend using mamba and uv. Mamba is a tool for quickly installing Python and other packages, and for creating isolated environments for your projects. uv is a fast Python package and project manager. While we won’t be running uv commands directly in this course, you’ll need uv to properly run Marimo notebooks, which provides a much better development experience. See here for installation instructions.\nFollow the following steps to install mamba, uv, along with the minimum Python packages required for this course.\n\n[Install mamba] (https://github.com/conda-forge/miniforge)\nRun the following command to create a new environment with the minimum Python packages required for this course.\n\nmamba create -n advnetsci python==3.11 matplotlib scipy numpy pandas seaborn uv\n\nActivate the environment.\n\nmamba activate advnetsci\n\nPip install marimo.\n\npip install marimo\n\n\n\n\n\n\nIf you prefer tools other than uv, here are some alternatives:\n\nvenv: The standard library for creating virtual environments;\npyenv: Great for managing multiple Python versions;\nConda: Popular in data science, includes non-Python packages;\nMamba: Faster drop-in replacement for conda;\nMiniforge: Community-driven conda distribution with mamba included;",
    "crumbs": [
      "Home",
      "Introduction",
      "Setup"
    ]
  },
  {
    "objectID": "intro/setup.html#marimo-notebook",
    "href": "intro/setup.html#marimo-notebook",
    "title": "Setup",
    "section": "2 Marimo Notebook",
    "text": "2 Marimo Notebook\nWe’ll use Marimo (GitHub) notebooks for assignments and interactive exercises throughout the course. Marimo is a reactive Python notebook that automatically updates when you change code, making it perfect for exploring network data and seeing results in real-time.\nFamiliarize yourself with Marimo by taking a look at the “Getting Started” section of the Marimo documentation.\n\n\n\n\nMarimo integrates especially tightly with uv and provides a package sandbox feature that lets you inline dependencies directly in notebook files. This is the easiest way to get started - no prior uv knowledge required.\nCreating a sandboxed notebook:\nuvx marimo edit --sandbox my_notebook.py\nThis command installs marimo in a temporary environment, tracks your dependencies and stores them in the notebook file, and automatically downloads any existing dependencies.\nRunning sandboxed notebooks:\nuv run my_notebook.py\nBenefits: Dependencies are embedded in the notebook file itself, perfect reproducibility, and no need to manage separate dependency files.\n\nAlternative Installation\nIf you’re not using uv, you can install marimo with pip:\npip install marimo\n\n\nRunning Marimo\nTo start a new marimo notebook:\nmarimo edit\nTo open an existing marimo notebook:\nmarimo edit notebook.py",
    "crumbs": [
      "Home",
      "Introduction",
      "Setup"
    ]
  },
  {
    "objectID": "intro/setup.html#github-and-github-copilot",
    "href": "intro/setup.html#github-and-github-copilot",
    "title": "Setup",
    "section": "3 Github and GitHub Copilot",
    "text": "3 Github and GitHub Copilot\nWe’ll use GitHub for assignment collection and auto-grading in this course.\n\n\n\n\n\nMinimum Requirements\nAt the minimum level, you only need to:\n\nCreate a GitHub account at github.com\nKnow how to upload files to GitHub\n\nDetailed instructions on how to upload your assignments to GitHub will be provided separately - advanced Git features are not required for the course. See this assignment example to get familiar with the format.\n\n\nSubscribing to GitHub Copilot\nWe strongly encourage you to use GitHub Copilot, an AI-powered coding assistant that helps you write code faster and more efficiently. GitHub Copilot is an AI pair programmer that provides intelligent code suggestions, completions, and explanations directly in code editor, including VS Code and Marimo.\nStudents can get free access to GitHub Copilot Pro, which includes enhanced features and priority access. Visit the GitHub Copilot Pro free access page to get started.\nMarimo notebook supports GitHub Copilot out of the box. See the instruction to enable it. If you are using VS Code, you can also install the GitHub Copilot extension to get the same experience.\n\n\nFor Students Interested in Learning More\nUnderstanding Git and GitHub is useful for seamlessly working with assignments and will benefit your programming workflow. Additionally, Git and GitHub integrate nicely with AI tools for productivity improvement, making your development process more efficient.\n\n\nGit(Hub) and AI tools are like a pair of best friends. Git ensures that all edits are tracked and can be reverted. GitHub makes it easy for you to collaborate with (multiple) AI agents with you.\n\n\n\n\n\nGitHub Desktop (Recommended for Beginners)\nIf you want to learn more about version control, start with GitHub Desktop, a user-friendly graphical interface:\n\nGo to desktop.github.com\nDownload for your operating system\nInstall and sign in with your GitHub account\n\n\n\nUnderstanding Git and Version Control\nGit is a version control system that tracks changes in your code over time. Think of it as a sophisticated “save” system that:\n\nKeeps a complete history of all changes to your files\nLets you go back to any previous version\nAllows multiple people to work on the same project simultaneously\nHelps you manage different versions or “branches” of your work\n\nGitHub is a cloud-based platform that hosts Git repositories and adds collaboration features.\n\n\nLearning Resources\nEssential resources to understand Git concepts:\n\nInteractive Git Tutorial - Visual, hands-on learning\nGitHub Desktop Documentation - Official desktop app guide\nAtlassian Git Tutorials - Detailed tutorials with examples",
    "crumbs": [
      "Home",
      "Introduction",
      "Setup"
    ]
  },
  {
    "objectID": "m01-euler_tour/03-exercises.html",
    "href": "m01-euler_tour/03-exercises.html",
    "title": "Exercises",
    "section": "",
    "text": "Open in molab\n\n\nExercise Notebook",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Exercises"
    ]
  },
  {
    "objectID": "m02-small-world/00-preparation.html#distance-measures-in-networks",
    "href": "m02-small-world/00-preparation.html#distance-measures-in-networks",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "Small-world networks are fundamentally about distances between nodes. You’ll need to understand:\n\n\nThe shortest path distance between two nodes is the minimum number of edges in any path connecting them.\nimport networkx as nx\n\n# Calculate shortest path distances\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 3), (3, 4), (1, 4)])\ndistance = nx.shortest_path_length(G, 1, 3)  # Returns 2\n\n\n\nFor network analysis, we often compute the average shortest path length across all pairs of nodes:\n\\langle d \\rangle = \\frac{1}{N(N-1)} \\sum_{i \\neq j} d_{ij}\nwhere d_{ij} is the shortest path distance between nodes i and j.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "m02-small-world/00-preparation.html#clustering-concepts",
    "href": "m02-small-world/00-preparation.html#clustering-concepts",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "The clustering coefficient measures how densely connected a node’s neighbors are:\nC_i = \\frac{2E_i}{k_i(k_i-1)}\nwhere E_i is the number of edges between neighbors of node i, and k_i is the degree of node i.\n\n\n\nThe average clustering coefficient across all nodes provides a measure of local connectivity.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "m02-small-world/00-preparation.html#statistical-analysis-prerequisites",
    "href": "m02-small-world/00-preparation.html#statistical-analysis-prerequisites",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "You’ll need basic understanding of: - Random variables and their distributions - Expected values and variance - Comparing observed vs. expected values\n\n\n\nUnderstanding of random graphs where edges are placed randomly with some probability will help contextualize small-world properties.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "m02-small-world/00-preparation.html#computational-prerequisites",
    "href": "m02-small-world/00-preparation.html#computational-prerequisites",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "Basic understanding of computational complexity (O(n), O(n²)) for evaluating network analysis algorithms.\n\n\n\nFamiliarity with: - Lists and dictionaries for graph representations - Efficient storage and retrieval of network data\nThese foundations will help you understand how small-world networks achieve the remarkable property of short average distances despite high local clustering.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "llm-context/m01-euler_tour.html",
    "href": "llm-context/m01-euler_tour.html",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "",
    "text": "In this module, we will explore the historical moment that gave birth to graph theory and modern network science. A simple Sunday stroll puzzle in an 18th-century Prussian city would spark a mathematical revolution that now powers everything from GPS navigation to social media algorithms.\nThrough Euler’s elegant solution, we will learn:\n\nHow to describe a network using mathematical language\nHow mathematical abstraction reveals hidden structure in complex problems\nThe power of degree-based reasoning in network analysis\nKeywords: network, graph, degree, Euler walk, mathematical abstraction\n\n\n\nThis is not just history—Euler’s approach of abstracting complex systems into nodes and edges is the same method we use today to analyze internet routing, brain connectivity, and viral spread patterns."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#what-to-learn-in-this-module",
    "href": "llm-context/m01-euler_tour.html#what-to-learn-in-this-module",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "",
    "text": "In this module, we will explore the historical moment that gave birth to graph theory and modern network science. A simple Sunday stroll puzzle in an 18th-century Prussian city would spark a mathematical revolution that now powers everything from GPS navigation to social media algorithms.\nThrough Euler’s elegant solution, we will learn:\n\nHow to describe a network using mathematical language\nHow mathematical abstraction reveals hidden structure in complex problems\nThe power of degree-based reasoning in network analysis\nKeywords: network, graph, degree, Euler walk, mathematical abstraction\n\n\n\nThis is not just history—Euler’s approach of abstracting complex systems into nodes and edges is the same method we use today to analyze internet routing, brain connectivity, and viral spread patterns."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#a-sunday-stroll-that-changed-mathematics",
    "href": "llm-context/m01-euler_tour.html#a-sunday-stroll-that-changed-mathematics",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "2 A Sunday Stroll That Changed Mathematics",
    "text": "2 A Sunday Stroll That Changed Mathematics\nBack in the 18th century, there was a city called Königsberg situated on the Pregel River in what was then Prussia (now Kaliningrad, Russia). The city was built around two large islands, beautifully connected to each other and the mainland by seven elegant bridges.\n\n\nKönigsberg was a major intellectual center of the Enlightenment. Immanuel Kant spent his entire life there, never traveling more than 10 miles from the city. The university attracted scholars from across Europe.\nDuring their leisurely Sunday walks, the citizens of Königsberg found themselves pondering an intriguing puzzle:\n\n\n\n\n\n\nThe Königsberg Bridge Problem\n\n\n\nIs it possible to take a walk through the city that crosses each bridge exactly once and returns to the starting point?\n\n\n\n\n\nThe seven bridges of Königsberg {#fig-seven-bridges}\n\n\nThis seemingly innocent recreational question would become one of the most important problems in the history of mathematics. What made it revolutionary wasn’t the answer, but how the answer was found."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#try-it-yourself-first",
    "href": "llm-context/m01-euler_tour.html#try-it-yourself-first",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "3 Try It Yourself First!",
    "text": "3 Try It Yourself First!\nBefore we reveal Euler’s brilliant solution, take some time to think about this problem yourself. This is exactly how mathematical discovery works—by wrestling with puzzles and developing your own insights.\n\n\n\n\n\n\nWork Through It Step by Step\n\n\n\nHighly recommended: Download and work through this excellent pen-and-paper worksheet created by Esteban Moro (Moro 2017). It guides you through Euler’s reasoning step by step, letting you discover the solution yourself.\nQuestions to consider while working:\n\nCan you trace a path that crosses each bridge exactly once?\nWhat patterns do you notice when you try different routes?\nWhat properties of the landmasses seem important?\nHow might you prove that something is impossible, rather than just failing to find it?\n\n\n\nThe beauty of mathematics lies not just in the answers, but in the process of discovery.\n\n\n\n\n\n\n⚠️ Pause Here First!\n\n\n\nBefore reading Euler’s solution below, we strongly encourage you to:\n\nWork through the pen-and-paper worksheet by Esteban Moro\nTry the puzzle yourself - can you find a path that crosses each bridge exactly once?\nThink about what makes this problem difficult - what constraints do you notice?\n\nThe learning experience is much richer when you discover the insights yourself first!\n\n\nOnce you’ve given it some thought, continue reading to see how Euler approached this problem in 1736."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#eulers-revolutionary-abstraction",
    "href": "llm-context/m01-euler_tour.html#eulers-revolutionary-abstraction",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "4 🔍 Euler’s Revolutionary Abstraction",
    "text": "4 🔍 Euler’s Revolutionary Abstraction\nLeonhard Euler approached this puzzle in 1736 with a stroke of genius that would define mathematical thinking for centuries. Instead of getting bogged down in the physical details—the width of the bridges, the size of the islands, the beauty of the architecture—he made a radical simplification.\n\n\nLeonhard Euler (1707-1783) was one of the most prolific mathematicians in history, contributing to nearly every area of mathematics. He lost sight in his right eye in 1738 but continued his work, producing almost half of his total output after becoming completely blind in 1766.\n\nThis was revolutionary thinking for its time. Before Euler, mathematics focused on quantities, measurements, and calculations. Euler showed that sometimes the relationships between objects matter more than the objects themselves.\nEuler realized that for this problem, only one thing mattered: which landmasses connect to which other landmasses. Everything else—the bridge lengths, island shapes, water depths—was irrelevant distraction.\nHe simplified the city into a network of landmasses connected by bridges:\n\n\n\n\n\n\nFigure 1: Euler’s graph of the bridges of Knigsberg. Taken from The Essential Guide to Graph Theory: From an 18th Century Riddle to AI Frameworks\n\n\n\nThis abstraction—reducing a complex physical system to its essential connectivity—was the birth of graph theory. Euler had invented a new mathematical language for describing relationships.\nOnce Euler had his abstract graph, he made another crucial insight. Instead of trying different walking routes (which would take forever), he focused on a fundamental property: how many bridges connect to each landmass?\n\n\nThis shift from “trying all possibilities” to “analyzing constraints” is a hallmark of mathematical thinking. Instead of brute force, Euler used logical reasoning to prove impossibility.\nEuler considered the degree (number of connections) of each node and realized there were only two cases: - a node has an even number of edges, or - a node has an odd number of edges.\nWhen a node has an even number 2k of edges, you can enter and leave the node exactly k times by crossing different edges. Every time you enter through one bridge, you can leave through another. The bridges naturally pair up.\nWhen a node has an odd number 2k+1 of edges, you can enter and leave the node k times, but one edge is left over. The only way to cross this last edge is if your journey starts or ends at this node.\n\n\nThink of it like a dance where everyone needs a partner. In nodes with even degree, every bridge has a “partner” for entering and leaving. Odd-degree nodes always have one “wallflower” bridge that can only be used at the very beginning or end.\nBased on this elegant reasoning, Euler arrived at his famous theorem:\n\n\n\n\n\n\nEuler’s Path Theorem\n\n\n\nA walk that crosses all edges exactly once exists if and only if:\n\nAll nodes have even degree, OR\nExactly two nodes have odd degree\n\n\n\nThis wasn’t just a solution—it was a proof. Euler had shown not just whether such a path exists, but exactly when it’s possible.\n\n\nA good Youtube video explaining the Euler’s story:"
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#the-verdict-königsbergs-impossible-dream",
    "href": "llm-context/m01-euler_tour.html#the-verdict-königsbergs-impossible-dream",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "5 ⚖️ The Verdict: Königsberg’s Impossible Dream",
    "text": "5 ⚖️ The Verdict: Königsberg’s Impossible Dream\nApplying Euler’s theorem to the original Königsberg bridges reveals the truth: every landmass has an odd number of bridges. According to Euler’s conditions, this makes the desired walk impossible.\n\n\nIn the original graph: North shore (3 bridges), South shore (3 bridges), Large island (5 bridges), Small island (3 bridges). Four nodes with odd degree—exactly two more than Euler’s theorem allows.\nThe citizens of Königsberg had been attempting the impossible. Their Sunday stroll puzzle had no solution, and Euler had proven it with mathematical certainty.\nThe story takes a sobering turn during World War II. In 1944, Königsberg was heavily bombed by Allied forces, and later captured by the Soviet Union. Two of the seven historic bridges were destroyed in the bombardment.\n\n\n\nAfter WWII bombing, only five bridges remained—finally making an Euler path possible. {#fig-markdown-fig}\n\n\n\n\nThe city was renamed Kaliningrad and became part of Russia. Today, it remains a Russian exclave, separated from the rest of Russia by Lithuania and Poland. The few remaining bridges span a river now in a very different political landscape.\nWith only five bridges remaining, the network finally satisfied Euler’s conditions: exactly two nodes had odd degree. The mathematical puzzle that had stumped citizens for two centuries was “solved” by the tragic circumstances of war.\nThis ironic resolution reminds us that while mathematics reveals timeless truths about structure and possibility, the physical world—and human history—follows much more complex and unpredictable patterns."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#the-lasting-legacy",
    "href": "llm-context/m01-euler_tour.html#the-lasting-legacy",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "6 The Lasting Legacy",
    "text": "6 The Lasting Legacy\nEuler’s solution to the Königsberg bridge problem did far more than solve a recreational puzzle. It demonstrated that:\n\nAbstract thinking can solve concrete problems\nMathematical proof is more powerful than trial and error\nNetwork structure determines what’s possible in interconnected systems\n\nThese insights now underpin our understanding of everything from internet routing protocols to epidemic spreading models. Every time you use GPS navigation or analyze social network data, you’re applying principles that trace back to Euler’s Sunday stroll through Königsberg.\n\nFun trivia:\nLeonhard Euler (1707-1783): Swiss mathematician and physicist, widely regarded as one of the most prolific mathematicians in history. Beyond solving the Königsberg bridge problem, he made fundamental contributions to calculus, topology, number theory, and physics. Despite losing sight in one eye and later becoming completely blind, he continued his mathematical work and produced nearly half of his total output after losing his sight.\nImmanuel Kant (1724-1804): German philosopher and one of the central thinkers of the Enlightenment. Born and died in Königsberg, never traveling more than 10 miles from the city. His systematic works in epistemology, metaphysics, ethics, and aesthetics have made him one of the most influential figures in modern Western philosophy. His regular daily walks were so punctual that neighbors reportedly set their clocks by his daily walks."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#references",
    "href": "llm-context/m01-euler_tour.html#references",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "7 References",
    "text": "7 References\n\n\ntitle: Coding Networks in Python jupyter: python3 execute: enabled: true —\nNow that you understand the conceptual foundation from Euler’s work, let’s explore how to represent and analyze networks computationally. Given a network of any size, our goal is to create a function that can tell us whether the network has an Euler path or not.\ndef has_euler_path(A):\n    \"\"\"\n    Check if a graph has an Euler path based on node degrees.\n    Complete this function based on Euler's theorem.\n\n    A: network\n    return: True if the network has an Euler path, False otherwise\n    \"\"\"\n    pass\nWe’ll work through both general network representations and apply them specifically to the Königsberg bridge problem.\n\n8 Network Representations: From Pictures to Data Structures\nConsider this network with 5 nodes and 6 edges:\n\n\n\n\n\n\nFigure 2: A small graph of five nodes and six edges.\n\n\n\nHow do we represent this graph in a format that a computer can understand and manipulate? Just as Euler needed to abstract Königsberg’s bridges, we need data structures that capture the network’s essential connectivity while enabling efficient analysis.\n\n\nThe choice of representation can dramatically affect computational efficiency. For sparse networks (few edges), adjacency lists are memory-efficient. For dense networks or matrix operations, adjacency matrices are preferred.\nLet’s explore three fundamental approaches that form the backbone of all network algorithms.\n\nEdge Table: The Direct Approach\nThe edge table directly lists connections as pairs—the most intuitive way to store network data.\n\n\nEdge tables are also called “edge lists” and are the most common format for storing large-scale network data in files. Social media platforms like Twitter and Facebook store billions of connections this way.\n\n# Each row represents one edge (connection between two nodes)\nedges = [\n    (0, 1),  # Node 0 connects to Node 1\n    (0, 2),  # Node 0 connects to Node 2\n    (1, 2),  # Node 1 connects to Node 2\n    (1, 3),  # Node 1 connects to Node 3\n    (2, 4),  # Node 2 connects to Node 4\n    (3, 4)   # Node 3 connects to Node 4\n]\n\nprint(f\"Network has {len(edges)} edges\")\nprint(\"Edge list:\", edges)\n\nThis mirrors how we’d naturally describe the network: “Node 0 connects to nodes 1 and 2, node 1 connects to nodes 0, 2, and 3…” It’s the digital equivalent of Euler’s original approach—simply listing which bridges connect which landmasses.\n\n\nAdjacency List: The Neighborhood Map\nThe adjacency list stores each node’s neighbors in a dictionary—like a social network where each person has a list of friends.\n\n\nMost graph algorithms prefer adjacency lists because they allow fast iteration over a node’s neighbors. This is crucial for algorithms like breadth-first search or computing clustering coefficients.\n\n# Define adjacency list directly as a dictionary\nneighbors = {\n    0: [1, 2],     # Node 0 connects to nodes 1 and 2\n    1: [0, 2, 3],  # Node 1 connects to nodes 0, 2, and 3\n    2: [0, 1, 4],  # Node 2 connects to nodes 0, 1, and 4\n    3: [1, 4],     # Node 3 connects to nodes 1 and 4\n    4: [2, 3]      # Node 4 connects to nodes 2 and 3\n}\n\nprint(\"Adjacency list representation:\")\nfor node, neighbor_list in neighbors.items():\n    print(f\"Node {node}: {neighbor_list}\")\n\n\n\nAdjacency Matrix: The Mathematical Grid\nThe adjacency matrix uses a grid where entry (i,j) = 1 if nodes are connected—the mathematician’s favorite representation.\n\n\nAdjacency matrices enable powerful mathematical operations. Matrix multiplication reveals paths of different lengths, and eigenvalue analysis can uncover community structure. Google’s PageRank algorithm fundamentally relies on matrix operations.\n\n# Define adjacency matrix directly\nimport numpy as np\n\nmatrix = np.array([\n    [0, 1, 1, 0, 0],  # Node 0 connects to nodes 1, 2\n    [1, 0, 1, 1, 0],  # Node 1 connects to nodes 0, 2, 3\n    [1, 1, 0, 0, 1],  # Node 2 connects to nodes 0, 1, 4\n    [0, 1, 0, 0, 1],  # Node 3 connects to nodes 1, 4\n    [0, 0, 1, 1, 0]   # Node 4 connects to nodes 2, 3\n])\n\nprint(\"Adjacency matrix:\")\nprint(matrix)\n\nNotice the symmetry: if node i connects to node j, then node j connects to node i (for undirected networks). This symmetry disappears in directed networks, where relationships can be one-way.\n\n\n\n9 Counting Node Degrees: Euler’s Key Insight\nThe degree of a node is the number of edges connected to it. This simple concept was central to Euler’s proof—he realized that a valid bridge walk requires each landmass to have an even degree (except possibly the starting and ending points).\n\n\nIn Königsberg, all four landmasses had odd degree, making the bridge walk impossible. This insight—that global properties emerge from local structure—remains fundamental to network analysis today.\nHere’s how to compute degrees using each representation:\n\nFrom Edge Table: Counting Appearances\nCount how many times each node appears in the edge list.\n\n_degrees = [0] * 5\nfor node1, node2 in edges:\n    _degrees[node1] += 1\n    _degrees[node2] += 1\nprint(\"Degrees from edge list:\", _degrees)\n\n\n\nWe increment the degree counter for both nodes in each edge because every edge contributes to two nodes’ degrees. This is why the total degree always equals twice the number of edges.\n\n\nFrom Adjacency List: Counting Friends\nCount the length of each node’s neighbor list—the most direct approach.\n\n_degrees = [len(neighbors[i]) for i in range(5)]\nprint(\"Degrees from adjacency list:\", _degrees)\n\n\n\nFrom Adjacency Matrix: Linear Algebra Power\nSum each row (or column) of the matrix—leveraging vectorized operations.\n\n_degrees = matrix.sum(axis=1)  # Sum rows\nprint(\"Degrees from adjacency matrix:\", _degrees)\n\n\n\nFor undirected networks, row sums equal column sums. For directed networks, row sums give out-degree (outgoing connections) while column sums give in-degree (incoming connections).\n\n\n\n10 Summary: From Euler’s Insight to Modern Computation\nYou now understand how to:\n\nRepresent networks using edge lists, adjacency lists, and adjacency matrices\nCompute node degrees efficiently using different data structures\n\nThe next step is to practice these concepts with real network data and explore more advanced network analysis techniques!— title: “Advanced: Sparse Matrices for Large-Scale Networks” jupyter: python3 —\n\n\n11 The Scale Problem: From Königsberg to Global Networks\nWhile Euler’s analysis worked perfectly for Königsberg’s 4 landmasses and 7 bridges, today’s networks operate at vastly different scales. Suppose we want to represent the social network of all people on Earth using an adjacency matrix. How much memory would we need? For an adjacency matrix with 8 billion nodes, the matrix size is 8 \\times 10^9 \\times 8 \\times 10^9 = 64 \\times 10^{18} entries, and the memory required is 64 \\times 10^{18} \\times 8 bytes ≈ 512 exabytes! Clearly, this approach is not feasible!\nA way to solve this problem is to exploit the fact that real networks are sparse: most pairs of nodes are not connected.\nTo give you an idea, let’s consider a social network of 8 billion people on Earth. How likely do you think that two randomly picked people are friends? If the network is dense, it should be likely. But in reality, it is very unlikely, right? So much so that the probability is almost zero (less than 3.1e-23 if each person has 100 friends on average)!\nThis means that working with the edge list is a good idea as it retains only the connections, not the non-connections (which are much more than the connections!). But the edge list is not efficient for many operaitions\n\n\nThink about the following operations:\n\nDegree: How many friends does a person have?\nNeighbors: Who are the friends of a person?\n\nThese operations are very common in network analysis. To do so, you need to go through all the edges in the network. This is not efficient, especially for large networks.\n\n\n12 Solution: Sparse Matrices\nWe say a matrix is sparse if the matrix has only a handful of non-zero entries. This is indeed the case for most real-world networks. For such networks, we can use a special type of data type called Compressed Sparse Row (CSR) or Compressed Sparse Column (CSC) to represent the network. This is widely used in many network analysis tools and makes it possible to process large networks in practice.\nTo learn more, here is a very good blog post by Matt Eding about efficient network representations.\n\n\n\n\n\n\n\nMoro, Esteban. 2017. “Network Science for Kids!” http://estebanmoro.org/2017/03/network-science-for-kids."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#network-representations-from-pictures-to-data-structures",
    "href": "llm-context/m01-euler_tour.html#network-representations-from-pictures-to-data-structures",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "8 Network Representations: From Pictures to Data Structures",
    "text": "8 Network Representations: From Pictures to Data Structures\nConsider this network with 5 nodes and 6 edges:\n\n\n\n\n\n\nFigure 2: A small graph of five nodes and six edges.\n\n\n\nHow do we represent this graph in a format that a computer can understand and manipulate? Just as Euler needed to abstract Königsberg’s bridges, we need data structures that capture the network’s essential connectivity while enabling efficient analysis.\n\n\nThe choice of representation can dramatically affect computational efficiency. For sparse networks (few edges), adjacency lists are memory-efficient. For dense networks or matrix operations, adjacency matrices are preferred.\nLet’s explore three fundamental approaches that form the backbone of all network algorithms.\n\nEdge Table: The Direct Approach\nThe edge table directly lists connections as pairs—the most intuitive way to store network data.\n\n\nEdge tables are also called “edge lists” and are the most common format for storing large-scale network data in files. Social media platforms like Twitter and Facebook store billions of connections this way.\n\n# Each row represents one edge (connection between two nodes)\nedges = [\n    (0, 1),  # Node 0 connects to Node 1\n    (0, 2),  # Node 0 connects to Node 2\n    (1, 2),  # Node 1 connects to Node 2\n    (1, 3),  # Node 1 connects to Node 3\n    (2, 4),  # Node 2 connects to Node 4\n    (3, 4)   # Node 3 connects to Node 4\n]\n\nprint(f\"Network has {len(edges)} edges\")\nprint(\"Edge list:\", edges)\n\nThis mirrors how we’d naturally describe the network: “Node 0 connects to nodes 1 and 2, node 1 connects to nodes 0, 2, and 3…” It’s the digital equivalent of Euler’s original approach—simply listing which bridges connect which landmasses.\n\n\nAdjacency List: The Neighborhood Map\nThe adjacency list stores each node’s neighbors in a dictionary—like a social network where each person has a list of friends.\n\n\nMost graph algorithms prefer adjacency lists because they allow fast iteration over a node’s neighbors. This is crucial for algorithms like breadth-first search or computing clustering coefficients.\n\n# Define adjacency list directly as a dictionary\nneighbors = {\n    0: [1, 2],     # Node 0 connects to nodes 1 and 2\n    1: [0, 2, 3],  # Node 1 connects to nodes 0, 2, and 3\n    2: [0, 1, 4],  # Node 2 connects to nodes 0, 1, and 4\n    3: [1, 4],     # Node 3 connects to nodes 1 and 4\n    4: [2, 3]      # Node 4 connects to nodes 2 and 3\n}\n\nprint(\"Adjacency list representation:\")\nfor node, neighbor_list in neighbors.items():\n    print(f\"Node {node}: {neighbor_list}\")\n\n\n\nAdjacency Matrix: The Mathematical Grid\nThe adjacency matrix uses a grid where entry (i,j) = 1 if nodes are connected—the mathematician’s favorite representation.\n\n\nAdjacency matrices enable powerful mathematical operations. Matrix multiplication reveals paths of different lengths, and eigenvalue analysis can uncover community structure. Google’s PageRank algorithm fundamentally relies on matrix operations.\n\n# Define adjacency matrix directly\nimport numpy as np\n\nmatrix = np.array([\n    [0, 1, 1, 0, 0],  # Node 0 connects to nodes 1, 2\n    [1, 0, 1, 1, 0],  # Node 1 connects to nodes 0, 2, 3\n    [1, 1, 0, 0, 1],  # Node 2 connects to nodes 0, 1, 4\n    [0, 1, 0, 0, 1],  # Node 3 connects to nodes 1, 4\n    [0, 0, 1, 1, 0]   # Node 4 connects to nodes 2, 3\n])\n\nprint(\"Adjacency matrix:\")\nprint(matrix)\n\nNotice the symmetry: if node i connects to node j, then node j connects to node i (for undirected networks). This symmetry disappears in directed networks, where relationships can be one-way."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#counting-node-degrees-eulers-key-insight",
    "href": "llm-context/m01-euler_tour.html#counting-node-degrees-eulers-key-insight",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "9 Counting Node Degrees: Euler’s Key Insight",
    "text": "9 Counting Node Degrees: Euler’s Key Insight\nThe degree of a node is the number of edges connected to it. This simple concept was central to Euler’s proof—he realized that a valid bridge walk requires each landmass to have an even degree (except possibly the starting and ending points).\n\n\nIn Königsberg, all four landmasses had odd degree, making the bridge walk impossible. This insight—that global properties emerge from local structure—remains fundamental to network analysis today.\nHere’s how to compute degrees using each representation:\n\nFrom Edge Table: Counting Appearances\nCount how many times each node appears in the edge list.\n\n_degrees = [0] * 5\nfor node1, node2 in edges:\n    _degrees[node1] += 1\n    _degrees[node2] += 1\nprint(\"Degrees from edge list:\", _degrees)\n\n\n\nWe increment the degree counter for both nodes in each edge because every edge contributes to two nodes’ degrees. This is why the total degree always equals twice the number of edges.\n\n\nFrom Adjacency List: Counting Friends\nCount the length of each node’s neighbor list—the most direct approach.\n\n_degrees = [len(neighbors[i]) for i in range(5)]\nprint(\"Degrees from adjacency list:\", _degrees)\n\n\n\nFrom Adjacency Matrix: Linear Algebra Power\nSum each row (or column) of the matrix—leveraging vectorized operations.\n\n_degrees = matrix.sum(axis=1)  # Sum rows\nprint(\"Degrees from adjacency matrix:\", _degrees)\n\n\n\nFor undirected networks, row sums equal column sums. For directed networks, row sums give out-degree (outgoing connections) while column sums give in-degree (incoming connections)."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#summary-from-eulers-insight-to-modern-computation",
    "href": "llm-context/m01-euler_tour.html#summary-from-eulers-insight-to-modern-computation",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "10 Summary: From Euler’s Insight to Modern Computation",
    "text": "10 Summary: From Euler’s Insight to Modern Computation\nYou now understand how to:\n\nRepresent networks using edge lists, adjacency lists, and adjacency matrices\nCompute node degrees efficiently using different data structures\n\nThe next step is to practice these concepts with real network data and explore more advanced network analysis techniques!— title: “Advanced: Sparse Matrices for Large-Scale Networks” jupyter: python3 —"
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#the-scale-problem-from-königsberg-to-global-networks",
    "href": "llm-context/m01-euler_tour.html#the-scale-problem-from-königsberg-to-global-networks",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "11 The Scale Problem: From Königsberg to Global Networks",
    "text": "11 The Scale Problem: From Königsberg to Global Networks\nWhile Euler’s analysis worked perfectly for Königsberg’s 4 landmasses and 7 bridges, today’s networks operate at vastly different scales. Suppose we want to represent the social network of all people on Earth using an adjacency matrix. How much memory would we need? For an adjacency matrix with 8 billion nodes, the matrix size is 8 \\times 10^9 \\times 8 \\times 10^9 = 64 \\times 10^{18} entries, and the memory required is 64 \\times 10^{18} \\times 8 bytes ≈ 512 exabytes! Clearly, this approach is not feasible!\nA way to solve this problem is to exploit the fact that real networks are sparse: most pairs of nodes are not connected.\nTo give you an idea, let’s consider a social network of 8 billion people on Earth. How likely do you think that two randomly picked people are friends? If the network is dense, it should be likely. But in reality, it is very unlikely, right? So much so that the probability is almost zero (less than 3.1e-23 if each person has 100 friends on average)!\nThis means that working with the edge list is a good idea as it retains only the connections, not the non-connections (which are much more than the connections!). But the edge list is not efficient for many operaitions\n\n\nThink about the following operations:\n\nDegree: How many friends does a person have?\nNeighbors: Who are the friends of a person?\n\nThese operations are very common in network analysis. To do so, you need to go through all the edges in the network. This is not efficient, especially for large networks."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#solution-sparse-matrices",
    "href": "llm-context/m01-euler_tour.html#solution-sparse-matrices",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "12 Solution: Sparse Matrices",
    "text": "12 Solution: Sparse Matrices\nWe say a matrix is sparse if the matrix has only a handful of non-zero entries. This is indeed the case for most real-world networks. For such networks, we can use a special type of data type called Compressed Sparse Row (CSR) or Compressed Sparse Column (CSC) to represent the network. This is widely used in many network analysis tools and makes it possible to process large networks in practice.\nTo learn more, here is a very good blog post by Matt Eding about efficient network representations."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to SSIE 641 Advanced Topics on Network Science",
    "section": "",
    "text": "``Don’t think! Feeeeeel’’ is a famous quote by Bruce Lee in the movie Enter the Dragon, and this is my guiding philosophy of learning.\nThis course is designed to help you feel the concepts and tools of network science through pen-and-paper exercises and hands-on coding."
  },
  {
    "objectID": "index.html#list-of-exercises",
    "href": "index.html#list-of-exercises",
    "title": "Welcome to SSIE 641 Advanced Topics on Network Science",
    "section": "1 List of Exercises",
    "text": "1 List of Exercises\n\n\n\nModule\nPen and Paper Exercise\nNotebook\n\n\n\n\nM01: Euler Tour\nThe Koningsberg Bridge\nNotebook\n\n\nM02: Small World\nIt’s a small world!! 6 degrees of separation\nNotebook\n\n\nM03: Robustness\nBuild it, Break it, and Build it back!\nNotebook\n\n\nM04: Friendship Paradox\nData Visualization\nNotebook\n\n\nM05: Clustering\nPerfect vs. Almost Perfect\nNotebook\n\n\nM06: Centrality\nWho’s the Big Cheese in the University Clubs?\nNotebook\n\n\nM07: Random Walks\nRandom Walks on Networks\nNotebook\n\n\nM08: Embedding\nNetwork Embeddings\nNotebook\n\n\nM09: Graph Neural Networks\nGraph Neural Networks\nNotebook"
  },
  {
    "objectID": "index.html#list-of-assignments",
    "href": "index.html#list-of-assignments",
    "title": "Welcome to SSIE 641 Advanced Topics on Network Science",
    "section": "2 List of assignments",
    "text": "2 List of assignments\nNote: For the students taking SSIE 641, the grading will be done through GitHub Classroom, and the following assignments are not linked to GitHub Classroom. Please use the links provided by the instructor. All the links are listed in Brightspace.\n\n\n\nModule\nAssignment\n\n\n\n\nSmall World\nAssignment 1\n\n\nNetwork Centrality\nAssignment 2\n\n\nSmall world networks\nAssignment 3"
  },
  {
    "objectID": "m01-euler_tour/01-concepts.html",
    "href": "m01-euler_tour/01-concepts.html",
    "title": "Euler Path Concepts - The Birth of Network Science",
    "section": "",
    "text": "In this module, we will explore the historical moment that gave birth to graph theory and modern network science. A simple Sunday stroll puzzle in an 18th-century Prussian city would spark a mathematical revolution that now powers everything from GPS navigation to social media algorithms.\nThrough Euler’s elegant solution, we will learn:\n\nHow to describe a network using mathematical language\nHow mathematical abstraction reveals hidden structure in complex problems\nThe power of degree-based reasoning in network analysis\nKeywords: network, graph, degree, Euler walk, mathematical abstraction\n\n\n\nThis is not just history—Euler’s approach of abstracting complex systems into nodes and edges is the same method we use today to analyze internet routing, brain connectivity, and viral spread patterns.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Euler Path Concepts - The Birth of Network Science"
    ]
  },
  {
    "objectID": "m01-euler_tour/01-concepts.html#what-to-learn-in-this-module",
    "href": "m01-euler_tour/01-concepts.html#what-to-learn-in-this-module",
    "title": "Euler Path Concepts - The Birth of Network Science",
    "section": "",
    "text": "In this module, we will explore the historical moment that gave birth to graph theory and modern network science. A simple Sunday stroll puzzle in an 18th-century Prussian city would spark a mathematical revolution that now powers everything from GPS navigation to social media algorithms.\nThrough Euler’s elegant solution, we will learn:\n\nHow to describe a network using mathematical language\nHow mathematical abstraction reveals hidden structure in complex problems\nThe power of degree-based reasoning in network analysis\nKeywords: network, graph, degree, Euler walk, mathematical abstraction\n\n\n\nThis is not just history—Euler’s approach of abstracting complex systems into nodes and edges is the same method we use today to analyze internet routing, brain connectivity, and viral spread patterns.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Euler Path Concepts - The Birth of Network Science"
    ]
  },
  {
    "objectID": "m01-euler_tour/01-concepts.html#a-sunday-stroll-that-changed-mathematics",
    "href": "m01-euler_tour/01-concepts.html#a-sunday-stroll-that-changed-mathematics",
    "title": "Euler Path Concepts - The Birth of Network Science",
    "section": "2 A Sunday Stroll That Changed Mathematics",
    "text": "2 A Sunday Stroll That Changed Mathematics\nBack in the 18th century, there was a city called Königsberg situated on the Pregel River in what was then Prussia (now Kaliningrad, Russia). The city was built around two large islands, beautifully connected to each other and the mainland by seven elegant bridges.\n\n\nKönigsberg was a major intellectual center of the Enlightenment. Immanuel Kant spent his entire life there, never traveling more than 10 miles from the city. The university attracted scholars from across Europe.\nDuring their leisurely Sunday walks, the citizens of Königsberg found themselves pondering an intriguing puzzle:\n\n\n\n\n\n\nThe Königsberg Bridge Problem\n\n\n\nIs it possible to take a walk through the city that crosses each bridge exactly once and returns to the starting point?\n\n\n\n\n\nThe seven bridges of Königsberg {#fig-seven-bridges}\n\n\nThis seemingly innocent recreational question would become one of the most important problems in the history of mathematics. What made it revolutionary wasn’t the answer, but how the answer was found.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Euler Path Concepts - The Birth of Network Science"
    ]
  },
  {
    "objectID": "m01-euler_tour/01-concepts.html#try-it-yourself-first",
    "href": "m01-euler_tour/01-concepts.html#try-it-yourself-first",
    "title": "Euler Path Concepts - The Birth of Network Science",
    "section": "3 Try It Yourself First!",
    "text": "3 Try It Yourself First!\nBefore we reveal Euler’s brilliant solution, take some time to think about this problem yourself. This is exactly how mathematical discovery works—by wrestling with puzzles and developing your own insights.\n\n\n\n\n\n\nWork Through It Step by Step\n\n\n\nHighly recommended: Download and work through this excellent pen-and-paper worksheet created by Esteban Moro (Moro 2017). It guides you through Euler’s reasoning step by step, letting you discover the solution yourself.\nQuestions to consider while working:\n\nCan you trace a path that crosses each bridge exactly once?\nWhat patterns do you notice when you try different routes?\nWhat properties of the landmasses seem important?\nHow might you prove that something is impossible, rather than just failing to find it?\n\n\n\nThe beauty of mathematics lies not just in the answers, but in the process of discovery.\n\n\n\n\n\n\n⚠️ Pause Here First!\n\n\n\nBefore reading Euler’s solution below, we strongly encourage you to:\n\nWork through the pen-and-paper worksheet by Esteban Moro\nTry the puzzle yourself - can you find a path that crosses each bridge exactly once?\nThink about what makes this problem difficult - what constraints do you notice?\n\nThe learning experience is much richer when you discover the insights yourself first!\n\n\nOnce you’ve given it some thought, continue reading to see how Euler approached this problem in 1736.\n\n\n🔍 Euler’s Revolutionary Abstraction\nLeonhard Euler approached this puzzle in 1736 with a stroke of genius that would define mathematical thinking for centuries. Instead of getting bogged down in the physical details—the width of the bridges, the size of the islands, the beauty of the architecture—he made a radical simplification.\n\n\nLeonhard Euler (1707-1783) was one of the most prolific mathematicians in history, contributing to nearly every area of mathematics. He lost sight in his right eye in 1738 but continued his work, producing almost half of his total output after becoming completely blind in 1766.\n\nThis was revolutionary thinking for its time. Before Euler, mathematics focused on quantities, measurements, and calculations. Euler showed that sometimes the relationships between objects matter more than the objects themselves.\nEuler realized that for this problem, only one thing mattered: which landmasses connect to which other landmasses. Everything else—the bridge lengths, island shapes, water depths—was irrelevant distraction.\nHe simplified the city into a network of landmasses connected by bridges:\n\n\n\n\n\n\nFigure 1: Euler’s graph of the bridges of Knigsberg. Taken from The Essential Guide to Graph Theory: From an 18th Century Riddle to AI Frameworks\n\n\n\nThis abstraction—reducing a complex physical system to its essential connectivity—was the birth of graph theory. Euler had invented a new mathematical language for describing relationships.\nOnce Euler had his abstract graph, he made another crucial insight. Instead of trying different walking routes (which would take forever), he focused on a fundamental property: how many bridges connect to each landmass?\n\n\nThis shift from “trying all possibilities” to “analyzing constraints” is a hallmark of mathematical thinking. Instead of brute force, Euler used logical reasoning to prove impossibility.\nEuler considered the degree (number of connections) of each node and realized there were only two cases: - a node has an even number of edges, or - a node has an odd number of edges.\nWhen a node has an even number 2k of edges, you can enter and leave the node exactly k times by crossing different edges. Every time you enter through one bridge, you can leave through another. The bridges naturally pair up.\nWhen a node has an odd number 2k+1 of edges, you can enter and leave the node k times, but one edge is left over. The only way to cross this last edge is if your journey starts or ends at this node.\n\n\nThink of it like a dance where everyone needs a partner. In nodes with even degree, every bridge has a “partner” for entering and leaving. Odd-degree nodes always have one “wallflower” bridge that can only be used at the very beginning or end.\nBased on this elegant reasoning, Euler arrived at his famous theorem:\n\n\n\n\n\n\nEuler’s Path Theorem\n\n\n\nA walk that crosses all edges exactly once exists if and only if:\n\nThe graph is connected (you can reach any node from any other node), AND\nEither:\n\nAll nodes have even degree (forms an Euler circuit), OR\nExactly two nodes have odd degree (forms an Euler path)\n\n\n\n\nThis wasn’t just a solution—it was a proof. Euler had shown not just whether such a path exists, but exactly when it’s possible.\n\n\nA good Youtube video explaining the Euler’s story:\n\n\n\n\n⚖️ The Verdict: Königsberg’s Impossible Dream\nApplying Euler’s theorem to the original Königsberg bridges reveals the truth: every landmass has an odd number of bridges. According to Euler’s conditions, this makes the desired walk impossible.\n\n\nIn the original graph: North shore (3 bridges), South shore (3 bridges), Large island (5 bridges), Small island (3 bridges). Four nodes with odd degree—exactly two more than Euler’s theorem allows.\nThe citizens of Königsberg had been attempting the impossible. Their Sunday stroll puzzle had no solution, and Euler had proven it with mathematical certainty.\nThe story takes a sobering turn during World War II. In 1944, Königsberg was heavily bombed by Allied forces, and later captured by the Soviet Union. Two of the seven historic bridges were destroyed in the bombardment.\n\n\n\nAfter WWII bombing, only five bridges remained—finally making an Euler path possible. {#fig-markdown-fig}\n\n\n\n\nThe city was renamed Kaliningrad and became part of Russia. Today, it remains a Russian exclave, separated from the rest of Russia by Lithuania and Poland. The few remaining bridges span a river now in a very different political landscape.\nWith only five bridges remaining, the network finally satisfied Euler’s conditions: exactly two nodes had odd degree. The mathematical puzzle that had stumped citizens for two centuries was “solved” by the tragic circumstances of war.\nThis ironic resolution reminds us that while mathematics reveals timeless truths about structure and possibility, the physical world—and human history—follows much more complex and unpredictable patterns.\n\n\nThe Lasting Legacy\nEuler’s solution to the Königsberg bridge problem did far more than solve a recreational puzzle. It demonstrated that:\n\nAbstract thinking can solve concrete problems\nMathematical proof is more powerful than trial and error\nNetwork structure determines what’s possible in interconnected systems\n\nThese insights now underpin our understanding of everything from internet routing protocols to epidemic spreading models. Every time you use GPS navigation or analyze social network data, you’re applying principles that trace back to Euler’s Sunday stroll through Königsberg.\n\n\nFun trivia:\nLeonhard Euler (1707-1783): Swiss mathematician and physicist, widely regarded as one of the most prolific mathematicians in history. Beyond solving the Königsberg bridge problem, he made fundamental contributions to calculus, topology, number theory, and physics. Despite losing sight in one eye and later becoming completely blind, he continued his mathematical work and produced nearly half of his total output after losing his sight.\nImmanuel Kant (1724-1804): German philosopher and one of the central thinkers of the Enlightenment. Born and died in Königsberg, never traveling more than 10 miles from the city. His systematic works in epistemology, metaphysics, ethics, and aesthetics have made him one of the most influential figures in modern Western philosophy. His regular daily walks were so punctual that neighbors reportedly set their clocks by his daily walks.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Euler Path Concepts - The Birth of Network Science"
    ]
  },
  {
    "objectID": "m01-euler_tour/01-concepts.html#eulers-revolutionary-abstraction",
    "href": "m01-euler_tour/01-concepts.html#eulers-revolutionary-abstraction",
    "title": "Euler Path Concepts - The Birth of Network Science",
    "section": "4 🔍 Euler’s Revolutionary Abstraction",
    "text": "4 🔍 Euler’s Revolutionary Abstraction\nLeonhard Euler approached this puzzle in 1736 with a stroke of genius that would define mathematical thinking for centuries. Instead of getting bogged down in the physical details—the width of the bridges, the size of the islands, the beauty of the architecture—he made a radical simplification.\n\n\nLeonhard Euler (1707-1783) was one of the most prolific mathematicians in history, contributing to nearly every area of mathematics. He lost sight in his right eye in 1738 but continued his work, producing almost half of his total output after becoming completely blind in 1766.\n\nThis was revolutionary thinking for its time. Before Euler, mathematics focused on quantities, measurements, and calculations. Euler showed that sometimes the relationships between objects matter more than the objects themselves.\nEuler realized that for this problem, only one thing mattered: which landmasses connect to which other landmasses. Everything else—the bridge lengths, island shapes, water depths—was irrelevant distraction.\nHe simplified the city into a network of landmasses connected by bridges:\n\n\n\n\n\n\nFigure 1: Euler’s graph of the bridges of Knigsberg. Taken from The Essential Guide to Graph Theory: From an 18th Century Riddle to AI Frameworks\n\n\n\nThis abstraction—reducing a complex physical system to its essential connectivity—was the birth of graph theory. Euler had invented a new mathematical language for describing relationships.\nOnce Euler had his abstract graph, he made another crucial insight. Instead of trying different walking routes (which would take forever), he focused on a fundamental property: how many bridges connect to each landmass?\n\n\nThis shift from “trying all possibilities” to “analyzing constraints” is a hallmark of mathematical thinking. Instead of brute force, Euler used logical reasoning to prove impossibility.\nEuler considered the degree (number of connections) of each node and realized there were only two cases: - a node has an even number of edges, or - a node has an odd number of edges.\nWhen a node has an even number 2k of edges, you can enter and leave the node exactly k times by crossing different edges. Every time you enter through one bridge, you can leave through another. The bridges naturally pair up.\nWhen a node has an odd number 2k+1 of edges, you can enter and leave the node k times, but one edge is left over. The only way to cross this last edge is if your journey starts or ends at this node.\n\n\nThink of it like a dance where everyone needs a partner. In nodes with even degree, every bridge has a “partner” for entering and leaving. Odd-degree nodes always have one “wallflower” bridge that can only be used at the very beginning or end.\nBased on this elegant reasoning, Euler arrived at his famous theorem:\n\n\n\n\n\n\nEuler’s Path Theorem\n\n\n\nA walk that crosses all edges exactly once exists if and only if:\n\nThe graph is connected (you can reach any node from any other node), AND\nEither:\n\nAll nodes have even degree (forms an Euler circuit), OR\nExactly two nodes have odd degree (forms an Euler path)\n\n\n\n\nThis wasn’t just a solution—it was a proof. Euler had shown not just whether such a path exists, but exactly when it’s possible.\n\n\nA good Youtube video explaining the Euler’s story:",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Euler Path Concepts - The Birth of Network Science"
    ]
  },
  {
    "objectID": "m01-euler_tour/01-concepts.html#the-verdict-königsbergs-impossible-dream",
    "href": "m01-euler_tour/01-concepts.html#the-verdict-königsbergs-impossible-dream",
    "title": "Euler Path Concepts - The Birth of Network Science",
    "section": "5 ⚖️ The Verdict: Königsberg’s Impossible Dream",
    "text": "5 ⚖️ The Verdict: Königsberg’s Impossible Dream\nApplying Euler’s theorem to the original Königsberg bridges reveals the truth: every landmass has an odd number of bridges. According to Euler’s conditions, this makes the desired walk impossible.\n\n\nIn the original graph: North shore (3 bridges), South shore (3 bridges), Large island (5 bridges), Small island (3 bridges). Four nodes with odd degree—exactly two more than Euler’s theorem allows.\nThe citizens of Königsberg had been attempting the impossible. Their Sunday stroll puzzle had no solution, and Euler had proven it with mathematical certainty.\nThe story takes a sobering turn during World War II. In 1944, Königsberg was heavily bombed by Allied forces, and later captured by the Soviet Union. Two of the seven historic bridges were destroyed in the bombardment.\n\n\n\nAfter WWII bombing, only five bridges remained—finally making an Euler path possible. {#fig-markdown-fig}\n\n\n\n\nThe city was renamed Kaliningrad and became part of Russia. Today, it remains a Russian exclave, separated from the rest of Russia by Lithuania and Poland. The few remaining bridges span a river now in a very different political landscape.\nWith only five bridges remaining, the network finally satisfied Euler’s conditions: exactly two nodes had odd degree. The mathematical puzzle that had stumped citizens for two centuries was “solved” by the tragic circumstances of war.\nThis ironic resolution reminds us that while mathematics reveals timeless truths about structure and possibility, the physical world—and human history—follows much more complex and unpredictable patterns.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Euler Path Concepts - The Birth of Network Science"
    ]
  },
  {
    "objectID": "m01-euler_tour/01-concepts.html#the-lasting-legacy",
    "href": "m01-euler_tour/01-concepts.html#the-lasting-legacy",
    "title": "Euler Path Concepts - The Birth of Network Science",
    "section": "6 The Lasting Legacy",
    "text": "6 The Lasting Legacy\nEuler’s solution to the Königsberg bridge problem did far more than solve a recreational puzzle. It demonstrated that:\n\nAbstract thinking can solve concrete problems\nMathematical proof is more powerful than trial and error\nNetwork structure determines what’s possible in interconnected systems\n\nThese insights now underpin our understanding of everything from internet routing protocols to epidemic spreading models. Every time you use GPS navigation or analyze social network data, you’re applying principles that trace back to Euler’s Sunday stroll through Königsberg.\n\nFun trivia:\nLeonhard Euler (1707-1783): Swiss mathematician and physicist, widely regarded as one of the most prolific mathematicians in history. Beyond solving the Königsberg bridge problem, he made fundamental contributions to calculus, topology, number theory, and physics. Despite losing sight in one eye and later becoming completely blind, he continued his mathematical work and produced nearly half of his total output after losing his sight.\nImmanuel Kant (1724-1804): German philosopher and one of the central thinkers of the Enlightenment. Born and died in Königsberg, never traveling more than 10 miles from the city. His systematic works in epistemology, metaphysics, ethics, and aesthetics have made him one of the most influential figures in modern Western philosophy. His regular daily walks were so punctual that neighbors reportedly set their clocks by his daily walks.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Euler Path Concepts - The Birth of Network Science"
    ]
  },
  {
    "objectID": "m01-euler_tour/01-concepts.html#references",
    "href": "m01-euler_tour/01-concepts.html#references",
    "title": "Euler Path Concepts - The Birth of Network Science",
    "section": "7 References",
    "text": "7 References\n\n\nMoro, Esteban. 2017. “Network Science for Kids!” http://estebanmoro.org/2017/03/network-science-for-kids.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Euler Path Concepts - The Birth of Network Science"
    ]
  },
  {
    "objectID": "m01-euler_tour/02-coding.html",
    "href": "m01-euler_tour/02-coding.html",
    "title": "Coding Networks in Python",
    "section": "",
    "text": "Now that you understand the conceptual foundation from Euler’s work, let’s explore how to represent and analyze networks computationally. Given a network of any size, our goal is to create a function that can tell us whether the network has an Euler path or not.\nWe’ll work through both general network representations and apply them specifically to the Königsberg bridge problem.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Coding Networks in Python"
    ]
  },
  {
    "objectID": "m01-euler_tour/02-coding.html#network-representations-from-pictures-to-data-structures",
    "href": "m01-euler_tour/02-coding.html#network-representations-from-pictures-to-data-structures",
    "title": "Coding Networks in Python",
    "section": "1 Network Representations: From Pictures to Data Structures",
    "text": "1 Network Representations: From Pictures to Data Structures\nConsider this network with 5 nodes and 6 edges:\n\n\n\n\n\n\nFigure 1: A small graph of five nodes and six edges.\n\n\n\nHow do we represent this graph in a format that a computer can understand and manipulate? Just as Euler needed to abstract Königsberg’s bridges, we need data structures that capture the network’s essential connectivity while enabling efficient analysis.\n\n\nThe choice of representation can dramatically affect computational efficiency. For sparse networks (few edges), adjacency lists are memory-efficient. For dense networks or matrix operations, adjacency matrices are preferred.\nLet’s explore three fundamental approaches that form the backbone of all network algorithms.\n\nEdge Table: The Direct Approach\nThe edge table directly lists connections as pairs—the most intuitive way to store network data.\n\n\nEdge tables are also called “edge lists” and are the most common format for storing large-scale network data in files. Social media platforms like Twitter and Facebook store billions of connections this way.\n\n# Each row represents one edge (connection between two nodes)\nedges = [\n    (0, 1),  # Node 0 connects to Node 1\n    (0, 2),  # Node 0 connects to Node 2\n    (1, 2),  # Node 1 connects to Node 2\n    (1, 3),  # Node 1 connects to Node 3\n    (2, 4),  # Node 2 connects to Node 4\n    (3, 4)   # Node 3 connects to Node 4\n]\n\nprint(f\"Network has {len(edges)} edges\")\nprint(\"Edge list:\", edges)\n\nNetwork has 6 edges\nEdge list: [(0, 1), (0, 2), (1, 2), (1, 3), (2, 4), (3, 4)]\n\n\nThis mirrors how we’d naturally describe the network: “Node 0 connects to nodes 1 and 2, node 1 connects to nodes 0, 2, and 3…” It’s the digital equivalent of Euler’s original approach—simply listing which bridges connect which landmasses.\n\n\nAdjacency List: The Neighborhood Map\nThe adjacency list stores each node’s neighbors in a dictionary—like a social network where each person has a list of friends.\n\n\nMost graph algorithms prefer adjacency lists because they allow fast iteration over a node’s neighbors. This is crucial for algorithms like breadth-first search or computing clustering coefficients.\n\n# Define adjacency list directly as a dictionary\nneighbors = {\n    0: [1, 2],     # Node 0 connects to nodes 1 and 2\n    1: [0, 2, 3],  # Node 1 connects to nodes 0, 2, and 3\n    2: [0, 1, 4],  # Node 2 connects to nodes 0, 1, and 4\n    3: [1, 4],     # Node 3 connects to nodes 1 and 4\n    4: [2, 3]      # Node 4 connects to nodes 2 and 3\n}\n\nprint(\"Adjacency list representation:\")\nfor node, neighbor_list in neighbors.items():\n    print(f\"Node {node}: {neighbor_list}\")\n\nAdjacency list representation:\nNode 0: [1, 2]\nNode 1: [0, 2, 3]\nNode 2: [0, 1, 4]\nNode 3: [1, 4]\nNode 4: [2, 3]\n\n\n\n\nAdjacency Matrix\nThe adjacency matrix uses a grid where entry (i,j) = 1 if nodes are connected—the mathematician’s favorite representation.\n\n\nAdjacency matrices enable powerful mathematical operations. Matrix multiplication reveals paths of different lengths, and eigenvalue analysis can uncover community structure. Google’s PageRank algorithm fundamentally relies on matrix operations.\n\n# Define adjacency matrix directly\nimport numpy as np\n\nmatrix = np.array([\n    [0, 1, 1, 0, 0],  # Node 0 connects to nodes 1, 2\n    [1, 0, 1, 1, 0],  # Node 1 connects to nodes 0, 2, 3\n    [1, 1, 0, 0, 1],  # Node 2 connects to nodes 0, 1, 4\n    [0, 1, 0, 0, 1],  # Node 3 connects to nodes 1, 4\n    [0, 0, 1, 1, 0]   # Node 4 connects to nodes 2, 3\n])\n\nprint(\"Adjacency matrix:\")\nprint(matrix)\n\nAdjacency matrix:\n[[0 1 1 0 0]\n [1 0 1 1 0]\n [1 1 0 0 1]\n [0 1 0 0 1]\n [0 0 1 1 0]]\n\n\nNotice the symmetry: if node i connects to node j, then node j connects to node i (for undirected networks). This symmetry disappears in directed networks, where relationships can be one-way.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Coding Networks in Python"
    ]
  },
  {
    "objectID": "m01-euler_tour/02-coding.html#node-degrees",
    "href": "m01-euler_tour/02-coding.html#node-degrees",
    "title": "Coding Networks in Python",
    "section": "2 Node Degrees",
    "text": "2 Node Degrees\nThe degree of a node is the number of edges connected to it. This simple concept was central to Euler’s proof—he realized that a valid bridge walk requires each landmass to have an even degree (except possibly the starting and ending points).\n\n\nIn Königsberg, all four landmasses had odd degree, making the bridge walk impossible. This insight—that global properties emerge from local structure—remains fundamental to network analysis today.\nHere’s how to compute degrees using each representation:\n\nFrom Edge Table\nCount how many times each node appears in the edge list.\n\n_degrees = [0] * 5\nfor node1, node2 in edges:\n    _degrees[node1] += 1\n    _degrees[node2] += 1\nprint(\"Degrees from edge list:\", _degrees)\n\nDegrees from edge list: [2, 3, 3, 2, 2]\n\n\n\n\nWe increment the degree counter for both nodes in each edge because every edge contributes to two nodes’ degrees. This is why the total degree always equals twice the number of edges.\n\n\nFrom Adjacency List\nCount the length of each node’s neighbor list—the most direct approach.\n\n_degrees = [len(neighbors[i]) for i in range(5)]\nprint(\"Degrees from adjacency list:\", _degrees)\n\nDegrees from adjacency list: [2, 3, 3, 2, 2]\n\n\n\n\nFrom Adjacency Matrix\nSum each row (or column) of the matrix—leveraging vectorized operations.\n\n_degrees = matrix.sum(axis=1)  # Sum rows\nprint(\"Degrees from adjacency matrix:\", _degrees)\n\nDegrees from adjacency matrix: [2 3 3 2 2]\n\n\n\n\nFor undirected networks, row sums equal column sums. For directed networks, row sums give out-degree (outgoing connections) while column sums give in-degree (incoming connections).",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Coding Networks in Python"
    ]
  },
  {
    "objectID": "m01-euler_tour/02-coding.html#checking-for-trails-walks-and-paths",
    "href": "m01-euler_tour/02-coding.html#checking-for-trails-walks-and-paths",
    "title": "Coding Networks in Python",
    "section": "3 Checking for Trails, Walks, and Paths",
    "text": "3 Checking for Trails, Walks, and Paths\nNow that we understand how to represent networks and compute degrees, let’s implement functions to verify whether a sequence of nodes represents a valid walk, trail, path, or cycle. These verification algorithms are essential for network analysis and implementing graph traversal algorithms.\n\nVerifying a Walk\nA walk is the most permissive—we simply need to check that each consecutive pair of nodes is connected by an edge.\n\ndef is_walk(sequence, adjacency_matrix):\n    \"\"\"\n    Check if a sequence of nodes forms a valid walk.\n\n    Args:\n        sequence: List of node indices [v0, v1, v2, ...]\n        adjacency_matrix: 2D numpy array representing the graph\n\n    Returns:\n        bool: True if sequence is a valid walk, False otherwise\n    \"\"\"\n    if len(sequence) &lt; 2:\n        return True  # Single node or empty sequence is trivially a walk\n\n    # Use NumPy vectorized operations for efficient edge checking\n    sequence = np.array(sequence)\n    current_nodes = sequence[:-1]  # All nodes except the last\n    next_nodes = sequence[1:]      # All nodes except the first\n\n    # Simple but slower: for loop version (slower but more explicit)\n    # for i, j in zip(current_nodes, next_nodes):\n    #     if adjacency_matrix[i, j] == 0:\n    #         return False\n    # return True\n\n    # Check all edges at once using advanced indexing\n    edges_exist = adjacency_matrix[current_nodes, next_nodes]\n\n    # All edges must exist (all values must be 1)\n    return np.all(edges_exist == 1)\n\n\n# Test with our sample network\ntest_sequence = [0, 1, 2, 4, 3, 1]\nprint(f\"Sequence {test_sequence} is a valid walk: {is_walk(test_sequence, matrix)}\")\n\n# Test an invalid walk\ninvalid_sequence = [0, 3]  # No direct edge between 0 and 3\nprint(f\"Sequence {invalid_sequence} is a valid walk: {is_walk(invalid_sequence, matrix)}\")\n\nSequence [0, 1, 2, 4, 3, 1] is a valid walk: True\nSequence [0, 3] is a valid walk: False\n\n\n\n\n\n\n\n\nMind the loops!\n\n\n\nFor loops in Python is the notorious source of computational bottlenecks. Avoiding for loops significantly boosts the speed. In is_walk, we use one for loop but you can avoid it by using NumPy’s advanced indexing, i.e., adjacency_matrix[(current_nodes, next_nodes)]. The way to think about this is that (current_nodes, next_nodes) is a tuple of indices, acting as a multi-dimensional index. adjacency_matrix[(current_nodes, next_nodes)] is 1d array of length the same as current_nodes and next_nodes. If the value is 0, then the edge does not exist. We can then check if all the values are not zero.\n\n\n\n\nVerifying a Trail\nA trail requires all edges to be distinct, but nodes can repeat.\n\ndef is_trail(sequence, adjacency_matrix):\n    \"\"\"\n    Check if a sequence of nodes forms a valid trail.\n\n    Args:\n        sequence: List of node indices [v0, v1, v2, ...]\n        adjacency_matrix: 2D numpy array representing the graph\n\n    Returns:\n        bool: True if sequence is a valid trail, False otherwise\n    \"\"\"\n    if not is_walk(sequence, adjacency_matrix):\n        return False  # Must be a valid walk first\n\n    if len(sequence) &lt; 2:\n        return True\n\n    # Convert to numpy for efficient operations\n    sequence = np.array(sequence)\n    current_nodes = sequence[:-1]\n    next_nodes = sequence[1:]\n\n    # Use complex numbers to represent edges!\n    # For undirected graph: smaller_node + 1j * larger_node\n    # This ensures edge (1,2) and (2,1) both become 1+2j\n    edge_starts = np.minimum(current_nodes, next_nodes)  # Real part\n    edge_ends = np.maximum(current_nodes, next_nodes)    # Imaginary part\n    complex_edges = edge_starts + 1j * edge_ends\n\n    # Check uniqueness directly with NumPy\n    return len(complex_edges) == len(np.unique(complex_edges))\n\n    # Alternative: Original for loop version (slower but more explicit)\n    # used_edges = set()\n    # for i in range(len(sequence) - 1):\n    #     current_node = sequence[i]\n    #     next_node = sequence[i + 1]\n    #     # Create edge tuple (smaller index first for undirected graphs)\n    #     edge = (min(current_node, next_node), max(current_node, next_node))\n    #     if edge in used_edges:\n    #         return False  # Edge already used\n    #     used_edges.add(edge)\n    # return True\n\n# Test trail verification\ntrail_sequence = [0, 1, 3, 4, 2]\nprint(f\"Sequence {trail_sequence} is a valid trail: {is_trail(trail_sequence, matrix)}\")\n\n# Test invalid trail (reuses edge 1-2)\ninvalid_trail = [0, 1, 2, 1, 3]\nprint(f\"Sequence {invalid_trail} is a valid trail: {is_trail(invalid_trail, matrix)}\")\n\nSequence [0, 1, 3, 4, 2] is a valid trail: True\nSequence [0, 1, 2, 1, 3] is a valid trail: False\n\n\n\n\nnp.unique is a powerful function that can handle complex numbers natively.\n\n\n\n\n\n\nComplex Numbers for Edge Representation\n\n\n\nWe use complex numbers to represent edges! Each edge becomes smaller_node + 1j * larger_node. For example, edge (1,2) becomes 1+2j, and edge (2,1) also becomes 1+2j (normalized). Think of complex numbers as natural 2D coordinates for representing node pairs.\n\n\n\n\nVerifying a Path\nA path requires all nodes (except possibly start/end for cycles) to be distinct.\n\ndef is_path(sequence, adjacency_matrix):\n    \"\"\"\n    Check if a sequence of nodes forms a valid path.\n\n    Args:\n        sequence: List of node indices [v0, v1, v2, ...]\n        adjacency_matrix: 2D numpy array representing the graph\n        allow_cycle: If True, allows start node = end node (cycle)\n\n    Returns:\n        bool: True if sequence is a valid path, False otherwise\n    \"\"\"\n    if not is_walk(sequence, adjacency_matrix):\n        return False  # Must be a valid walk first\n\n    if len(sequence) &lt; 2:\n        return True\n\n    sequence = np.array(sequence)\n\n    return len(sequence) == len(np.unique(sequence))\n\n# Test path verification\npath_sequence = [0, 1, 3, 4]\nprint(f\"Sequence {path_sequence} is a valid path: {is_path(path_sequence, matrix)}\")\n\n# Test invalid path (repeats node 1)\ninvalid_path = [0, 1, 2, 1, 3]\nprint(f\"Sequence {invalid_path} is a valid path: {is_path(invalid_path, matrix)}\")\n\nSequence [0, 1, 3, 4] is a valid path: True\nSequence [0, 1, 2, 1, 3] is a valid path: False",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Coding Networks in Python"
    ]
  },
  {
    "objectID": "m01-euler_tour/02-coding.html#summary",
    "href": "m01-euler_tour/02-coding.html#summary",
    "title": "Coding Networks in Python",
    "section": "4 Summary",
    "text": "4 Summary\nYou now understand how to:\n\nRepresent networks using edge lists, adjacency lists, and adjacency matrices\nCompute node degrees efficiently using different data structures\nVerify walks, trails, paths, and cycles",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Coding Networks in Python"
    ]
  },
  {
    "objectID": "m01-euler_tour/01-concepts.html#the-königsberg-bridge-problem",
    "href": "m01-euler_tour/01-concepts.html#the-königsberg-bridge-problem",
    "title": "Euler Path Concepts - The Birth of Network Science",
    "section": "2 The Königsberg Bridge Problem",
    "text": "2 The Königsberg Bridge Problem\n\nA Sunday Stroll That Changed Mathematics\nBack in the 18th century, there was a city called Königsberg situated on the Pregel River in what was then Prussia (now Kaliningrad, Russia). The city was built around two large islands, beautifully connected to each other and the mainland by seven elegant bridges.\n\n\nKönigsberg was a major intellectual center of the Enlightenment. Immanuel Kant spent his entire life there, never traveling more than 10 miles from the city. The university attracted scholars from across Europe.\nDuring their leisurely Sunday walks, the citizens of Königsberg found themselves pondering an intriguing puzzle:\n\n\n\n\n\n\nThe Königsberg Bridge Problem\n\n\n\nIs it possible to take a walk through the city that crosses each bridge exactly once and returns to the starting point?\n\n\n\n\n\nThe seven bridges of Königsberg {#fig-seven-bridges}\n\n\nThis seemingly innocent recreational question would become one of the most important problems in the history of mathematics. What made it revolutionary wasn’t the answer, but how the answer was found.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Euler Path Concepts - The Birth of Network Science"
    ]
  },
  {
    "objectID": "m01-euler_tour/01-concepts.html#walk-path-and-trail",
    "href": "m01-euler_tour/01-concepts.html#walk-path-and-trail",
    "title": "Euler Path Concepts - The Birth of Network Science",
    "section": "4 Walk, Path, and Trail",
    "text": "4 Walk, Path, and Trail\n\n\nHere is a short video explaining the difference between walk, path, and trail. Good one to watch if you are visual learner.\n\n\nWe used the term walk and path in the previous section. But what are they? Let’s define them formally in the following.\nA walk is the most general type of movement through a network. Imagine you’re exploring a city with no restrictions:\n\nYou can visit any vertex (intersection) multiple times\nYou can traverse any edge (street) multiple times\nYou simply move from one connected vertex to another\n\nFormally, a walk is a sequence of nodes where each consecutive node pair is connected by an edge. No teleportation is allowed in a walk on a network.\nA trail is a walk without traversing the same edge twice. You can still visit the same node multiple times though via different edges.\n\n\n\n\n\n\nTrail\n\n\n\nIf edges are directed and two nodes are bidirectionally connected, then an edge from one node to the other is a different edge from the other node to the first node.\n\n\n\n\nA mail carrier’s route through a neighborhood: they might return to the same intersection multiple times but should traverse each street exactly once for efficiency.\nA path is a more restrictive type of walk without revisiting the same node.\n\n\n\nWalk: You can fly from New York to London, then back to New York, then to Paris, possibly using the same flight routes multiple times.\nTrail: You plan a trip where you never take the same flight route twice, but you might visit the same city more than once (e.g., New York \\rightarrow London \\rightarrow Paris \\rightarrow New York \\rightarrow Rome).\nPath: You visit a sequence of cities where you never visit the same city twice (e.g., New York \\rightarrow London \\rightarrow Paris \\rightarrow Rome).\n\nIn airline route maps, a trail means you never repeat a specific flight segment, while a path means you never return to a city you’ve already visited.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Euler Path Concepts - The Birth of Network Science"
    ]
  },
  {
    "objectID": "m01-euler_tour/04-advanced.html",
    "href": "m01-euler_tour/04-advanced.html",
    "title": "Advanced: Sparse Matrices for Large-Scale Networks",
    "section": "",
    "text": "Modern networks have billions of nodes—far beyond Königsberg’s 4 landmasses. A dense adjacency matrix for Earth’s 8 billion people would require 512 exabytes of memory!\nReal networks are sparse: most node pairs aren’t connected. Edge lists save memory but are inefficient for common operations like finding neighbors or computing degrees.\n\n\nThink about the following operations:\n\nDegree: How many friends does a person have?\nNeighbors: Who are the friends of a person?\n\nThese operations are very common in network analysis. To do so, you need to go through all the edges in the network. This is not efficient, especially for large networks.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Advanced: Sparse Matrices for Large-Scale Networks"
    ]
  },
  {
    "objectID": "m01-euler_tour/04-advanced.html#the-scale-problem-from-königsberg-to-global-networks",
    "href": "m01-euler_tour/04-advanced.html#the-scale-problem-from-königsberg-to-global-networks",
    "title": "Advanced: Sparse Matrices for Large-Scale Networks",
    "section": "",
    "text": "Modern networks have billions of nodes—far beyond Königsberg’s 4 landmasses. A dense adjacency matrix for Earth’s 8 billion people would require 512 exabytes of memory!\nReal networks are sparse: most node pairs aren’t connected. Edge lists save memory but are inefficient for common operations like finding neighbors or computing degrees.\n\n\nThink about the following operations:\n\nDegree: How many friends does a person have?\nNeighbors: Who are the friends of a person?\n\nThese operations are very common in network analysis. To do so, you need to go through all the edges in the network. This is not efficient, especially for large networks.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Advanced: Sparse Matrices for Large-Scale Networks"
    ]
  },
  {
    "objectID": "m01-euler_tour/04-advanced.html#solution-sparse-matrices",
    "href": "m01-euler_tour/04-advanced.html#solution-sparse-matrices",
    "title": "Advanced: Sparse Matrices for Large-Scale Networks",
    "section": "2 Solution: Sparse Matrices",
    "text": "2 Solution: Sparse Matrices\nWe say a matrix is sparse if the matrix has only a handful of non-zero entries. This is indeed the case for most real-world networks. For such networks, we can use a special type of data type called Compressed Sparse Row (CSR) or Compressed Sparse Column (CSC) to represent the network. This is widely used in many network analysis tools and makes it possible to process large networks in practice.\nTo learn more, here is a very good blog post by Matt Eding about efficient network representations.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Advanced: Sparse Matrices for Large-Scale Networks"
    ]
  },
  {
    "objectID": "m01-euler_tour/04-advanced.html#scipys-compressed-sparse-row-csr-format",
    "href": "m01-euler_tour/04-advanced.html#scipys-compressed-sparse-row-csr-format",
    "title": "Advanced: Sparse Matrices for Large-Scale Networks",
    "section": "3 SciPy’s Compressed Sparse Row (CSR) Format",
    "text": "3 SciPy’s Compressed Sparse Row (CSR) Format\n\n\nHere is a short video explaining the CSR format. Good one to watch if you are visual learner.\n\n\n\n\n\n\n\n\nFigure 1: A sparse matrix is a matrix with only a handful of non-zero entries represented with a compressed sparse frmat.\n\n\n\nCSR stores only non-zero matrix entries using three arrays, making it the standard for large-scale network analysis.\n\nUnderstanding CSR Structure\nCSR format uses three arrays to represent a sparse matrix:\n\ndata: Contains all non-zero values\nindices: Column indices of each non-zero value\nindptr: Row pointers indicating where each row starts in the data array\n\n\n\nMemory efficiency: For a sparse matrix with m non-zero entries out of n^2 total entries, CSR uses O(m + n) memory instead of O(n^2). For social networks where m \\ll n^2, this is a massive saving!\n\nimport numpy as np\nfrom scipy import sparse\n\n# Create a small example network\n# Let's represent the same 5-node network from earlier\ndense_matrix = np.array([\n    [0, 1, 1, 0, 0],  # Node 0 connects to nodes 1, 2\n    [1, 0, 1, 1, 0],  # Node 1 connects to nodes 0, 2, 3\n    [1, 1, 0, 0, 1],  # Node 2 connects to nodes 0, 1, 4\n    [0, 1, 0, 0, 1],  # Node 3 connects to nodes 1, 4\n    [0, 0, 1, 1, 0]   # Node 4 connects to nodes 2, 3\n])\n\n# Convert to CSR format\ncsr_matrix = sparse.csr_matrix(dense_matrix)\n\nprint(\"Dense matrix shape:\", dense_matrix.shape)\nprint(\"CSR matrix shape:\", csr_matrix.shape)\nprint(\"Non-zero entries:\", csr_matrix.nnz)\nprint(\"Memory saved: {:.1f}%\".format((1 - csr_matrix.nnz / dense_matrix.size) * 100))\n\nDense matrix shape: (5, 5)\nCSR matrix shape: (5, 5)\nNon-zero entries: 12\nMemory saved: 52.0%\n\n\n\n\nInside the CSR Format\nLet’s examine the internal structure of our CSR matrix:\n\nprint(\"CSR internal arrays:\")\nprint(\"data (non-zero values):\", csr_matrix.data)\nprint(\"indices (column positions):\", csr_matrix.indices)\nprint(\"indptr (row pointers):\", csr_matrix.indptr)\n\n# Let's trace through how CSR works\nprint(\"\\nDecoding CSR structure:\")\nfor i in range(len(csr_matrix.indptr) - 1):\n    start = csr_matrix.indptr[i]\n    end = csr_matrix.indptr[i + 1]\n    row_data = csr_matrix.data[start:end]\n    row_indices = csr_matrix.indices[start:end]\n    print(f\"Row {i}: values {row_data} at columns {row_indices}\")\n\nCSR internal arrays:\ndata (non-zero values): [1 1 1 1 1 1 1 1 1 1 1 1]\nindices (column positions): [1 2 0 2 3 0 1 4 1 4 2 3]\nindptr (row pointers): [ 0  2  5  8 10 12]\n\nDecoding CSR structure:\nRow 0: values [1 1] at columns [1 2]\nRow 1: values [1 1 1] at columns [0 2 3]\nRow 2: values [1 1 1] at columns [0 1 4]\nRow 3: values [1 1] at columns [1 4]\nRow 4: values [1 1] at columns [2 3]\n\n\n\n\n\n\n\n\nHow CSR Works\n\n\n\nFor row i, the non-zero values are stored in data[indptr[i]:indptr[i+1]] with their column positions in indices[indptr[i]:indptr[i+1]].\nFor example, if indptr[0] = 0 and indptr[1] = 2, then row 0 has non-zero values data[0:2] at columns indices[0:2].\n\n\n\n\nCreating CSR Matrices from Edge Lists\nThe most common way to create network CSR matrices is from edge lists:\n\n# Define our network as an edge list\nedges = [\n    (0, 1), (0, 2),  # Node 0 connections\n    (1, 2), (1, 3),  # Node 1 connections\n    (2, 4),          # Node 2 connections\n    (3, 4)           # Node 3 connections\n]\n\n# Extract source and target nodes\nsources = [edge[0] for edge in edges]\ntargets = [edge[1] for edge in edges]\n\n# For undirected graphs, add reverse edges\nall_sources = sources + targets\nall_targets = targets + sources\n\n# Create data array (all ones for unweighted graph)\ndata_values = np.ones(len(all_sources))\n\n# Create CSR matrix directly from edge list\nn_nodes = 5\ncsr_from_edges = sparse.csr_matrix(\n    (data_values, (all_sources, all_targets)),\n    shape=(n_nodes, n_nodes)\n)\n\nprint(\"CSR from edge list:\")\nprint(csr_from_edges.toarray())\n\nCSR from edge list:\n[[0. 1. 1. 0. 0.]\n [1. 0. 1. 1. 0.]\n [1. 1. 0. 0. 1.]\n [0. 1. 0. 0. 1.]\n [0. 0. 1. 1. 0.]]\n\n\n\n\nEfficient Operations with CSR\nCSR format enables efficient network operations that would be slow with dense matrices:\n\n# Node degrees - sum each row\ndegrees = np.array(csr_matrix.sum(axis=1)).flatten()\nprint(\"Node degrees:\", degrees)\n\n# Find neighbors of node 1\nnode_1_neighbors = csr_matrix.indices[csr_matrix.indptr[1]:csr_matrix.indptr[2]]\nprint(\"Node 1 neighbors:\", node_1_neighbors)\n\n# Matrix multiplication for 2-hop paths\ntwo_hop_matrix = csr_matrix @ csr_matrix\nprint(\"Two-hop connections (shows paths of length 2):\")\nprint(two_hop_matrix.toarray())\n\nNode degrees: [2 3 3 2 2]\nNode 1 neighbors: [0 2 3]\nTwo-hop connections (shows paths of length 2):\n[[2 1 1 1 1]\n [1 3 1 0 2]\n [1 1 3 2 0]\n [1 0 2 2 0]\n [1 2 0 0 2]]\n\n\n\n\nMatrix multiplication: @ is the matrix multiplication operator in SciPy and NumPy. It is equivalent to np.dot.\n\n\nMemory Comparison: Dense vs CSR\nLet’s demonstrate the memory efficiency with a larger, sparser network:\n\n# Create a larger sparse network\nn = 1000\ndensity = 0.01  # Only 1% of edges exist\n\n# Generate random sparse matrix\nnp.random.seed(42)\nlarge_dense = sparse.random(n, n, density=density, format='csr')\n\nprint(f\"Network size: {n} × {n} = {n**2:,} potential edges\")\nprint(f\"Actual edges: {large_dense.nnz:,}\")\nprint(f\"Sparsity: {(1 - large_dense.nnz / (n*n)) * 100:.1f}% zeros\")\nprint(f\"CSR memory usage: ~{(large_dense.nnz * 2 + n) * 4 / 1024:.1f} KB\")\nprint(f\"Dense memory usage: ~{n*n * 4 / 1024:.1f} KB\")\nprint(f\"Memory savings: {((n*n * 4) - (large_dense.nnz * 2 + n) * 4) / (n*n * 4) * 100:.1f}%\")\n\nNetwork size: 1000 × 1000 = 1,000,000 potential edges\nActual edges: 10,000\nSparsity: 99.0% zeros\nCSR memory usage: ~82.0 KB\nDense memory usage: ~3906.2 KB\nMemory savings: 97.9%\n\n\n\n\nCSR for Network Analysis Algorithms\nCSR format integrates seamlessly with our previously defined functions:\n\ndef is_walk_sparse(sequence, csr_matrix):\n    \"\"\"\n    Check if a sequence forms a valid walk using sparse CSR matrix.\n    \"\"\"\n    if len(sequence) &lt; 2:\n        return True\n\n    sequence = np.array(sequence)\n    current_nodes = sequence[:-1]\n    next_nodes = sequence[1:]\n\n    # Use CSR matrix indexing - still works with advanced indexing!\n    edges_exist = csr_matrix[(current_nodes, next_nodes)]\n\n    # Convert sparse result to array and check\n    return np.all(edges_exist == 1)\n\n# Test with our CSR matrix\ntest_walk = [0, 1, 2, 4, 3, 1]\nprint(f\"Walk {test_walk} is valid: {is_walk_sparse(test_walk, csr_matrix)}\")\n\nWalk [0, 1, 2, 4, 3, 1] is valid: True\n\n\n\n\n\n\n\n\nBest Practices\n\n\n\nWhen to use CSR: - Sparse matrices - Row-based operations (computing degrees, finding neighbors) - Matrix-vector multiplication\nWhen to use dense matrices: - Small networks - Dense networks - Frequent random access to individual entries\n\n\n\n\nThere are several different sparse matrix formats such as COO, CSC, and LIL. If you are interested in learning more, you can check out this blog post by Matt Eding. The following video is also a good one to watch.\n\n\n\n\nAdvanced CSR Features\n\n# Submatrix extraction - get connections for subset of nodes\nsubset_nodes = [0, 1, 2]\nsubgraph = csr_matrix[subset_nodes][:, subset_nodes]\nprint(\"Subgraph for nodes [0, 1, 2]:\")\nprint(subgraph.toarray())\n\n# Efficient boolean operations\n# Find nodes with degree &gt; 2\nhigh_degree_nodes = np.where(degrees &gt; 2)[0]\nprint(\"High degree nodes (&gt; 2 connections):\", high_degree_nodes)\n\n# Matrix powers for path counting\npaths_3 = csr_matrix ** 3  # Counts 3-step paths\nprint(\"3-step path counts:\")\nprint(paths_3.toarray())\n\nSubgraph for nodes [0, 1, 2]:\n[[0 1 1]\n [1 0 1]\n [1 1 0]]\nHigh degree nodes (&gt; 2 connections): [1 2]\n3-step path counts:\n[[2 4 4 2 2]\n [4 2 6 5 1]\n [4 6 2 1 5]\n [2 5 1 0 4]\n [2 1 5 4 0]]\n\n\nThe CSR format transforms network analysis from impossible to practical for large-scale networks. By storing only the essential information (non-zero connections), we can analyze networks with millions of nodes and billions of edges on standard hardware—something that would require exabytes of memory with dense matrices!",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Advanced: Sparse Matrices for Large-Scale Networks"
    ]
  },
  {
    "objectID": "m01-euler_tour/01-concepts.html#cycle-and-circuit",
    "href": "m01-euler_tour/01-concepts.html#cycle-and-circuit",
    "title": "Euler Path Concepts - The Birth of Network Science",
    "section": "5 Cycle and Circuit",
    "text": "5 Cycle and Circuit\nCycle and Circuit are two special types of walks that start and end at the same node—they form closed loops in the network.\nA circuit is a closed trail—a trail that starts and ends at the same vertex. Think of it as making a round trip where you never use the same road twice, but you can pass through the same intersections multiple times.\n\n\nExample: A tourist exploring a city who wants to end up back at their hotel without taking any street twice. They might pass through Times Square multiple times via different streets, but never walk down Broadway twice.\nA cycle is a closed path—a path that starts and ends at the same vertex with no repeated vertices (except for the starting/ending vertex). It’s the most restrictive type of closed walk.\n\n\nExample: A delivery truck route that visits each neighborhood exactly once before returning to the depot. Each stop is unique, forming a perfect loop.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Euler Path Concepts - The Birth of Network Science"
    ]
  },
  {
    "objectID": "m01-euler_tour/01-concepts.html#eulers-special-cases",
    "href": "m01-euler_tour/01-concepts.html#eulers-special-cases",
    "title": "Euler Path Concepts - The Birth of Network Science",
    "section": "6 Euler’s Special Cases",
    "text": "6 Euler’s Special Cases\nNow we can precisely define what Euler was looking for in Königsberg:\n\nEuler Trail: A trail that includes every edge in the graph exactly once\nEuler Circuit/Cycle: An Euler trail that starts and ends at the same vertex\n\nThe Königsberg citizens were seeking an Euler circuit—a closed trail that would cross every bridge exactly once and return them home.",
    "crumbs": [
      "Home",
      "M01: Euler Path",
      "Euler Path Concepts - The Birth of Network Science"
    ]
  },
  {
    "objectID": "course/about.html",
    "href": "course/about.html",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "Networks are everywhere—from the Internet connecting billions of devices to the social connections that shape our daily lives. This course explores network data analysis from the ground up, combining hands-on coding with theoretical foundations to unlock the secrets of complex systems.",
    "crumbs": [
      "Home",
      "Course Information",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "course/about.html#course-information",
    "href": "course/about.html#course-information",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "Welcome! My name is Sadamori Kojaku, the instructor of this course. I started my career as a computer scientist but couldn’t resist to fall in love with Network Science right after I got Ph.D. Network Science is about a science on networks, and networks appear in many different forms in our daily lives. The internet, social media, and biological networks, power grid, and you name it. But when we abstract them into a bunch of dots connected by lines, we can compare them and understand them in a unified way. We can study them using the same toolkit no matter what the domain is, and can find universal patterns and principles that govern seemingly different systems. This course will guide you through the fascinating world of networks, from foundational theory to hands-on coding and real-world applications. I hope you will enjoy and find the course useful in\n\nAbout the Instructor:\nSadamori Kojaku\nInstructor: Sadamori Kojaku\nCourse Hours: Wednesdays 16:40 - 19:40\nLocation: G22 Engineering Building\nCredits: 3\nOffice Hours:\n\nTuesdays & Thursdays 14:30 - 16:30 (J19 Engineering Building)\n\n\nWelcome to Advanced Topics in Network Science! This course will guide you through the fascinating world of networks, from foundational theory to hands-on coding and real-world applications. Whether you’re interested in social networks, biological systems, or technological infrastructures, you’ll gain the skills to analyze and understand complex interconnected systems. Let’s embark on this journey together!",
    "crumbs": [
      "Home",
      "Course Information",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "course/about.html#learning-philosophy",
    "href": "course/about.html#learning-philosophy",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "“Don’t think! Feeeeeel” - Bruce Lee, Enter the Dragon\n\nThis quote guides our approach. Rather than just memorizing formulas, you’ll feel network concepts through:\n\nHands-on coding with real network data\nPen-and-paper exercises to build intuition\nInteractive visualizations to see patterns emerge\nWeekly quizzes to reinforce understanding",
    "crumbs": [
      "Home",
      "Course Information",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "course/about.html#course-structure",
    "href": "course/about.html#course-structure",
    "title": "Advanced Topics in Network Science",
    "section": "3 Course Structure",
    "text": "3 Course Structure\n\nLearning Outcomes\nAfter completing this course, you will:\n\nInterpret and evaluate modern network science literature and methodologies\nConduct advanced network analysis using mathematical and computational tools\nDesign original research using network science methods\nIntegrate systems engineering knowledge with network modeling skills\n\n\n\nAssessment\n\nAttendance & Quizzes: 20%\nAssignments: 20%\nExam: 30%\nFinal Project: 30%",
    "crumbs": [
      "Home",
      "Course Information",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "course/about.html#resources",
    "href": "course/about.html#resources",
    "title": "Advanced Topics in Network Science",
    "section": "3 Resources",
    "text": "3 Resources\n\nEssential Textbooks\n\nMark Newman, Networks (Second Edition), Oxford University Press, 2018\nFilippo Menczer, Santo Fortunato, and Clayton A. Davis, A First Course in Network Science, Cambridge University Press, 2020\nJames Bagrow and Yong-Yeol Ahn, Working with Network Data: A Data Science Perspective, Cambridge University Press, 2024",
    "crumbs": [
      "Home",
      "Course Information",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "course/about.html#prerequisites",
    "href": "course/about.html#prerequisites",
    "title": "Advanced Topics in Network Science",
    "section": "4 Prerequisites",
    "text": "4 Prerequisites\n\nSSIE-523 or equivalent\nFluency in Python programming\nBasic understanding of mathematics and statistics",
    "crumbs": [
      "Home",
      "Course Information",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "course/about.html#about-the-instructor",
    "href": "course/about.html#about-the-instructor",
    "title": "Advanced Topics in Network Science",
    "section": "5 About the Instructor",
    "text": "5 About the Instructor\n\nSadamori Kojaku\nI am an Assistant Professor in the Department of Systems Science and Industrial Engineering at Binghamton University. My research focuses on computational social science, network science, and machine learning.\nResearch Interests: - Network science and complex systems - Computational social science - Machine learning for networks - Social dynamics and information spread\nBackground: - PhD in Physics, Hokkaido University - Postdoc at Indiana University’s Network Science Institute - Research experience at the University of Tokyo and RIKEN\n\n\nContact Information\n\nEmail: skojaku@binghamton.edu\nOffice: J19 Engineering Building\nWebsite: https://skojaku.github.io\nOffice Hours: Tuesdays & Thursdays 14:30-16:30\nZoom: binghamton.zoom.us/my/skojaku.zoom\n\n\n\nResearch Philosophy\nI believe in learning through doing. Network science is not just about equations and algorithms—it’s about understanding the hidden patterns that connect our world. Whether analyzing social media networks, studying epidemic spread, or designing resilient infrastructure, the goal is to develop intuition alongside technical skills.",
    "crumbs": [
      "Home",
      "Course Information",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "course/about.html#course-links",
    "href": "course/about.html#course-links",
    "title": "Advanced Topics in Network Science",
    "section": "4 Course Links",
    "text": "4 Course Links\n\nCourse Website: skojaku.github.io/adv-net-sci\nGitHub Repository: github.com/skojaku/adv-net-sci\nDiscord: Invitation sent via Brightspace",
    "crumbs": [
      "Home",
      "Course Information",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "course/about.html#important-dates",
    "href": "course/about.html#important-dates",
    "title": "Advanced Topics in Network Science",
    "section": "5 Important Dates",
    "text": "5 Important Dates\n\nProject Proposal: September 29\nFinal Project Paper: December 4\nProject Presentations: December 8\nFinal Exam: December 9-13\n\n\nReady to explore the connected world around us? Let’s dive into the fascinating field of network science!",
    "crumbs": [
      "Home",
      "Course Information",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "course/about.html#about-the",
    "href": "course/about.html#about-the",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "Welcome! My name is Sadamori Kojaku, the instructor of this course. I started my career as a computer scientist but couldn’t resist to fall in love with Network Science right after I got Ph.D. Network Science is about a science on networks, and networks appear in many different forms in our daily lives. The internet, social media, and biological networks, power grid, and you name it. But when we abstract them into a bunch of dots connected by lines, we can compare them and understand them in a unified way. We can study them using the same toolkit no matter what the domain is, and can find universal patterns and principles that govern seemingly different systems. Sounds fun, right 😉?\nThis course will guide you through the fascinating world of networks, from foundational theory to hands-on coding and real-world applications. I hope you will enjoy and find the course useful in your future endeavors.\n\nAbout the Instructor:\nSadamori Kojaku\nInstructor: Sadamori Kojaku\nCourse Hours: Wednesdays 16:40 - 19:40\nLocation: G22 Engineering Building\nCredits: 3\nOffice Hours:\n\nTuesdays & Thursdays 14:30 - 16:30 (J19 Engineering Building)",
    "crumbs": [
      "Home",
      "Course Information",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "course/about.html#about-us",
    "href": "course/about.html#about-us",
    "title": "Advanced Topics in Network Science",
    "section": "1 About us",
    "text": "1 About us\n\nInstructor\n\n\n\nWelcome! My name is Sadamori Kojaku, the instructor of this course. I started my career as a computer scientist but couldn’t resist to fall in love with Network Science right after I got Ph.D. Network Science is about a science on networks, and networks appear in many different forms in our daily lives. The internet, social media, and biological networks, power grid, and you name it. But when we abstract them into a bunch of dots connected by lines, we can compare them and understand them in a unified way. We can study them using the same toolkit no matter what the domain is, and can find universal patterns and principles that govern seemingly different systems. Sounds fun, right 😉?\nThis course will guide you through the fascinating world of networks, from foundational theory to hands-on coding and real-world applications. I hope you will enjoy and find the course useful in your future endeavors.\n\n\n\n\n\n\n\n\nTA\nTeaching Assistant is not yet assigned.\n\n\nAI Tutor (Minidora)\n\n\n\nMinidora is an AI tutor robot conceived in the 22nd century and deployed in the present era to support students. (the original character is designed by Fujiko Fujio for a famous Japanese manga called Doraemon). Minidora supports students in this course by providing dialogic explanations, quiz questions, and coding guidance on the course Discord.",
    "crumbs": [
      "Home",
      "Course Information",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "course/about.html#learning-activities",
    "href": "course/about.html#learning-activities",
    "title": "Advanced Topics in Network Science",
    "section": "2 Learning activities",
    "text": "2 Learning activities\n\nIn class activities\n\nQuiz: Each lecture begins with a short paper‑based quiz reviewing the previous week’s material, graded immediately when possible, followed by a discussion of common mistakes at the end of the lecture.\nPen‑and‑Paper Exercise: Before the lecture, students complete a brief exercise to practice key concepts, then discuss solutions in class while the instructor synthesizes the answers.\nLecture: A recorded lecture covering core network‑science fundamentals is delivered and posted on the course website.\nNetwork of the Week: Weekly, a student or group presents a 10‑minute paper on a network‑related topic of their choice.\nCoding: Each module includes a Python coding exercise (using Marimo notebooks) to apply the concepts to real data.\n\n\n\nHomework\n\nCoding assignment: Every module comes with a coding assignment. The assignment will be distributed via GitHub Classroom. Students will submit their solutions to the assignment via GitHub and get automatic grading.\nLLM Quiz Challenge: Every assignment also includes a task of formulating two quiz questions and correct answers. These quiz questions will be taken by a large language model that learns the course content without seeing the correct answers. The students pass the test if they can generate questions that LLM fails to answer correctly.\n\n\n\nProject\n\nProject Proposal: The students will submit a project proposal on the course content.\nProject Paper: The students will submit a project paper on the course content.\nProject Presentation: The students will present their project.\n\n\n\nExam\nA final exam will be given at the end of the course during the exam period. This exam will be a take-home exam, and will be distributed via Brightspace.",
    "crumbs": [
      "Home",
      "Course Information",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "course/about.html#project",
    "href": "course/about.html#project",
    "title": "Advanced Topics in Network Science",
    "section": "3 Project",
    "text": "3 Project\n\nProject Proposal: The students will submit a project proposal on the course content.\nProject Paper: The students will submit a project paper on the course content.\nProject Presentation: The students will present their project.\n\n\nExam",
    "crumbs": [
      "Home",
      "Course Information",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "course/minidora-usage.html",
    "href": "course/minidora-usage.html",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "Minidora is your personal AI tutor available 24/7 through Discord to help you master network science concepts. She’s designed to provide personalized learning support, answer questions about course materials, and guide you through challenging topics with patience and clarity. To interact with Minidora, simply use Discord slash commands or mention her directly in any channel or thread where she’s present.\nCheck out the instruction here on how to use Minidora: Minidora Usage\n\n\n\nThe most straightforward way to get help is using the /ask command followed by your question. For example, suppose that you want to ask a subject (Euler tour) in module 1.\n\nType /ask then type space.\nType your question (e.g., What is an Euler tour?)\nType space\nYou will be prompted to specify the module id. The id consists of “m”. For example, if it is module 1, you should type m01. Type the module id.\nThen type enter.\n\nMinidora will then read the lecture content and provide an explanation.\n\n\n\nFor a more conversational experience, use the /chat command which allows you to interact with Minidora in a natural, free-flowing manner. You can say things like /chat I'm confused about small-world networks, can you explain them step by step? or /chat Can you help me debug this Python code for computing centrality? Minidora will engage in back-and-forth dialogue, ask clarifying questions, and adapt her explanations based on your responses. This conversational approach is particularly helpful when you need to work through complex problems or want to explore topics in depth.\n\n\n\nTo test your understanding and reinforce learning, Minidora offers intelligent quiz features through the /quiz command. She can generate concept-based questions using /concept-quiz m01 multiple-choice for theoretical understanding, or coding challenges with /code-quiz m01 to practice implementation skills. Minidora tracks your progress and adapts quiz difficulty based on your performance, focusing on areas where you need more practice. You can also request quizzes on specific topics by adding subject keywords, such as /quiz m02 clustering algorithms.\n\n\n\nUse the /status command to monitor your learning journey and see detailed insights about your progress. Minidora provides different status views: /status summary gives you a quick overview of questions asked and concepts mastered, while /status concepts shows which topics you’ve learned and what to study next. The /status profile command reveals your personalized learning profile, including your preferred difficulty level, learning style, and areas where you excel or need additional support. This helps Minidora provide increasingly personalized assistance as you continue learning."
  },
  {
    "objectID": "course/minidora-usage.html#getting-started-with-minidora",
    "href": "course/minidora-usage.html#getting-started-with-minidora",
    "title": "Using Minidora",
    "section": "1 Getting Started with Minidora",
    "text": "1 Getting Started with Minidora\nMinidora is your personal AI tutor available 24/7 through Discord to help you master network science concepts. She’s designed to provide personalized learning support, answer questions about course materials, and guide you through challenging topics with patience and clarity. To interact with Minidora, simply use Discord slash commands or mention her directly in any channel or thread where she’s present.\nCheck out the instruction here on how to use Minidora: Minidora Usage",
    "crumbs": [
      "Home",
      "Course Information",
      "Using Minidora"
    ]
  },
  {
    "objectID": "course/minidora-usage.html#asking-questions-and-getting-help",
    "href": "course/minidora-usage.html#asking-questions-and-getting-help",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "The most straightforward way to get help is using the /ask command followed by your question. For example, suppose that you want to ask a subject (Euler tour) in module 1.\n\nType /ask then type space.\nType your question (e.g., What is an Euler tour?)\nType space\nYou will be prompted to specify the module id. The id consists of “m”. For example, if it is module 1, you should type m01. Type the module id.\nThen type enter.\n\nMinidora will then read the lecture content and provide an explanation."
  },
  {
    "objectID": "course/minidora-usage.html#natural-conversations-and-interactive-learning",
    "href": "course/minidora-usage.html#natural-conversations-and-interactive-learning",
    "title": "Using Minidora",
    "section": "3 Natural Conversations and Interactive Learning",
    "text": "3 Natural Conversations and Interactive Learning\nFor a more conversational experience, use the /chat command which allows you to interact with Minidora in a natural, free-flowing manner. You can say things like /chat I'm confused about small-world networks, can you explain them step by step? or /chat Can you help me debug this Python code for computing centrality? Minidora will engage in back-and-forth dialogue, ask clarifying questions, and adapt her explanations based on your responses.\nNote that /chat does not contextualize the Minidora to the course materials. That means that it does not read the lecture content and interact with the students with its build-in knowledge.",
    "crumbs": [
      "Home",
      "Course Information",
      "Using Minidora"
    ]
  },
  {
    "objectID": "course/minidora-usage.html#quizzes-and-assessment",
    "href": "course/minidora-usage.html#quizzes-and-assessment",
    "title": "Using Minidora",
    "section": "4 Quizzes and Assessment",
    "text": "4 Quizzes and Assessment\nTo test your understanding and reinforce learning, Minidora offers intelligent quiz features through the /quiz command. She can generate concept-based questions using /concept-quiz m01 multiple-choice for theoretical understanding, or coding challenges with /code-quiz m01 to practice implementation skills. Minidora tracks your progress and adapts quiz difficulty based on your performance, focusing on areas where you need more practice. You can also request quizzes on specific topics by adding subject keywords, such as /quiz m02 clustering algorithms.",
    "crumbs": [
      "Home",
      "Course Information",
      "Using Minidora"
    ]
  },
  {
    "objectID": "course/minidora-usage.html#tracking-your-progress",
    "href": "course/minidora-usage.html#tracking-your-progress",
    "title": "Using Minidora",
    "section": "5 Tracking Your Progress",
    "text": "5 Tracking Your Progress\nUse the /status command to monitor your learning journey and see detailed insights about your progress. Minidora provides different status views: /status summary gives you a quick overview of questions asked and concepts mastered, while /status concepts shows which topics you’ve learned and what to study next. The /status profile command reveals your personalized learning profile, including your preferred difficulty level, learning style, and areas where you excel or need additional support. This helps Minidora provide increasingly personalized assistance as you continue learning.",
    "crumbs": [
      "Home",
      "Course Information",
      "Using Minidora"
    ]
  },
  {
    "objectID": "course/minidora-usage.html#asking-questions",
    "href": "course/minidora-usage.html#asking-questions",
    "title": "Using Minidora",
    "section": "2 Asking Questions",
    "text": "2 Asking Questions\nThe most straightforward way to get help is using the /ask command followed by your question. For example, suppose that you want to ask a subject (Euler tour) in module 1.\n\nType /ask then type space.\nType your question (e.g., What is an Euler tour?)\nType space\nYou will be prompted to specify the module id. The id consists of “m”. For example, if it is module 1, you should type m01. Type the module id.\nThen type enter.\n\nMinidora will then read the lecture content and provide an explanation.",
    "crumbs": [
      "Home",
      "Course Information",
      "Using Minidora"
    ]
  },
  {
    "objectID": "m02-small-world/01-concepts.html",
    "href": "m02-small-world/01-concepts.html",
    "title": "Small-World Networks: Core Concepts",
    "section": "",
    "text": "In this module, we will learn small-world experiments and conduct a small small-world experiment . We will learn:\n\nSmall-world experiment by Milgram\nDifferent concepts of distance: path, walks, circuits, cycles, connectedness\nHow to measure a distance between two nodes\nKeywords: small-world experiment, six degrees of separation, path, walks, circuits, cycles, connectedness, connected component, weakly connected component, strongly connected component.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Small-World Networks: Core Concepts"
    ]
  },
  {
    "objectID": "m02-small-world/01-concepts.html#what-to-learn-in-this-module",
    "href": "m02-small-world/01-concepts.html#what-to-learn-in-this-module",
    "title": "Small-World Networks: Core Concepts",
    "section": "",
    "text": "In this module, we will learn small-world experiments and conduct a small small-world experiment . We will learn:\n\nSmall-world experiment by Milgram\nDifferent concepts of distance: path, walks, circuits, cycles, connectedness\nHow to measure a distance between two nodes\nKeywords: small-world experiment, six degrees of separation, path, walks, circuits, cycles, connectedness, connected component, weakly connected component, strongly connected component.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Small-World Networks: Core Concepts"
    ]
  },
  {
    "objectID": "m02-small-world/01-concepts.html#small-world-experiment",
    "href": "m02-small-world/01-concepts.html#small-world-experiment",
    "title": "Small-World Networks: Core Concepts",
    "section": "2 Small-world experiment",
    "text": "2 Small-world experiment\n\n\nStanley Milgram (1933-1984) was an American social psychologist best known for his controversial obedience experiments at Yale University in the early 1960s. Beyond the obedience studies, Milgram conducted groundbreaking research on social networks, including the famous “small world” experiment that revealed the surprisingly short chains connecting any two people in society.\nHow far are two people in a social network? Milgram and his colleagues conducted a series of expriment to find out in the 1960s.\n\n\n\n\n\n\nFigure 1: Milgram’s small world experiment.\n\n\n\nThe experiment went as follows:\n\nMilgram first sent out packets to randomly selected people in Omaha, Nebraska, and Wichita, Kansas.\nThe recipient was asked to send the packet to the target person in Boston if they knew them. If not, they were to forward it to someone they knew on a first-name basis who might know the target.\nThe recipient continued to forward the packet to their acquaintances until it reached the target.\n\nThe results were surprising: out of the 160 letters sent, 64 successfully reached the target person by the chain of nearly six people, which was later called six degrees of separation. The results imply that, despite the fact that there were hundreds of millions of people in the United States, their social network was significantly compact, with two random people being connected to each other in only a few steps.\n\n\nThe term “Six degrees of separation” is commonly associated with Milgram’s experiment, but Milgram never used it. John Guare coined the term for his 1991 play and movie “Six Degrees of Separation.”\nThe results were later confirmed independently.\n\nYahoo research replicate the Milgram’s experiment by using emails. Started from more than 24,000 people, only 384 people reached the one of the 18 target person in 13 countries. Among the successful ones, the average length of the chain was about 4. When taken into account the broken chain, the average length was estimated between 5 and 7. (Goel, Muhamad, and Watts 2009)\nResearchers in Facebook and University of Milan analyzed the social network n Facebook, which consisted of 721 million active users and 69 billion friendships. The average length of the shortest chain was found to be 4.74. (Backstrom et al. 2012)",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Small-World Networks: Core Concepts"
    ]
  },
  {
    "objectID": "m02-small-world/01-concepts.html#wikirace-experiencing-small-world-networks",
    "href": "m02-small-world/01-concepts.html#wikirace-experiencing-small-world-networks",
    "title": "Small-World Networks: Core Concepts",
    "section": "3 Wikirace: Experiencing Small-World Networks",
    "text": "3 Wikirace: Experiencing Small-World Networks\nLet us feel how small a large network can be by playing the Wikirace game.\n\n\n\nAt the end of the module, we will measure the average path length in a social network. Before jumping on, let us arm with some coding techniques to handle the network in the next two sections.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Small-World Networks: Core Concepts"
    ]
  },
  {
    "objectID": "m02-small-world/01-concepts.html#paths-walks-and-network-connectivity",
    "href": "m02-small-world/01-concepts.html#paths-walks-and-network-connectivity",
    "title": "Small-World Networks: Core Concepts",
    "section": "7 Paths, Walks, and Network Connectivity",
    "text": "7 Paths, Walks, and Network Connectivity\nWhile we have already used the term path, let us make clear its definition, together with other related terms and concepts of network connectivity.\nBasic Definitions:\n\nA walk is a sequence of nodes that are connected to form a continous route in a network. For instance, walk (0, 1, 2, 3) is a walk in the graph of the bridges of Konigsberg. But the sequence (0,2,3,1) is not a walk, because the node 0 is not directly connected to node 2.\nA trail is a walk with no repeated edge. For instance, walk (0, 1, 2, 3) is also a trail as it does not cross the same edge twice. But walk (0,2,3,1,3) is not a trail due to the repeated edge (1,3).\nA path is a walk without repeated node. For instance, walk (0,1,2,3) is a path. But walk (0, 1, 2, 1, 2, 3) is not a path due to the repeated node 1 and 2.\nWhen a walk starts and ends at the same node, it is called a **loop*. If the loop is a trail, it is called a circuit. If the loop is a path, it is called a cycle.\n\nQuestion: Is a path always a trail, and is a trail always a path?\n\n\n\n\n\n\nFigure 5: Labeled Knigsberg graph\n\n\n\nShortest Paths:\n\nShortest Path is the path with the smallest number of edges (or nodes) between two nodes. A shortest path from node 0 to 2 is (0, 1, 2). Two nodes can have multiple shortest paths e.g., (0, 3, 2).\nThe shortest path length is the number of edges in the shortest path, not the number of nodes! 👈👈\n\n\n\n\n\n\n\nAre there shortest trails and shortest walks?\n\n\n\nShortest trails and shortest walks are fundamentally equivalent to shortest paths. A shortest trail must visit each node only once (otherwise it would not be the shortest), and similarly, a shortest walk does not repeat nodes (otherwise it would not be the shortest), both forming a shortest path.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Small-World Networks: Core Concepts"
    ]
  },
  {
    "objectID": "m02-small-world/01-concepts.html#network-connectivity",
    "href": "m02-small-world/01-concepts.html#network-connectivity",
    "title": "Small-World Networks: Core Concepts",
    "section": "8 Network Connectivity",
    "text": "8 Network Connectivity\nBasic Connectivity Concepts:\n\nA network is connected if there is a path between every pair of nodes.\nA network is disconnected if there is no path between some pairs of nodes.\nA connected component of a network is a set of nodes that are connected to each other.\nThe giant component of a network is the largest connected component that contains a significant fraction of nodes in the network (in order of the number of nodes).\n\n\n\n\n\n\n\nFigure 6: connected components of a network. the nodes with the same color form a connected component.\n\n\n\nConnectivity in Directed Networks:\nWe call a network is directed if the edges have a direction. Example directed networks include the network of Web pages, the network of friendships on X, the network of citations on academic papers.\nIn a directed network, a walk must follow the edge directions. Paths, trails, and loops extend similarly to directed networks. But one thing to keep in mind: a walk may not be reversible, meaning there can be a walk from one node to another but not vice versa.\nThis leads to two different types of connectedness as follows:\n\nStrong connectedness: A directed network is said to be strongly connected if there is a path from every node to every other node.\nWeak connectedness: A directed network is said to be weakly connected if there is a path from every node to every other node on its undirected counterpart.\n\n\n\n\n\n\n\nFigure 7: connected components of a network. the nodes with the same color form a connected component.\n\n\n\nQuestion: Is a strongly-connected component always a weakly-connected component?\nIn the next section, we will learn how to compute the shortest paths and connected components of a network using a library igraph.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Small-World Networks: Core Concepts"
    ]
  },
  {
    "objectID": "m02-small-world/01-concepts.html#references",
    "href": "m02-small-world/01-concepts.html#references",
    "title": "Small-World Networks: Core Concepts",
    "section": "7 References",
    "text": "7 References\n\n\nBackstrom, Lars, Paolo Boldi, Marco Rosa, Johan Ugander, and Sebastiano Vigna. 2012. “Four Degrees of Separation.” In Proceedings of the 4th Annual ACM Web Science Conference, 33–42.\n\n\nGoel, Sharad, Roby Muhamad, and Duncan Watts. 2009. “Social Search in\" Small-World\" Experiments.” In Proceedings of the 18th International Conference on World Wide Web, 701–10.\n\n\nHumphries, Mark D., and Kevin Gurney. 2008. “Network ‘Small-World-Ness’: A Quantitative Method for Determining Canonical Network Equivalence.” Edited by Olaf Sporns. PLoS ONE 3 (4): e0002051. https://doi.org/10.1371/journal.pone.0002051.\n\n\nNewman, M. E. J., S. H. Strogatz, and D. J. Watts. 2001. “Random graphs with arbitrary degree distributions and their applications.” Physical Review E 64 (2). https://doi.org/10.1103/physreve.64.026118.\n\n\nWatts, Duncan J, and Steven H Strogatz. 1998. “Collective Dynamics of ‘Small-World’networks.” Nature 393 (6684): 440–42.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Small-World Networks: Core Concepts"
    ]
  },
  {
    "objectID": "m02-small-world/01-concepts.html#why-is-small-world-networks-non-trivial",
    "href": "m02-small-world/01-concepts.html#why-is-small-world-networks-non-trivial",
    "title": "Small-World Networks: Core Concepts",
    "section": "4 Why is small-world networks non-trivial?",
    "text": "4 Why is small-world networks non-trivial?\n\n\n\n\nWhen we think about social networks, it’s natural to imagine that most people are friends with others who are nearby—friends of friends, classmates, colleagues, or neighbors. These are local connections, and they tend to form tightly-knit groups where everyone knows each other. In network terms, this means there are many triangles: if Alice is friends with Bob, and Bob is friends with Carol, then Alice is also likely to be friends with Carol.\nHowever, if a network only had these local, clustered connections, it would be difficult for information or influence to travel quickly across the entire network. You would have to go through many intermediaries to reach someone far away, resulting in a large diameter (the longest shortest path between any two nodes).\nWhat makes small-world networks non-trivial and surprising is that, despite having lots of local clustering (many triangles), they also have a few long-range connections—edges that link distant parts of the network. These “shortcuts” dramatically reduce the average distance between nodes. As a result, even in a huge network, you can reach almost anyone in just a few steps. This combination of high clustering and short path lengths is what defines the small-world property.\nIn summary:\n\nLocal connections create clustering (many triangles), but by themselves would make the network “large” in terms of path length.\nSmall-world networks have both high clustering and short average path lengths, thanks to a few edges that connect distant parts of the network.\nThis structure is non-trivial because it cannot be explained by local connections alone; the presence of long-range links is essential for the “small world” phenomenon.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Small-World Networks: Core Concepts"
    ]
  },
  {
    "objectID": "m02-small-world/01-concepts.html#local-clustering-vs.-global-clustering",
    "href": "m02-small-world/01-concepts.html#local-clustering-vs.-global-clustering",
    "title": "Small-World Networks: Core Concepts",
    "section": "5 Local Clustering vs. Global Clustering",
    "text": "5 Local Clustering vs. Global Clustering\n\n\n\n\nLet us approach the small-world properties from mathematical angle. Two key characteristics of small-world networks are:\n\nShort average path length: You can reach distant parts of the network quickly.\nHigh clustering: Friends of friends are often friends.\n\nShort Average Path Length:\n\n\nA path is a walk without repeated nodes. The shortest paths are the paths with the smallest number of edges.\nLet’s understand what average path length means. When we talk about how “far apart” two nodes are in a network, we mean the shortest number of edges you need to traverse to get from one node to the other. This is called the distance between nodes.\n\n\n\n\n\n\n\n\nG\n\n\n\nA\n\nA\n\n\n\nB\n\nB\n\n\n\nA--B\n\n\n\n\nC\n\nC\n\n\n\nA--C\n\n\n\n\nB--C\n\n\n\n\nD\n\nD\n\n\n\nB--D\n\n\n\n\nC--D\n\n\n\n\n\n\n\nFigure 2: Simple network example for understanding shortest paths\n\n\n\n\n\nIn this simple network, let’s find the distance between nodes A and D:\n\nPath 1: A \\rightarrow B \\rightarrow D (2 edges)\nPath 2: A \\rightarrow C \\rightarrow D (2 edges)\nPath 3: A \\rightarrow C \\rightarrow B \\rightarrow D (3 edges)\n\nEven though there are multiple paths, the shortest path length (distance) from A to D is 2 edges.\nStep 3: Calculate All Pairwise Distances\nNow let’s find the distance between every pair of nodes: - A to B: 1 edge (A → B) - A to C: 1 edge (A → C) - A to D: 2 edges (A → B → D or A → C → D) - B to C: 1 edge (B → C) - B to D: 1 edge (B → D) - C to D: 1 edge (C → D)\nStep 4: Calculate Average Path Length\nThe average path length is simply the average of all these distances:\nTotal distances: 1 + 1 + 2 + 1 + 1 + 1 = 7 Number of node pairs: 6 Average path length = 7 ÷ 6 = 1.17\nThis tells us that, on average, any two nodes in this network are about 1.17 edges apart.\nHigh clustering Local Clustering:\nLocal clustering measures how tightly connected a node’s immediate neighbors are to each other. If you have a friend Alice, and Alice has friends Bob and Carol, local clustering asks: “Are Bob and Carol also friends with each other?” High local clustering means that your friends tend to know each other, creating dense local neighborhoods or cliques.\n\nMathematical definition: For a node i, local clustering coefficient C_i is the fraction of possible triangles that actually exist among node i and its neighbors.\nRange: Local clustering coefficients range from 0 (no triangles) to 1 (all possible triangles exist).\nExample: In social networks, high local clustering reflects the fact that people in the same social circles (work, school, neighborhood) tend to know each other.\n\nGlobal Clustering:\nGlobal clustering, also known as transitivity, measures the overall tendency for triangles to form throughout the entire network. It answers the question: “Across the whole network, how likely is it that two nodes connected to a common neighbor are also connected to each other?”\n\nMathematical definition: Global clustering coefficient is the ratio of the number of actual triangles to the number of possible triangles in the network.\nRange: Like local clustering, it ranges from 0 to 1.\nNetwork-wide perspective: Global clustering captures the overall “clumpiness” of connections across the entire network structure.\n\nWhy This Distinction Matters for Small-World Networks:\nThe key insight is that small-world networks exhibit high local clustering (friends of friends are often friends) while maintaining short average path lengths (you can reach distant parts of the network quickly). This combination seems contradictory:\n\nHigh clustering suggests a “clumpy” network where connections are mostly local, which should make distant nodes hard to reach.\nShort path lengths suggest efficient global connectivity, which typically requires more random, long-range connections.\n\nSmall-world networks resolve this apparent contradiction through a clever structure: they maintain dense local clusters while having just enough long-range “shortcut” connections to dramatically reduce distances. This is what makes them both highly clustered locally and globally efficient for information flow.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Small-World Networks: Core Concepts"
    ]
  },
  {
    "objectID": "m02-small-world/01-concepts.html#quantifying-small-world-properties",
    "href": "m02-small-world/01-concepts.html#quantifying-small-world-properties",
    "title": "Small-World Networks: Core Concepts",
    "section": "5 Quantifying Small-World Properties",
    "text": "5 Quantifying Small-World Properties\n\n\n\n\nLet us approach the small-world properties from mathematical angle. Two key characteristics of small-world networks are:\n\nShort average path length: You can reach distant parts of the network quickly.\nHigh clustering: Friends of friends are often friends.\n\n\nShort Average Path Length\n\n\nA path is a walk without repeated nodes. The shortest paths are the paths with the smallest number of edges.\nLet’s understand what average path length means. When we talk about how “far apart” two nodes are in a network, we mean the shortest number of edges you need to traverse to get from one node to the other. This is called the distance between nodes.\n\n\n\n\n\n\n\n\nG\n\n\n\nA\n\nA\n\n\n\nB\n\nB\n\n\n\nA--B\n\n\n\n\nC\n\nC\n\n\n\nA--C\n\n\n\n\nB--C\n\n\n\n\nD\n\nD\n\n\n\nB--D\n\n\n\n\nC--D\n\n\n\n\n\n\n\nFigure 2: Simple network example for understanding shortest paths\n\n\n\n\n\nIn this simple network, let’s find the distance between nodes A and D:\n\nPath 1: A \\rightarrow B \\rightarrow D (2 edges)\nPath 2: A \\rightarrow C \\rightarrow D (2 edges)\nPath 3: A \\rightarrow C \\rightarrow B \\rightarrow D (3 edges)\n\nEven though there are multiple paths, the shortest path length (distance) from A to D is 2 edges.\nBuilding on this, let us calculate the average path length between two nodes. We have four nodes in the network, so there are 6 pairs of nodes. Let us enumerate them as follows:\n\n\n\n\n\n\n\n\nPair\nShortest Path\nLength\n\n\n\n\nA - B\nA \\rightarrow B\n1\n\n\nA - C\nA \\rightarrow C\n1\n\n\nA - D\nA \\rightarrow B \\rightarrow D or A \\rightarrow C \\rightarrow D\n2\n\n\nB - C\nB \\rightarrow C\n1\n\n\nB - D\nB \\rightarrow D\n1\n\n\nC - D\nC \\rightarrow D\n1\n\n\n\nThe average path length is simply the average of all these distances, which is 7 / 6 \\simeq 1.16.\n\n\nClustering Coefficient\nIn social networks, your friends tend to know each other. If you have a friend Alice, and Alice has friends Bob and Carol, local clustering asks: “Are Bob and Carol also friends with each other?” High local clustering means that your friends tend to know each other, creating dense local neighborhoods or cliques.\nThere are three ways to measure clustering: local clustering, average local clustering, and global clustering. The key difference is the focus of the measurement:\n\nLocal clustering focuses on the clustering of the neighbors of a specific node\nAverage local clustering focuses on the clustering of the neighbors of a node\nGlobal clustering focuses on the clustering of the entire network.\n\nLet us explain each of them one by one.\n\nLocal Clustering\nLocal clustering asks: given all your friends, how many of triangles you and your friends form, relative to the maximum possible number of triangles?\nThe local clustering coefficient C_i of a node i is defined as:\n\nC_i = \\dfrac{\\text{\\# of triangles involving } i \\text{ and its neighbors}}{\\text{\\# of edges possibly exist in the neighborhood of } i}\n\nOr alternatively, using the adjacency matrix A and the degree k_i of node i, \n\\begin{aligned}\nC_i = \\frac{\\sum_{j}\\sum_{\\ell} A_{ij}A_{j\\ell} A_{\\ell i} }{k_i(k_i-1)}\n\\end{aligned}\n\n\n\n\n\n\n\nNote: Derivation of the local clustering coefficient\n\n\n\n\n\nNumerator A_{ij}A_{j\\ell} A_{\\ell i} is a binary indicator of whether three nodes i, j, and \\ell form a triangle; A_{ij}A_{j\\ell} A_{\\ell i}=1 if a cycle i \\rightarrow j \\rightarrow \\ell \\rightarrow i exists, and 0 otherwise. By summing up all nodes, we have the number of triangles in the neighbors of i given by \\sum_{j}\\sum_{\\ell} A_{ij}A_{j\\ell} A_{\\ell i} / 2. Note that we divide the sum by 2 because the same triangle forms two cycles, i.g., i \\rightarrow j \\rightarrow \\ell \\rightarrow i and i \\rightarrow \\ell \\rightarrow j \\rightarrow i.\nThe number of possible triangles in the neighborhood of i is given by \\binom{k_i}{2} = k_i(k_i-1)/2.\nPutting them together:\n\nC_i = \\frac{\\sum_{j}\\sum_{\\ell} A_{ij}A_{j\\ell} A_{\\ell i} }{k_i(k_i-1)}\n\n\n\n\nFor example, let us compute the local clustering coefficient of node A in the following network. There are two triangles in the neighborhood of A. The number of possible triangles is 5 \\times 4 / 2 = 10. Thus, the local clustering coefficient of A is 2 / 10 = 0.2.\n\n\n\n\n\n\n\n\nG\n\n\n\nA\n\nA\n\n\n\nB\n\nB\n\n\n\nA--B\n\n\n\n\nC\n\nC\n\n\n\nA--C\n\n\n\n\nD\n\nD\n\n\n\nA--D\n\n\n\n\nE\n\nE\n\n\n\nA--E\n\n\n\n\nF\n\nF\n\n\n\nA--F\n\n\n\n\nB--F\n\n\n\n\nC--E\n\n\n\n\n\n\n\nFigure 3: A network of friends\n\n\n\n\n\n\n\nAverage Local Clustering\nLocal clustering focuses on the clustering of a node’s neighborhood, while the global clustering focuses on the clustering of the entire network. One can adapt the local clustering for measuring the global clustering by taking the average of the local clustering coefficients of all nodes, i.e.,\n\n\\overline {C} = \\frac{1}{N} \\sum_{i=1}^N C_i\n\n\n\nGlobal Clustering\nGlobal clustering, also known as transitivity, measures the overall tendency for triangles to form throughout the entire network. It answers the question: “Across the whole network, how likely is it that two nodes connected to a common neighbor are also connected to each other?”\nThe global clustering coefficient C is defined as:\n\nC = \\frac{3 \\times \\text{number of triangles}}{\\text{number of connected triplets}}\n\nwhere a connected triplet is a set of three nodes connected by at least two edges, forming either a closed triplet (triangle) or an open triplet (wedge) shown below.\n\n\n\n\n\n\n\nG\n\n\n\nA1\n\nA1\n\n\n\nB1\n\nB1\n\n\n\nA1--B1\n\n\n\n\nC1\n\nC1\n\n\n\nB1--C1\n\n\n\n\nC1--A1\n\n\n\n\nA2\n\nA2\n\n\n\nB2\n\nB2\n\n\n\nA2--B2\n\n\n\n\nC2\n\nC2\n\n\n\nB2--C2\n\n\n\n\n\n Closed triplet (left) and open triplet (right) \n\n\n\nIn triplets, the order of the nodes matters. For example, (A_1, B_1, C_1) and (B_1, C_1, A_1) are two different triplets. A triangle pertains to three triplets, i.e., (A_1, B_1, C_1), (B_1, C_1, A_1), and (C_1, A_1, B_1). This is why we multiple three to the number of triangles in the numerator.\n\n\n\n\n\n\nKey difference between average local and global clustering\n\n\n\n\n\nIt is confusing to have two different global clustering measures, but the distinction becomes clearer if we think in terms of micro and macro perspectives:\n\nThe global clustering coefficient C (based on the total number of triangles and triplets in the network) is a micro-level measure. It looks at the prevalence of triangles relative to all possible connected triples in the entire network, essentially aggregating over all small, local patterns (triplets) to get a sense of how likely it is for any three connected nodes to form a closed triangle.\nThe average local clustering coefficient \\overline{C} is a macro-level measure. It first computes the clustering coefficient for each individual node (how clustered each node’s neighborhood is), and then averages these values across all nodes. This gives a sense of the overall tendency for nodes in the network to have tightly knit neighborhoods.\n\nSo the focal scope remains the same: the average local clustering focuses on a node’s neighborhood, while the global clustering focuses on the entire network.\n\n\n\n\n\n\nSmall-world coefficient\nNow let’s define a coefficient to measure the small-world property. Recall that a small-world network has both high clustering and short average path length. A naive approach is to take the ratio between the average local clustering coefficient and the average path length:\n\ns_{\\text{naive}} = \\frac{\\overline{C}}{\\overline{L}}\n\nwhere \\overline{C} is a clustering coefficient and \\overline{L} is the average path length. The original work by Watts and Strogatz used the average local clustering coefficient (Watts and Strogatz 1998) but one can use the global clustering coefficient as well, which leads to different results (Humphries and Gurney 2008).\nA high s_{\\text{naive}} value would seem to indicate a strong small-world property. However, this naive measure has a critical flaw: it can be high for trivial network structures. For example, a fully-connected network has \\overline{L} = 1 (minimum possible) and \\overline{C} = 1 (maximum possible), giving s_{\\text{naive}} = 1. This leads us to normalize against random networks with the same basic properties (Humphries and Gurney 2008).\nTo address this issue, Watts and Strogatz proposed normalizing by equivalent random networks. The small-world index (or small-world coefficient) is defined as:\n\n\\sigma = \\frac{\\overline{C}/\\overline{C}_{\\text{random}}}{\\overline{L}/\\overline{L}_{\\text{random}}} = \\frac{\\overline{C} \\cdot \\overline{L}_{\\text{random}}}{\\overline{L} \\cdot \\overline{C}_{\\text{random}}}\n\nwhere: \\overline{C}_{\\text{random}} and \\overline{L}_{\\text{random}} are the average clustering coefficient and the average path length of an equivalent random network. The “equivalent random network” typically refers to an Erdős–Rényi random graph, where edges are randomly connected with the same number of nodes and edges (or same average degree) as the original network (thus it represents a trivial random network of the same number of nodes and edges).\nA high \\sigma value greater than 1 indicates a strong small-world property. If \\sigma is close to 1, the network is not small-world but comparable to a random network in terms of the small-world property. If \\sigma is less than 1, the network is anti-small-world, i.e., it has a large average path length and low clustering compared to a random counterpart.\nSo how do we compute the reference value of \\overline{C}_{\\text{random}} and \\overline{L}_{\\text{random}}? We can compute them numerically by generating many random networks and computing the average of the clustering coefficient and the path length. For Erdős–Rényi random graph, it has been shown that the reference value of \\overline{C}_{\\text{random}} and \\overline{L}_{\\text{random}} follow on average (Humphries and Gurney 2008) (Newman, Strogatz, and Watts 2001): \n\\begin{aligned}\n\\overline{C}_{\\text{random}} & \\approx \\frac{\\langle k \\rangle}{n-1} \\\\\n\\overline{L}_{\\text{random}} &\\approx \\frac{\\ln n }{\\ln \\langle k \\rangle}\n\\end{aligned}\n\nwhere \\langle k \\rangle is the average degree of the network, and n is the number of nodes.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Small-World Networks: Core Concepts"
    ]
  },
  {
    "objectID": "m02-small-world/01-concepts.html#watts-strogatz-model",
    "href": "m02-small-world/01-concepts.html#watts-strogatz-model",
    "title": "Small-World Networks: Core Concepts",
    "section": "6 Watts-Strogatz Model",
    "text": "6 Watts-Strogatz Model\n\n\n\n\n\n\nFigure 4: Watts-Strogatz model.\n\n\n\nWe have a way to measure the small-world property of a network, which reveals that the small-world property is surprisingly common in real-world networks. This leads to a question: what is the underlying mechanism? The Watts-Strogatz model provides a way to generate small-world networks, as we will see in the next section.\n\n\nHere is a nice blog post about the Watts-Strogatz model.\n\n\n“What I cannot create, I do not understand.” - Richard Feynman\n\nThis quote captures the essence of why models like Watts-Strogatz are crucial: by building networks that exhibit small-world properties, we gain deeper insight into how these properties emerge in real systems.\n\n\nWhat is the Watts-Strogatz Model?\nThe Watts-Strogatz model provides one explanation for the small-world phenomenon. The Watts-Strogatz model starts with a ring lattice and introduces randomness through edge rewiring:\nStep 1: Start with a Ring Lattice\n\nCreate a ring of N nodes\nConnect each node to its k nearest neighbors (k/2 on each side)\nThis gives high clustering but long average path length\n\nStep 2: Rewire Edges with Probability p\n\nFor each edge in the lattice:\n\nWith probability p: remove the edge and reconnect one endpoint to a randomly chosen node\nWith probability (1-p): keep the original edge\n\nAvoid self-loops and duplicate edges\n\nAt p = 0, the network is a regular ring lattice (high clustering, long paths); at p = 1, it becomes a random graph (low clustering, short paths). For 0 &lt; p &lt; 1, the network combines high clustering with short path lengths—the hallmark of the small-world property.\n\n\n\n\n\n\ninteractive exploration\n\n\n\nHere is the interactive visualization of the Watts-Strogatz model 😎: .\n\n\n\n\nWhy does the small-world property emerge?\nThe Watts-Strogatz model explains that the small-world property emerges from a small number of long-range connections that connect distant parts of the network, despite the nodes being connected to their local neighbors. While we have focused on social networks, the same explanation applies to different domains, such as biological networks (e.g., neurons are primarily connected locally but have some long-range connections that enable rapid information transmission), and technological networks (e.g., the Internet topology is regional but has some long-range connections that span continents).\n\n\nInteractive Exploration\n\n\nExplore the Watts-Strogatz model interactively by adjusting the rewiring probability and observing how network properties change:\nIn the next section, we will learn how to compute the shortest paths and connected components of a network using a library igraph.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Small-World Networks: Core Concepts"
    ]
  },
  {
    "objectID": "m02-small-world/01-concepts.html#watts-strogatz-model-1",
    "href": "m02-small-world/01-concepts.html#watts-strogatz-model-1",
    "title": "Small-World Networks: Core Concepts",
    "section": "7 Watts-Strogatz Model",
    "text": "7 Watts-Strogatz Model\n\n\n\n\n\n\nFigure 5: Watts-Strogatz model.\n\n\n\n\n\nHere is a nice blog post about the Watts-Strogatz model: https://chih-ling-hsu.github.io/2020/05/15/watts-strogatz.\n\n\n“What I cannot create, I do not understand.” - Richard Feynman\n\nThis quote captures the essence of why models like Watts-Strogatz are crucial: by building networks that exhibit small-world properties, we gain deeper insight into how these properties emerge in real systems.\n\nThe Watts-Strogatz model provides a elegant way to generate networks that interpolate between regular lattices (high clustering, long paths) and random graphs (low clustering, short paths), capturing the small-world phenomenon.\n\nThe Algorithm\nThe Watts-Strogatz model starts with a ring lattice and introduces randomness through edge rewiring:\nStep 1: Start with a Ring Lattice - Create a ring of N nodes - Connect each node to its k nearest neighbors (k/2 on each side) - This gives high clustering but long average path length\nStep 2: Rewire Edges with Probability p - For each edge in the lattice: - With probability p: remove the edge and reconnect one endpoint to a randomly chosen node - With probability (1-p): keep the original edge - Avoid self-loops and duplicate edges\nStep 3: Resulting Network Properties - p = 0: Regular ring lattice (high clustering, long paths) - p = 1: Random graph (low clustering, short paths) - 0 &lt; p &lt; 1: Small-world network (high clustering, short paths)\nquarto-executable-code-5450563D\n//| fig-width: 6\n//| fig-height: 2.5\n//| fig-cap: \"Watts-Strogatz model progression from regular lattice to random graph\"\n//| fig-align: center\ngraph G {\n  layout=neato;\n  fontsize=14;\n\n  subgraph cluster_0 {\n    label=\"p = 0 (Regular Lattice)\";\n    fontsize=12;\n    style=filled;\n    color=lightgrey;\n\n    A1 [pos=\"-4,0!\" shape=circle];\n    B1 [pos=\"-3.5,0.8!\" shape=circle];\n    C1 [pos=\"-2.8,0.8!\" shape=circle];\n    D1 [pos=\"-2.3,0!\" shape=circle];\n    E1 [pos=\"-2.8,-0.8!\" shape=circle];\n    F1 [pos=\"-3.5,-0.8!\" shape=circle];\n\n    A1 -- B1; B1 -- C1; C1 -- D1; D1 -- E1; E1 -- F1; F1 -- A1;\n    A1 -- C1; B1 -- D1; C1 -- E1; D1 -- F1; E1 -- A1; F1 -- B1;\n  }\n\n  subgraph cluster_1 {\n    label=\"0 &lt; p &lt; 1 (Small World)\";\n    fontsize=12;\n    style=filled;\n    color=lightgrey;\n\n    A2 [pos=\"0,0!\" shape=circle];\n    B2 [pos=\"0.5,0.8!\" shape=circle];\n    C2 [pos=\"1.2,0.8!\" shape=circle];\n    D2 [pos=\"1.7,0!\" shape=circle];\n    E2 [pos=\"1.2,-0.8!\" shape=circle];\n    F2 [pos=\"0.5,-0.8!\" shape=circle];\n\n    A2 -- B2; B2 -- C2; C2 -- D2; D2 -- E2; E2 -- F2; F2 -- A2;\n    A2 -- C2; B2 -- D2; E2 -- A2; F2 -- B2;\n    C2 -- F2 [color=red, penwidth=2]; // rewired edge\n    D2 -- A2 [color=red, penwidth=2]; // rewired edge\n  }\n\n  subgraph cluster_2 {\n    label=\"p = 1 (Random Graph)\";\n    fontsize=12;\n    style=filled;\n    color=lightgrey;\n\n    A3 [pos=\"4,0!\" shape=circle];\n    B3 [pos=\"4.5,0.8!\" shape=circle];\n    C3 [pos=\"5.2,0.8!\" shape=circle];\n    D3 [pos=\"5.7,0!\" shape=circle];\n    E3 [pos=\"5.2,-0.8!\" shape=circle];\n    F3 [pos=\"4.5,-0.8!\" shape=circle];\n\n    A3 -- D3; B3 -- E3; C3 -- F3; D3 -- B3; E3 -- C3; F3 -- A3;\n    A3 -- B3; C3 -- D3; E3 -- F3; A3 -- E3; B3 -- F3; C3 -- A3;\n  }\n}\n\n\nKey Insights\nThe Magic of Small p Values: Even a small rewiring probability (p \\approx 0.01) dramatically reduces average path length while maintaining high clustering. This happens because:\n\nClustering preservation: Most edges remain local (probability 1-p), maintaining triangular relationships\nShortcut creation: A few random edges (probability p) act as “shortcuts” across the network\nDiameter collapse: These shortcuts reduce the network diameter from O(N) to O(\\log N)\n\nMathematical Properties: - Clustering coefficient: C(p) \\approx C(0) \\cdot (1-p)^3 for small p - Average path length: L(p) drops rapidly even for small p - Small-world regime: Optimal \\sigma typically occurs around p \\approx 0.01 to 0.1\n\n\nBiological and Social Relevance\nThe Watts-Strogatz model captures essential features of real networks:\nNeural networks: Neurons are primarily connected locally (clustering) but have some long-range connections (shortcuts) that enable rapid information transmission.\nSocial networks: People have local social groups (high clustering) but occasional distant connections (through travel, online interaction) that reduce social distances.\nInternet topology: Routers are connected regionally for efficiency but have backbone connections that span continents.\nThe model’s success lies in showing that small-world properties emerge naturally from the tension between local organization and random connectivity - a fundamental principle observed across many natural and social systems.\n\n\nInteractive Exploration\nExplore the Watts-Strogatz model interactively by adjusting the rewiring probability and observing how network properties change:\nimport marimo as mo\nimport networkx as nx\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.collections import LineCollection\n\n# Create the rewiring probability slider\np_slider = mo.ui.slider(\n    start=0.0,\n    stop=1.0,\n    step=0.01,\n    value=0.1,\n    show_value=True,\n    label=\"Rewiring Probability (p)\"\n)\n\n# Display the slider\nmo.md(f\"**Control the rewiring probability:** {p_slider}\")\ndef watts_strogatz_with_metrics(N=20, k=4, p=0.1):\n    \"\"\"Generate Watts-Strogatz network and compute metrics\"\"\"\n    # Generate the network\n    G = nx.watts_strogatz_graph(N, k, p, seed=42)\n\n    # Generate random network for comparison (same N, M)\n    num_edges = G.number_of_edges()\n    G_random = nx.erdos_renyi_graph(N, num_edges / (N * (N-1) / 2), seed=42)\n\n    # Compute metrics for original network\n    try:\n        C = nx.average_clustering(G)\n        L = nx.average_shortest_path_length(G)\n    except:\n        C = 0\n        L = float('inf')\n\n    # Compute metrics for random network\n    try:\n        C_random = nx.average_clustering(G_random)\n        L_random = nx.average_shortest_path_length(G_random)\n    except:\n        C_random = 0.001  # Small value to avoid division by zero\n        L_random = 1\n\n    # Compute small-world coefficient\n    if C_random &gt; 0 and L_random &gt; 0:\n        sigma = (C / C_random) / (L / L_random)\n    else:\n        sigma = 0\n\n    return G, C, L, C_random, L_random, sigma\n\ndef plot_network_and_metrics(p_value):\n    \"\"\"Create network visualization and metrics plots\"\"\"\n    G, C, L, C_random, L_random, sigma = watts_strogatz_with_metrics(N=20, k=4, p=p_value)\n\n    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(12, 10))\n\n    # Plot 1: Network visualization\n    pos = {}\n    N = len(G.nodes())\n    for i, node in enumerate(G.nodes()):\n        angle = 2 * np.pi * i / N\n        pos[node] = (np.cos(angle), np.sin(angle))\n\n    # Draw edges\n    edge_colors = []\n    for edge in G.edges():\n        # Check if this edge would exist in a regular ring lattice\n        i, j = edge\n        ring_distance = min(abs(i-j), N-abs(i-j))\n        if ring_distance &lt;= 2:  # k=4 means connect to 2 neighbors on each side\n            edge_colors.append('blue')  # Original edge\n        else:\n            edge_colors.append('red')   # Rewired edge\n\n    nx.draw_networkx_edges(G, pos, ax=ax1, edge_color=edge_colors, alpha=0.6, width=1.5)\n    nx.draw_networkx_nodes(G, pos, ax=ax1, node_color='lightblue',\n                          node_size=300, edgecolors='black')\n    nx.draw_networkx_labels(G, pos, ax=ax1, font_size=8)\n\n    ax1.set_title(f'Watts-Strogatz Network (p = {p_value:.3f})')\n    ax1.set_aspect('equal')\n    ax1.axis('off')\n\n    # Add legend\n    blue_patch = patches.Patch(color='blue', label='Original edges')\n    red_patch = patches.Patch(color='red', label='Rewired edges')\n    ax1.legend(handles=[blue_patch, red_patch], loc='upper right')\n\n    # Plot 2: Clustering coefficient comparison\n    ax2.bar(['Network', 'Random'], [C, C_random],\n            color=['skyblue', 'lightcoral'], alpha=0.7)\n    ax2.set_ylabel('Clustering Coefficient')\n    ax2.set_title('Clustering Coefficient Comparison')\n    ax2.set_ylim(0, max(C, C_random) * 1.2 if max(C, C_random) &gt; 0 else 1)\n\n    # Add value labels\n    ax2.text(0, C + 0.01, f'{C:.3f}', ha='center', va='bottom')\n    ax2.text(1, C_random + 0.01, f'{C_random:.3f}', ha='center', va='bottom')\n\n    # Plot 3: Average path length comparison\n    if L != float('inf'):\n        ax3.bar(['Network', 'Random'], [L, L_random],\n                color=['skyblue', 'lightcoral'], alpha=0.7)\n        ax3.text(0, L + 0.05, f'{L:.3f}', ha='center', va='bottom')\n        ax3.text(1, L_random + 0.05, f'{L_random:.3f}', ha='center', va='bottom')\n        ax3.set_ylim(0, max(L, L_random) * 1.2)\n    else:\n        ax3.bar(['Network', 'Random'], [10, L_random],\n                color=['skyblue', 'lightcoral'], alpha=0.7)\n        ax3.text(0, 10.5, '∞', ha='center', va='bottom')\n        ax3.text(1, L_random + 0.05, f'{L_random:.3f}', ha='center', va='bottom')\n\n    ax3.set_ylabel('Average Path Length')\n    ax3.set_title('Average Path Length Comparison')\n\n    # Plot 4: Small-world coefficient\n    ax4.bar(['σ (Small-world coefficient)'], [sigma], color='gold', alpha=0.7)\n    ax4.axhline(y=1, color='red', linestyle='--', alpha=0.7, label='σ = 1 (Random)')\n    ax4.set_ylabel('Small-world Coefficient (σ)')\n    ax4.set_title('Small-world Property')\n    ax4.text(0, sigma + 0.1, f'{sigma:.2f}', ha='center', va='bottom', fontweight='bold')\n\n    # Interpretation text\n    if sigma &gt; 1:\n        interpretation = \"Strong small-world\"\n        color = 'green'\n    elif sigma &gt; 0.5:\n        interpretation = \"Moderate small-world\"\n        color = 'orange'\n    else:\n        interpretation = \"Random-like\"\n        color = 'red'\n\n    ax4.text(0, max(sigma * 0.8, 0.5), interpretation, ha='center', va='center',\n             bbox=dict(boxstyle='round', facecolor=color, alpha=0.3))\n\n    ax4.legend()\n    ax4.set_ylim(0, max(sigma * 1.3, 2))\n\n    plt.tight_layout()\n    return fig\n\n# Generate the plot based on slider value\ncurrent_fig = plot_network_and_metrics(p_slider.value)\nmo.mpl.interactive(current_fig)\nmo.md(f\"\"\"\n### Key Observations\n\n- **Network Structure**: Blue edges represent original ring lattice connections, red edges show rewired shortcuts\n- **Clustering**: Measures local triangle density - starts high and decreases with rewiring\n- **Path Length**: Average shortest path between nodes - drops rapidly even with small p values\n- **Small-world Coefficient (σ)**: When σ &gt; 1, the network exhibits small-world properties\n\n**Current values**: C = {watts_strogatz_with_metrics(N=20, k=4, p=p_slider.value)[1]:.3f},\nL = {watts_strogatz_with_metrics(N=20, k=4, p=p_slider.value)[2]:.3f},\nσ = {watts_strogatz_with_metrics(N=20, k=4, p=p_slider.value)[5]:.2f}\n\nTry different values of p and observe how even small amounts of rewiring (p ≈ 0.01-0.1) can create the small-world effect!\n\"\"\")\n\n\n\n\n\n## Paths, Walks, and Network Connectivity\n\nWhile we have already used the term **path**, let us make clear its definition, together with other related terms and concepts of network connectivity.\n\n**Basic Definitions:**\n\n- A **walk** is a sequence of nodes that are connected to form a continous route in a network. For instance, walk (0, 1, 2, 3) is a walk in the graph of the bridges of Konigsberg. But the sequence (0,2,3,1) is not a walk, because the node 0 is not directly connected to node 2.\n\n- A **trail** is a walk with no repeated edge. For instance, walk (0, 1, 2, 3) is also a trail as it does not cross the same edge twice. But walk (0,2,3,1,3) is not a trail due to the repeated edge (1,3).\n\n- A **path** is a walk without repeated node. For instance, walk (0,1,2,3) is a path. But walk (0, 1, 2, 1, 2, 3) is not a path due to the repeated node 1 and 2.\n\n- When a walk starts and ends at the same node, it is called a **loop*. If the loop is a trail, it is called a **circuit**. If the loop is a path, it is called a **cycle**.\n\n***Question***: Is a path always a trail, and is a trail always a path?\n\n::: {#fig-numbered-koningsberg-graph2}\n\n&lt;img src= \"../figs/labeled-koningsberg.jpg\" width=\"30%\"&gt;\n\nLabeled Knigsberg graph\n\n:::\n\n**Shortest Paths:**\n\n- **Shortest Path** is the path with the smallest number of edges (or nodes) between two nodes. A shortest path from node 0 to 2 is (0, 1, 2). Two nodes can have multiple shortest paths e.g., (0, 3, 2).\n- **The shortest path length** is the number of edges in the shortest path, *not the number of nodes!* 👈👈\n\n::: {.callout-note}\n## Are there **shortest trails** and **shortest walks**?\nShortest trails and shortest walks are fundamentally equivalent to shortest paths. A shortest trail must visit each node only once (otherwise it would not be the shortest), and similarly, a shortest walk does not repeat nodes (otherwise it would not be the shortest), both forming a shortest path.\n:::\n\n## Network Connectivity\n\n**Basic Connectivity Concepts:**\n\n- A network is **connected** if there is a path between every pair of nodes.\n- A network is **disconnected** if there is no path between some pairs of nodes.\n- **A connected component** of a network is a set of nodes that are connected to each other.\n- **The giant component** of a network is the largest connected component that contains a significant fraction of nodes in the network (in order of the number of nodes).\n\n::: {#fig-connected-components}\n\n&lt;img src= \"../figs/connected-component.jpg\" width=\"50%\"&gt;\n\nconnected components of a network. the nodes with the same color form a connected component.\n\n:::\n\n**Connectivity in Directed Networks:**\n\nWe call a network is *directed* if the edges have a direction. Example directed networks include the network of Web pages, the network of friendships on X, the network of citations on academic papers.\n\nIn a directed network, a walk must follow the edge directions. Paths, trails, and loops extend similarly to directed networks. But one thing to keep in mind: a walk may not be reversible, meaning there can be a walk from one node to another but not vice versa.\n\nThis leads to two different types of `connectedness` as follows:\n\n- **Strong connectedness**: A directed network is said to be strongly connected if there is a path from every node to every other node.\n- **Weak connectedness**: A directed network is said to be weakly connected if there is a path from every node to every other node on its *undirected* counterpart.\n\n::: {#fig-connected-components-directed}\n\n&lt;img src= \"../figs/connected-component-directed.jpg\" width=\"50%\"&gt;\n\nconnected components of a network. the nodes with the same color form a connected component.\n\n:::\n\n**Question**: Is a strongly-connected component always a weakly-connected component?\n\nIn the next section, we will learn how to compute the shortest paths and connected components of a network using a library [igraph](https://python.igraph.org/en/stable/).\n\n## References\n\n::: {#refs}\n:::\n:::",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Small-World Networks: Core Concepts"
    ]
  }
]