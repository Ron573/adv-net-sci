[
  {
    "objectID": "m02-small-world/00-preparation.html",
    "href": "m02-small-world/00-preparation.html",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "Before studying small-world networks, you should understand these concepts from the Euler Tour module: - Basic graph representations (adjacency matrix, edge lists) - Node degree calculations - Graph connectivity fundamentals\n\n\n\nSmall-world networks are fundamentally about distances between nodes. You’ll need to understand:\n\n\nThe shortest path distance between two nodes is the minimum number of edges in any path connecting them.\nimport networkx as nx\n\n# Calculate shortest path distances\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 3), (3, 4), (1, 4)])\ndistance = nx.shortest_path_length(G, 1, 3)  # Returns 2\n\n\n\nFor network analysis, we often compute the average shortest path length across all pairs of nodes:\n\\langle d \\rangle = \\frac{1}{N(N-1)} \\sum_{i \\neq j} d_{ij}\nwhere d_{ij} is the shortest path distance between nodes i and j.\n\n\n\n\n\n\nThe clustering coefficient measures how densely connected a node’s neighbors are:\nC_i = \\frac{2E_i}{k_i(k_i-1)}\nwhere E_i is the number of edges between neighbors of node i, and k_i is the degree of node i.\n\n\n\nThe average clustering coefficient across all nodes provides a measure of local connectivity.\n\n\n\n\n\n\nYou’ll need basic understanding of: - Random variables and their distributions - Expected values and variance - Comparing observed vs. expected values\n\n\n\nUnderstanding of random graphs where edges are placed randomly with some probability will help contextualize small-world properties.\n\n\n\n\n\n\nBasic understanding of computational complexity (O(n), O(n²)) for evaluating network analysis algorithms.\n\n\n\nFamiliarity with: - Lists and dictionaries for graph representations - Efficient storage and retrieval of network data\nThese foundations will help you understand how small-world networks achieve the remarkable property of short average distances despite high local clustering.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "m02-small-world/00-preparation.html#required-knowledge-from-module-1",
    "href": "m02-small-world/00-preparation.html#required-knowledge-from-module-1",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "Before studying small-world networks, you should understand these concepts from the Euler Tour module: - Basic graph representations (adjacency matrix, edge lists) - Node degree calculations - Graph connectivity fundamentals",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "intro/setup.html",
    "href": "intro/setup.html",
    "title": "Setup",
    "section": "",
    "text": "We’ll use Python to work with data throughout this course. Python is an excellent choice for network science for its rich ecosystem of libraries, readable and intuitive syntax, and well-documented documentation.\nWe strongly recommend using virtual environments to manage your Python packages. Virtual environments create isolated Python installations for each project, avoiding dependency hell and providing several key benefits:\n\n\nDon’t confuse Python virtual environments with virtual machines (VMs). Python virtual environments are lightweight isolation tools that only separate Python packages and dependencies within the same operating system. Virtual machines, on the other hand, create complete isolated operating systems.\n\nReproducibility: Your code will work consistently across different machines and over time\nFlexibility: You can use different versions of packages for different projects without conflicts\nPrevent project interference: Changes to one project won’t break another project’s dependencies\n\n\n\n\n\n\n\nFigure 1: Without virtual environments, you risk dependency hell where package conflicts make your projects unusable.\n\n\n\nWe recommend using mamba and uv. Mamba is a tool for quickly installing Python and other packages, and for creating isolated environments for your projects. uv is a fast Python package and project manager. While we won’t be running uv commands directly in this course, you’ll need uv to properly run Marimo notebooks, which provides a much better development experience. See here for installation instructions.\nFollow the following steps to install mamba, uv, along with the minimum Python packages required for this course.\n\n[Install mamba] (https://github.com/conda-forge/miniforge)\nRun the following command to create a new environment with the minimum Python packages required for this course.\n\nmamba create -n advnetsci python==3.11 matplotlib scipy numpy pandas seaborn uv\n\nActivate the environment.\n\nmamba activate advnetsci\n\nPip install marimo.\n\npip install marimo\n\n\n\n\n\n\nIf you prefer tools other than uv, here are some alternatives:\n\nvenv: The standard library for creating virtual environments;\npyenv: Great for managing multiple Python versions;\nConda: Popular in data science, includes non-Python packages;\nMamba: Faster drop-in replacement for conda;\nMiniforge: Community-driven conda distribution with mamba included;",
    "crumbs": [
      "Home",
      "Introduction",
      "Setup"
    ]
  },
  {
    "objectID": "intro/setup.html#python-and-virtual-environments",
    "href": "intro/setup.html#python-and-virtual-environments",
    "title": "Setup",
    "section": "",
    "text": "We’ll use Python to work with data throughout this course. Python is an excellent choice for network science for its rich ecosystem of libraries, readable and intuitive syntax, and well-documented documentation.\nWe strongly recommend using virtual environments to manage your Python packages. Virtual environments create isolated Python installations for each project, avoiding dependency hell and providing several key benefits:\n\n\nDon’t confuse Python virtual environments with virtual machines (VMs). Python virtual environments are lightweight isolation tools that only separate Python packages and dependencies within the same operating system. Virtual machines, on the other hand, create complete isolated operating systems.\n\nReproducibility: Your code will work consistently across different machines and over time\nFlexibility: You can use different versions of packages for different projects without conflicts\nPrevent project interference: Changes to one project won’t break another project’s dependencies\n\n\n\n\n\n\n\nFigure 1: Without virtual environments, you risk dependency hell where package conflicts make your projects unusable.\n\n\n\nWe recommend using mamba and uv. Mamba is a tool for quickly installing Python and other packages, and for creating isolated environments for your projects. uv is a fast Python package and project manager. While we won’t be running uv commands directly in this course, you’ll need uv to properly run Marimo notebooks, which provides a much better development experience. See here for installation instructions.\nFollow the following steps to install mamba, uv, along with the minimum Python packages required for this course.\n\n[Install mamba] (https://github.com/conda-forge/miniforge)\nRun the following command to create a new environment with the minimum Python packages required for this course.\n\nmamba create -n advnetsci python==3.11 matplotlib scipy numpy pandas seaborn uv\n\nActivate the environment.\n\nmamba activate advnetsci\n\nPip install marimo.\n\npip install marimo\n\n\n\n\n\n\nIf you prefer tools other than uv, here are some alternatives:\n\nvenv: The standard library for creating virtual environments;\npyenv: Great for managing multiple Python versions;\nConda: Popular in data science, includes non-Python packages;\nMamba: Faster drop-in replacement for conda;\nMiniforge: Community-driven conda distribution with mamba included;",
    "crumbs": [
      "Home",
      "Introduction",
      "Setup"
    ]
  },
  {
    "objectID": "intro/setup.html#marimo-notebook",
    "href": "intro/setup.html#marimo-notebook",
    "title": "Setup",
    "section": "2 Marimo Notebook",
    "text": "2 Marimo Notebook\nWe’ll use Marimo (GitHub) notebooks for assignments and interactive exercises throughout the course. Marimo is a reactive Python notebook that automatically updates when you change code, making it perfect for exploring network data and seeing results in real-time.\nFamiliarize yourself with Marimo by taking a look at the “Getting Started” section of the Marimo documentation.\n\n\n\n\nMarimo integrates especially tightly with uv and provides a package sandbox feature that lets you inline dependencies directly in notebook files. This is the easiest way to get started - no prior uv knowledge required.\nCreating a sandboxed notebook:\nuvx marimo edit --sandbox my_notebook.py\nThis command installs marimo in a temporary environment, tracks your dependencies and stores them in the notebook file, and automatically downloads any existing dependencies.\nRunning sandboxed notebooks:\nuv run my_notebook.py\nBenefits: Dependencies are embedded in the notebook file itself, perfect reproducibility, and no need to manage separate dependency files.\n\nAlternative Installation\nIf you’re not using uv, you can install marimo with pip:\npip install marimo\n\n\nRunning Marimo\nTo start a new marimo notebook:\nmarimo edit\nTo open an existing marimo notebook:\nmarimo edit notebook.py",
    "crumbs": [
      "Home",
      "Introduction",
      "Setup"
    ]
  },
  {
    "objectID": "intro/setup.html#github-and-github-copilot",
    "href": "intro/setup.html#github-and-github-copilot",
    "title": "Setup",
    "section": "3 Github and GitHub Copilot",
    "text": "3 Github and GitHub Copilot\nWe’ll use GitHub for assignment collection and auto-grading in this course.\n\n\n\n\n\nMinimum Requirements\nAt the minimum level, you only need to:\n\nCreate a GitHub account at github.com\nKnow how to upload files to GitHub\n\nDetailed instructions on how to upload your assignments to GitHub will be provided separately - advanced Git features are not required for the course. See this assignment example to get familiar with the format.\n\n\nSubscribing to GitHub Copilot\nWe strongly encourage you to use GitHub Copilot, an AI-powered coding assistant that helps you write code faster and more efficiently. GitHub Copilot is an AI pair programmer that provides intelligent code suggestions, completions, and explanations directly in code editor, including VS Code and Marimo.\nStudents can get free access to GitHub Copilot Pro, which includes enhanced features and priority access. Visit the GitHub Copilot Pro free access page to get started.\nMarimo notebook supports GitHub Copilot out of the box. See the instruction to enable it. If you are using VS Code, you can also install the GitHub Copilot extension to get the same experience.\n\n\nFor Students Interested in Learning More\nUnderstanding Git and GitHub is useful for seamlessly working with assignments and will benefit your programming workflow. Additionally, Git and GitHub integrate nicely with AI tools for productivity improvement, making your development process more efficient.\n\n\nGit(Hub) and AI tools are like a pair of best friends. Git ensures that all edits are tracked and can be reverted. GitHub makes it easy for you to collaborate with (multiple) AI agents with you.\n\n\n\n\n\nGitHub Desktop (Recommended for Beginners)\nIf you want to learn more about version control, start with GitHub Desktop, a user-friendly graphical interface:\n\nGo to desktop.github.com\nDownload for your operating system\nInstall and sign in with your GitHub account\n\n\n\nUnderstanding Git and Version Control\nGit is a version control system that tracks changes in your code over time. Think of it as a sophisticated “save” system that:\n\nKeeps a complete history of all changes to your files\nLets you go back to any previous version\nAllows multiple people to work on the same project simultaneously\nHelps you manage different versions or “branches” of your work\n\nGitHub is a cloud-based platform that hosts Git repositories and adds collaboration features.\n\n\nLearning Resources\nEssential resources to understand Git concepts:\n\nInteractive Git Tutorial - Visual, hands-on learning\nGitHub Desktop Documentation - Official desktop app guide\nAtlassian Git Tutorials - Detailed tutorials with examples",
    "crumbs": [
      "Home",
      "Introduction",
      "Setup"
    ]
  },
  {
    "objectID": "m01-euler_tour/03-exercises.html",
    "href": "m01-euler_tour/03-exercises.html",
    "title": "Exercises",
    "section": "",
    "text": "Open in molab\n\n\nExercise Notebook",
    "crumbs": [
      "Home",
      "M01: Euler Tour",
      "Exercises"
    ]
  },
  {
    "objectID": "m02-small-world/00-preparation.html#distance-measures-in-networks",
    "href": "m02-small-world/00-preparation.html#distance-measures-in-networks",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "Small-world networks are fundamentally about distances between nodes. You’ll need to understand:\n\n\nThe shortest path distance between two nodes is the minimum number of edges in any path connecting them.\nimport networkx as nx\n\n# Calculate shortest path distances\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 3), (3, 4), (1, 4)])\ndistance = nx.shortest_path_length(G, 1, 3)  # Returns 2\n\n\n\nFor network analysis, we often compute the average shortest path length across all pairs of nodes:\n\\langle d \\rangle = \\frac{1}{N(N-1)} \\sum_{i \\neq j} d_{ij}\nwhere d_{ij} is the shortest path distance between nodes i and j.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "m02-small-world/00-preparation.html#clustering-concepts",
    "href": "m02-small-world/00-preparation.html#clustering-concepts",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "The clustering coefficient measures how densely connected a node’s neighbors are:\nC_i = \\frac{2E_i}{k_i(k_i-1)}\nwhere E_i is the number of edges between neighbors of node i, and k_i is the degree of node i.\n\n\n\nThe average clustering coefficient across all nodes provides a measure of local connectivity.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "m02-small-world/00-preparation.html#statistical-analysis-prerequisites",
    "href": "m02-small-world/00-preparation.html#statistical-analysis-prerequisites",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "You’ll need basic understanding of: - Random variables and their distributions - Expected values and variance - Comparing observed vs. expected values\n\n\n\nUnderstanding of random graphs where edges are placed randomly with some probability will help contextualize small-world properties.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "m02-small-world/00-preparation.html#computational-prerequisites",
    "href": "m02-small-world/00-preparation.html#computational-prerequisites",
    "title": "Advanced Topics in Network Science",
    "section": "",
    "text": "Basic understanding of computational complexity (O(n), O(n²)) for evaluating network analysis algorithms.\n\n\n\nFamiliarity with: - Lists and dictionaries for graph representations - Efficient storage and retrieval of network data\nThese foundations will help you understand how small-world networks achieve the remarkable property of short average distances despite high local clustering.",
    "crumbs": [
      "Home",
      "M02: Small World",
      "Advanced Topics in Network Science"
    ]
  },
  {
    "objectID": "llm-context/m01-euler_tour.html",
    "href": "llm-context/m01-euler_tour.html",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "",
    "text": "In this module, we will explore the historical moment that gave birth to graph theory and modern network science. A simple Sunday stroll puzzle in an 18th-century Prussian city would spark a mathematical revolution that now powers everything from GPS navigation to social media algorithms.\nThrough Euler’s elegant solution, we will learn:\n\nHow to describe a network using mathematical language\nHow mathematical abstraction reveals hidden structure in complex problems\nThe power of degree-based reasoning in network analysis\nKeywords: network, graph, degree, Euler walk, mathematical abstraction\n\n\n\nThis is not just history—Euler’s approach of abstracting complex systems into nodes and edges is the same method we use today to analyze internet routing, brain connectivity, and viral spread patterns."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#what-to-learn-in-this-module",
    "href": "llm-context/m01-euler_tour.html#what-to-learn-in-this-module",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "",
    "text": "In this module, we will explore the historical moment that gave birth to graph theory and modern network science. A simple Sunday stroll puzzle in an 18th-century Prussian city would spark a mathematical revolution that now powers everything from GPS navigation to social media algorithms.\nThrough Euler’s elegant solution, we will learn:\n\nHow to describe a network using mathematical language\nHow mathematical abstraction reveals hidden structure in complex problems\nThe power of degree-based reasoning in network analysis\nKeywords: network, graph, degree, Euler walk, mathematical abstraction\n\n\n\nThis is not just history—Euler’s approach of abstracting complex systems into nodes and edges is the same method we use today to analyze internet routing, brain connectivity, and viral spread patterns."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#a-sunday-stroll-that-changed-mathematics",
    "href": "llm-context/m01-euler_tour.html#a-sunday-stroll-that-changed-mathematics",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "2 A Sunday Stroll That Changed Mathematics",
    "text": "2 A Sunday Stroll That Changed Mathematics\nBack in the 18th century, there was a city called Königsberg situated on the Pregel River in what was then Prussia (now Kaliningrad, Russia). The city was built around two large islands, beautifully connected to each other and the mainland by seven elegant bridges.\n\n\nKönigsberg was a major intellectual center of the Enlightenment. Immanuel Kant spent his entire life there, never traveling more than 10 miles from the city. The university attracted scholars from across Europe.\nDuring their leisurely Sunday walks, the citizens of Königsberg found themselves pondering an intriguing puzzle:\n\n\n\n\n\n\nThe Königsberg Bridge Problem\n\n\n\nIs it possible to take a walk through the city that crosses each bridge exactly once and returns to the starting point?\n\n\n\n\n\nThe seven bridges of Königsberg {#fig-seven-bridges}\n\n\nThis seemingly innocent recreational question would become one of the most important problems in the history of mathematics. What made it revolutionary wasn’t the answer, but how the answer was found."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#try-it-yourself-first",
    "href": "llm-context/m01-euler_tour.html#try-it-yourself-first",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "3 Try It Yourself First!",
    "text": "3 Try It Yourself First!\nBefore we reveal Euler’s brilliant solution, take some time to think about this problem yourself. This is exactly how mathematical discovery works—by wrestling with puzzles and developing your own insights.\n\n\n\n\n\n\nWork Through It Step by Step\n\n\n\nHighly recommended: Download and work through this excellent pen-and-paper worksheet created by Esteban Moro (Moro 2017). It guides you through Euler’s reasoning step by step, letting you discover the solution yourself.\nQuestions to consider while working:\n\nCan you trace a path that crosses each bridge exactly once?\nWhat patterns do you notice when you try different routes?\nWhat properties of the landmasses seem important?\nHow might you prove that something is impossible, rather than just failing to find it?\n\n\n\nThe beauty of mathematics lies not just in the answers, but in the process of discovery.\n\n\n\n\n\n\n⚠️ Pause Here First!\n\n\n\nBefore reading Euler’s solution below, we strongly encourage you to:\n\nWork through the pen-and-paper worksheet by Esteban Moro\nTry the puzzle yourself - can you find a path that crosses each bridge exactly once?\nThink about what makes this problem difficult - what constraints do you notice?\n\nThe learning experience is much richer when you discover the insights yourself first!\n\n\nOnce you’ve given it some thought, continue reading to see how Euler approached this problem in 1736."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#eulers-revolutionary-abstraction",
    "href": "llm-context/m01-euler_tour.html#eulers-revolutionary-abstraction",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "4 🔍 Euler’s Revolutionary Abstraction",
    "text": "4 🔍 Euler’s Revolutionary Abstraction\nLeonhard Euler approached this puzzle in 1736 with a stroke of genius that would define mathematical thinking for centuries. Instead of getting bogged down in the physical details—the width of the bridges, the size of the islands, the beauty of the architecture—he made a radical simplification.\n\n\nLeonhard Euler (1707-1783) was one of the most prolific mathematicians in history, contributing to nearly every area of mathematics. He lost sight in his right eye in 1738 but continued his work, producing almost half of his total output after becoming completely blind in 1766.\n\nThis was revolutionary thinking for its time. Before Euler, mathematics focused on quantities, measurements, and calculations. Euler showed that sometimes the relationships between objects matter more than the objects themselves.\nEuler realized that for this problem, only one thing mattered: which landmasses connect to which other landmasses. Everything else—the bridge lengths, island shapes, water depths—was irrelevant distraction.\nHe simplified the city into a network of landmasses connected by bridges:\n\n\n\n\n\n\nFigure 1: Euler’s graph of the bridges of Knigsberg. Taken from The Essential Guide to Graph Theory: From an 18th Century Riddle to AI Frameworks\n\n\n\nThis abstraction—reducing a complex physical system to its essential connectivity—was the birth of graph theory. Euler had invented a new mathematical language for describing relationships.\nOnce Euler had his abstract graph, he made another crucial insight. Instead of trying different walking routes (which would take forever), he focused on a fundamental property: how many bridges connect to each landmass?\n\n\nThis shift from “trying all possibilities” to “analyzing constraints” is a hallmark of mathematical thinking. Instead of brute force, Euler used logical reasoning to prove impossibility.\nEuler considered the degree (number of connections) of each node and realized there were only two cases: - a node has an even number of edges, or - a node has an odd number of edges.\nWhen a node has an even number 2k of edges, you can enter and leave the node exactly k times by crossing different edges. Every time you enter through one bridge, you can leave through another. The bridges naturally pair up.\nWhen a node has an odd number 2k+1 of edges, you can enter and leave the node k times, but one edge is left over. The only way to cross this last edge is if your journey starts or ends at this node.\n\n\nThink of it like a dance where everyone needs a partner. In nodes with even degree, every bridge has a “partner” for entering and leaving. Odd-degree nodes always have one “wallflower” bridge that can only be used at the very beginning or end.\nBased on this elegant reasoning, Euler arrived at his famous theorem:\n\n\n\n\n\n\nEuler’s Path Theorem\n\n\n\nA walk that crosses all edges exactly once exists if and only if:\n\nAll nodes have even degree, OR\nExactly two nodes have odd degree\n\n\n\nThis wasn’t just a solution—it was a proof. Euler had shown not just whether such a path exists, but exactly when it’s possible.\n\n\nA good Youtube video explaining the Euler’s story:"
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#the-verdict-königsbergs-impossible-dream",
    "href": "llm-context/m01-euler_tour.html#the-verdict-königsbergs-impossible-dream",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "5 ⚖️ The Verdict: Königsberg’s Impossible Dream",
    "text": "5 ⚖️ The Verdict: Königsberg’s Impossible Dream\nApplying Euler’s theorem to the original Königsberg bridges reveals the truth: every landmass has an odd number of bridges. According to Euler’s conditions, this makes the desired walk impossible.\n\n\nIn the original graph: North shore (3 bridges), South shore (3 bridges), Large island (5 bridges), Small island (3 bridges). Four nodes with odd degree—exactly two more than Euler’s theorem allows.\nThe citizens of Königsberg had been attempting the impossible. Their Sunday stroll puzzle had no solution, and Euler had proven it with mathematical certainty.\nThe story takes a sobering turn during World War II. In 1944, Königsberg was heavily bombed by Allied forces, and later captured by the Soviet Union. Two of the seven historic bridges were destroyed in the bombardment.\n\n\n\nAfter WWII bombing, only five bridges remained—finally making an Euler path possible. {#fig-markdown-fig}\n\n\n\n\nThe city was renamed Kaliningrad and became part of Russia. Today, it remains a Russian exclave, separated from the rest of Russia by Lithuania and Poland. The few remaining bridges span a river now in a very different political landscape.\nWith only five bridges remaining, the network finally satisfied Euler’s conditions: exactly two nodes had odd degree. The mathematical puzzle that had stumped citizens for two centuries was “solved” by the tragic circumstances of war.\nThis ironic resolution reminds us that while mathematics reveals timeless truths about structure and possibility, the physical world—and human history—follows much more complex and unpredictable patterns."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#the-lasting-legacy",
    "href": "llm-context/m01-euler_tour.html#the-lasting-legacy",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "6 The Lasting Legacy",
    "text": "6 The Lasting Legacy\nEuler’s solution to the Königsberg bridge problem did far more than solve a recreational puzzle. It demonstrated that:\n\nAbstract thinking can solve concrete problems\nMathematical proof is more powerful than trial and error\nNetwork structure determines what’s possible in interconnected systems\n\nThese insights now underpin our understanding of everything from internet routing protocols to epidemic spreading models. Every time you use GPS navigation or analyze social network data, you’re applying principles that trace back to Euler’s Sunday stroll through Königsberg.\n\nFun trivia:\nLeonhard Euler (1707-1783): Swiss mathematician and physicist, widely regarded as one of the most prolific mathematicians in history. Beyond solving the Königsberg bridge problem, he made fundamental contributions to calculus, topology, number theory, and physics. Despite losing sight in one eye and later becoming completely blind, he continued his mathematical work and produced nearly half of his total output after losing his sight.\nImmanuel Kant (1724-1804): German philosopher and one of the central thinkers of the Enlightenment. Born and died in Königsberg, never traveling more than 10 miles from the city. His systematic works in epistemology, metaphysics, ethics, and aesthetics have made him one of the most influential figures in modern Western philosophy. His regular daily walks were so punctual that neighbors reportedly set their clocks by his daily walks."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#references",
    "href": "llm-context/m01-euler_tour.html#references",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "7 References",
    "text": "7 References\n\n\ntitle: Coding Networks in Python jupyter: python3 execute: enabled: true —\nNow that you understand the conceptual foundation from Euler’s work, let’s explore how to represent and analyze networks computationally. Given a network of any size, our goal is to create a function that can tell us whether the network has an Euler path or not.\ndef has_euler_path(A):\n    \"\"\"\n    Check if a graph has an Euler path based on node degrees.\n    Complete this function based on Euler's theorem.\n\n    A: network\n    return: True if the network has an Euler path, False otherwise\n    \"\"\"\n    pass\nWe’ll work through both general network representations and apply them specifically to the Königsberg bridge problem.\n\n8 Network Representations: From Pictures to Data Structures\nConsider this network with 5 nodes and 6 edges:\n\n\n\n\n\n\nFigure 2: A small graph of five nodes and six edges.\n\n\n\nHow do we represent this graph in a format that a computer can understand and manipulate? Just as Euler needed to abstract Königsberg’s bridges, we need data structures that capture the network’s essential connectivity while enabling efficient analysis.\n\n\nThe choice of representation can dramatically affect computational efficiency. For sparse networks (few edges), adjacency lists are memory-efficient. For dense networks or matrix operations, adjacency matrices are preferred.\nLet’s explore three fundamental approaches that form the backbone of all network algorithms.\n\nEdge Table: The Direct Approach\nThe edge table directly lists connections as pairs—the most intuitive way to store network data.\n\n\nEdge tables are also called “edge lists” and are the most common format for storing large-scale network data in files. Social media platforms like Twitter and Facebook store billions of connections this way.\n\n# Each row represents one edge (connection between two nodes)\nedges = [\n    (0, 1),  # Node 0 connects to Node 1\n    (0, 2),  # Node 0 connects to Node 2\n    (1, 2),  # Node 1 connects to Node 2\n    (1, 3),  # Node 1 connects to Node 3\n    (2, 4),  # Node 2 connects to Node 4\n    (3, 4)   # Node 3 connects to Node 4\n]\n\nprint(f\"Network has {len(edges)} edges\")\nprint(\"Edge list:\", edges)\n\nThis mirrors how we’d naturally describe the network: “Node 0 connects to nodes 1 and 2, node 1 connects to nodes 0, 2, and 3…” It’s the digital equivalent of Euler’s original approach—simply listing which bridges connect which landmasses.\n\n\nAdjacency List: The Neighborhood Map\nThe adjacency list stores each node’s neighbors in a dictionary—like a social network where each person has a list of friends.\n\n\nMost graph algorithms prefer adjacency lists because they allow fast iteration over a node’s neighbors. This is crucial for algorithms like breadth-first search or computing clustering coefficients.\n\n# Define adjacency list directly as a dictionary\nneighbors = {\n    0: [1, 2],     # Node 0 connects to nodes 1 and 2\n    1: [0, 2, 3],  # Node 1 connects to nodes 0, 2, and 3\n    2: [0, 1, 4],  # Node 2 connects to nodes 0, 1, and 4\n    3: [1, 4],     # Node 3 connects to nodes 1 and 4\n    4: [2, 3]      # Node 4 connects to nodes 2 and 3\n}\n\nprint(\"Adjacency list representation:\")\nfor node, neighbor_list in neighbors.items():\n    print(f\"Node {node}: {neighbor_list}\")\n\n\n\nAdjacency Matrix: The Mathematical Grid\nThe adjacency matrix uses a grid where entry (i,j) = 1 if nodes are connected—the mathematician’s favorite representation.\n\n\nAdjacency matrices enable powerful mathematical operations. Matrix multiplication reveals paths of different lengths, and eigenvalue analysis can uncover community structure. Google’s PageRank algorithm fundamentally relies on matrix operations.\n\n# Define adjacency matrix directly\nimport numpy as np\n\nmatrix = np.array([\n    [0, 1, 1, 0, 0],  # Node 0 connects to nodes 1, 2\n    [1, 0, 1, 1, 0],  # Node 1 connects to nodes 0, 2, 3\n    [1, 1, 0, 0, 1],  # Node 2 connects to nodes 0, 1, 4\n    [0, 1, 0, 0, 1],  # Node 3 connects to nodes 1, 4\n    [0, 0, 1, 1, 0]   # Node 4 connects to nodes 2, 3\n])\n\nprint(\"Adjacency matrix:\")\nprint(matrix)\n\nNotice the symmetry: if node i connects to node j, then node j connects to node i (for undirected networks). This symmetry disappears in directed networks, where relationships can be one-way.\n\n\n\n9 Counting Node Degrees: Euler’s Key Insight\nThe degree of a node is the number of edges connected to it. This simple concept was central to Euler’s proof—he realized that a valid bridge walk requires each landmass to have an even degree (except possibly the starting and ending points).\n\n\nIn Königsberg, all four landmasses had odd degree, making the bridge walk impossible. This insight—that global properties emerge from local structure—remains fundamental to network analysis today.\nHere’s how to compute degrees using each representation:\n\nFrom Edge Table: Counting Appearances\nCount how many times each node appears in the edge list.\n\n_degrees = [0] * 5\nfor node1, node2 in edges:\n    _degrees[node1] += 1\n    _degrees[node2] += 1\nprint(\"Degrees from edge list:\", _degrees)\n\n\n\nWe increment the degree counter for both nodes in each edge because every edge contributes to two nodes’ degrees. This is why the total degree always equals twice the number of edges.\n\n\nFrom Adjacency List: Counting Friends\nCount the length of each node’s neighbor list—the most direct approach.\n\n_degrees = [len(neighbors[i]) for i in range(5)]\nprint(\"Degrees from adjacency list:\", _degrees)\n\n\n\nFrom Adjacency Matrix: Linear Algebra Power\nSum each row (or column) of the matrix—leveraging vectorized operations.\n\n_degrees = matrix.sum(axis=1)  # Sum rows\nprint(\"Degrees from adjacency matrix:\", _degrees)\n\n\n\nFor undirected networks, row sums equal column sums. For directed networks, row sums give out-degree (outgoing connections) while column sums give in-degree (incoming connections).\n\n\n\n10 Summary: From Euler’s Insight to Modern Computation\nYou now understand how to:\n\nRepresent networks using edge lists, adjacency lists, and adjacency matrices\nCompute node degrees efficiently using different data structures\n\nThe next step is to practice these concepts with real network data and explore more advanced network analysis techniques!— title: “Advanced: Sparse Matrices for Large-Scale Networks” jupyter: python3 —\n\n\n11 The Scale Problem: From Königsberg to Global Networks\nWhile Euler’s analysis worked perfectly for Königsberg’s 4 landmasses and 7 bridges, today’s networks operate at vastly different scales. Suppose we want to represent the social network of all people on Earth using an adjacency matrix. How much memory would we need? For an adjacency matrix with 8 billion nodes, the matrix size is 8 \\times 10^9 \\times 8 \\times 10^9 = 64 \\times 10^{18} entries, and the memory required is 64 \\times 10^{18} \\times 8 bytes ≈ 512 exabytes! Clearly, this approach is not feasible!\nA way to solve this problem is to exploit the fact that real networks are sparse: most pairs of nodes are not connected.\nTo give you an idea, let’s consider a social network of 8 billion people on Earth. How likely do you think that two randomly picked people are friends? If the network is dense, it should be likely. But in reality, it is very unlikely, right? So much so that the probability is almost zero (less than 3.1e-23 if each person has 100 friends on average)!\nThis means that working with the edge list is a good idea as it retains only the connections, not the non-connections (which are much more than the connections!). But the edge list is not efficient for many operaitions\n\n\nThink about the following operations:\n\nDegree: How many friends does a person have?\nNeighbors: Who are the friends of a person?\n\nThese operations are very common in network analysis. To do so, you need to go through all the edges in the network. This is not efficient, especially for large networks.\n\n\n12 Solution: Sparse Matrices\nWe say a matrix is sparse if the matrix has only a handful of non-zero entries. This is indeed the case for most real-world networks. For such networks, we can use a special type of data type called Compressed Sparse Row (CSR) or Compressed Sparse Column (CSC) to represent the network. This is widely used in many network analysis tools and makes it possible to process large networks in practice.\nTo learn more, here is a very good blog post by Matt Eding about efficient network representations.\n\n\n\n\n\n\n\nMoro, Esteban. 2017. “Network Science for Kids!” http://estebanmoro.org/2017/03/network-science-for-kids."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#network-representations-from-pictures-to-data-structures",
    "href": "llm-context/m01-euler_tour.html#network-representations-from-pictures-to-data-structures",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "8 Network Representations: From Pictures to Data Structures",
    "text": "8 Network Representations: From Pictures to Data Structures\nConsider this network with 5 nodes and 6 edges:\n\n\n\n\n\n\nFigure 2: A small graph of five nodes and six edges.\n\n\n\nHow do we represent this graph in a format that a computer can understand and manipulate? Just as Euler needed to abstract Königsberg’s bridges, we need data structures that capture the network’s essential connectivity while enabling efficient analysis.\n\n\nThe choice of representation can dramatically affect computational efficiency. For sparse networks (few edges), adjacency lists are memory-efficient. For dense networks or matrix operations, adjacency matrices are preferred.\nLet’s explore three fundamental approaches that form the backbone of all network algorithms.\n\nEdge Table: The Direct Approach\nThe edge table directly lists connections as pairs—the most intuitive way to store network data.\n\n\nEdge tables are also called “edge lists” and are the most common format for storing large-scale network data in files. Social media platforms like Twitter and Facebook store billions of connections this way.\n\n# Each row represents one edge (connection between two nodes)\nedges = [\n    (0, 1),  # Node 0 connects to Node 1\n    (0, 2),  # Node 0 connects to Node 2\n    (1, 2),  # Node 1 connects to Node 2\n    (1, 3),  # Node 1 connects to Node 3\n    (2, 4),  # Node 2 connects to Node 4\n    (3, 4)   # Node 3 connects to Node 4\n]\n\nprint(f\"Network has {len(edges)} edges\")\nprint(\"Edge list:\", edges)\n\nThis mirrors how we’d naturally describe the network: “Node 0 connects to nodes 1 and 2, node 1 connects to nodes 0, 2, and 3…” It’s the digital equivalent of Euler’s original approach—simply listing which bridges connect which landmasses.\n\n\nAdjacency List: The Neighborhood Map\nThe adjacency list stores each node’s neighbors in a dictionary—like a social network where each person has a list of friends.\n\n\nMost graph algorithms prefer adjacency lists because they allow fast iteration over a node’s neighbors. This is crucial for algorithms like breadth-first search or computing clustering coefficients.\n\n# Define adjacency list directly as a dictionary\nneighbors = {\n    0: [1, 2],     # Node 0 connects to nodes 1 and 2\n    1: [0, 2, 3],  # Node 1 connects to nodes 0, 2, and 3\n    2: [0, 1, 4],  # Node 2 connects to nodes 0, 1, and 4\n    3: [1, 4],     # Node 3 connects to nodes 1 and 4\n    4: [2, 3]      # Node 4 connects to nodes 2 and 3\n}\n\nprint(\"Adjacency list representation:\")\nfor node, neighbor_list in neighbors.items():\n    print(f\"Node {node}: {neighbor_list}\")\n\n\n\nAdjacency Matrix: The Mathematical Grid\nThe adjacency matrix uses a grid where entry (i,j) = 1 if nodes are connected—the mathematician’s favorite representation.\n\n\nAdjacency matrices enable powerful mathematical operations. Matrix multiplication reveals paths of different lengths, and eigenvalue analysis can uncover community structure. Google’s PageRank algorithm fundamentally relies on matrix operations.\n\n# Define adjacency matrix directly\nimport numpy as np\n\nmatrix = np.array([\n    [0, 1, 1, 0, 0],  # Node 0 connects to nodes 1, 2\n    [1, 0, 1, 1, 0],  # Node 1 connects to nodes 0, 2, 3\n    [1, 1, 0, 0, 1],  # Node 2 connects to nodes 0, 1, 4\n    [0, 1, 0, 0, 1],  # Node 3 connects to nodes 1, 4\n    [0, 0, 1, 1, 0]   # Node 4 connects to nodes 2, 3\n])\n\nprint(\"Adjacency matrix:\")\nprint(matrix)\n\nNotice the symmetry: if node i connects to node j, then node j connects to node i (for undirected networks). This symmetry disappears in directed networks, where relationships can be one-way."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#counting-node-degrees-eulers-key-insight",
    "href": "llm-context/m01-euler_tour.html#counting-node-degrees-eulers-key-insight",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "9 Counting Node Degrees: Euler’s Key Insight",
    "text": "9 Counting Node Degrees: Euler’s Key Insight\nThe degree of a node is the number of edges connected to it. This simple concept was central to Euler’s proof—he realized that a valid bridge walk requires each landmass to have an even degree (except possibly the starting and ending points).\n\n\nIn Königsberg, all four landmasses had odd degree, making the bridge walk impossible. This insight—that global properties emerge from local structure—remains fundamental to network analysis today.\nHere’s how to compute degrees using each representation:\n\nFrom Edge Table: Counting Appearances\nCount how many times each node appears in the edge list.\n\n_degrees = [0] * 5\nfor node1, node2 in edges:\n    _degrees[node1] += 1\n    _degrees[node2] += 1\nprint(\"Degrees from edge list:\", _degrees)\n\n\n\nWe increment the degree counter for both nodes in each edge because every edge contributes to two nodes’ degrees. This is why the total degree always equals twice the number of edges.\n\n\nFrom Adjacency List: Counting Friends\nCount the length of each node’s neighbor list—the most direct approach.\n\n_degrees = [len(neighbors[i]) for i in range(5)]\nprint(\"Degrees from adjacency list:\", _degrees)\n\n\n\nFrom Adjacency Matrix: Linear Algebra Power\nSum each row (or column) of the matrix—leveraging vectorized operations.\n\n_degrees = matrix.sum(axis=1)  # Sum rows\nprint(\"Degrees from adjacency matrix:\", _degrees)\n\n\n\nFor undirected networks, row sums equal column sums. For directed networks, row sums give out-degree (outgoing connections) while column sums give in-degree (incoming connections)."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#summary-from-eulers-insight-to-modern-computation",
    "href": "llm-context/m01-euler_tour.html#summary-from-eulers-insight-to-modern-computation",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "10 Summary: From Euler’s Insight to Modern Computation",
    "text": "10 Summary: From Euler’s Insight to Modern Computation\nYou now understand how to:\n\nRepresent networks using edge lists, adjacency lists, and adjacency matrices\nCompute node degrees efficiently using different data structures\n\nThe next step is to practice these concepts with real network data and explore more advanced network analysis techniques!— title: “Advanced: Sparse Matrices for Large-Scale Networks” jupyter: python3 —"
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#the-scale-problem-from-königsberg-to-global-networks",
    "href": "llm-context/m01-euler_tour.html#the-scale-problem-from-königsberg-to-global-networks",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "11 The Scale Problem: From Königsberg to Global Networks",
    "text": "11 The Scale Problem: From Königsberg to Global Networks\nWhile Euler’s analysis worked perfectly for Königsberg’s 4 landmasses and 7 bridges, today’s networks operate at vastly different scales. Suppose we want to represent the social network of all people on Earth using an adjacency matrix. How much memory would we need? For an adjacency matrix with 8 billion nodes, the matrix size is 8 \\times 10^9 \\times 8 \\times 10^9 = 64 \\times 10^{18} entries, and the memory required is 64 \\times 10^{18} \\times 8 bytes ≈ 512 exabytes! Clearly, this approach is not feasible!\nA way to solve this problem is to exploit the fact that real networks are sparse: most pairs of nodes are not connected.\nTo give you an idea, let’s consider a social network of 8 billion people on Earth. How likely do you think that two randomly picked people are friends? If the network is dense, it should be likely. But in reality, it is very unlikely, right? So much so that the probability is almost zero (less than 3.1e-23 if each person has 100 friends on average)!\nThis means that working with the edge list is a good idea as it retains only the connections, not the non-connections (which are much more than the connections!). But the edge list is not efficient for many operaitions\n\n\nThink about the following operations:\n\nDegree: How many friends does a person have?\nNeighbors: Who are the friends of a person?\n\nThese operations are very common in network analysis. To do so, you need to go through all the edges in the network. This is not efficient, especially for large networks."
  },
  {
    "objectID": "llm-context/m01-euler_tour.html#solution-sparse-matrices",
    "href": "llm-context/m01-euler_tour.html#solution-sparse-matrices",
    "title": "Euler Tour Concepts - The Birth of Network Science",
    "section": "12 Solution: Sparse Matrices",
    "text": "12 Solution: Sparse Matrices\nWe say a matrix is sparse if the matrix has only a handful of non-zero entries. This is indeed the case for most real-world networks. For such networks, we can use a special type of data type called Compressed Sparse Row (CSR) or Compressed Sparse Column (CSC) to represent the network. This is widely used in many network analysis tools and makes it possible to process large networks in practice.\nTo learn more, here is a very good blog post by Matt Eding about efficient network representations."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to SSIE 641 Advanced Topics on Network Science",
    "section": "",
    "text": "``Don’t think! Feeeeeel’’ is a famous quote by Bruce Lee in the movie Enter the Dragon, and this is my guiding philosophy of learning.\nThis course is designed to help you feel the concepts and tools of network science through pen-and-paper exercises and hands-on coding."
  },
  {
    "objectID": "index.html#list-of-exercises",
    "href": "index.html#list-of-exercises",
    "title": "Welcome to SSIE 641 Advanced Topics on Network Science",
    "section": "1 List of Exercises",
    "text": "1 List of Exercises\n\n\n\nModule\nPen and Paper Exercise\nNotebook\n\n\n\n\nM01: Euler Tour\nThe Koningsberg Bridge\nNotebook\n\n\nM02: Small World\nIt’s a small world!! 6 degrees of separation\nNotebook\n\n\nM03: Robustness\nBuild it, Break it, and Build it back!\nNotebook\n\n\nM04: Friendship Paradox\nData Visualization\nNotebook\n\n\nM05: Clustering\nPerfect vs. Almost Perfect\nNotebook\n\n\nM06: Centrality\nWho’s the Big Cheese in the University Clubs?\nNotebook\n\n\nM07: Random Walks\nRandom Walks on Networks\nNotebook\n\n\nM08: Embedding\nNetwork Embeddings\nNotebook\n\n\nM09: Graph Neural Networks\nGraph Neural Networks\nNotebook"
  },
  {
    "objectID": "index.html#list-of-assignments",
    "href": "index.html#list-of-assignments",
    "title": "Welcome to SSIE 641 Advanced Topics on Network Science",
    "section": "2 List of assignments",
    "text": "2 List of assignments\nNote: For the students taking SSIE 641, the grading will be done through GitHub Classroom, and the following assignments are not linked to GitHub Classroom. Please use the links provided by the instructor. All the links are listed in Brightspace.\n\n\n\nModule\nAssignment\n\n\n\n\nSmall World\nAssignment 1\n\n\nNetwork Centrality\nAssignment 2\n\n\nSmall world networks\nAssignment 3"
  }
]