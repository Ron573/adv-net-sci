{
  "hash": "ff5fb44a6fba213f1a751d31a30b9a1a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Clustering Algorithms and Implementation\"\njupyter: advnetsci\nexecute:\n    enabled: true\n---\n\n# Hands-on: Clustering\n\n\n```python\n# If you are using Google Colab, uncomment the following line to install igraph\n#!sudo apt install libcairo2-dev pkg-config python3-dev\n#!pip install pycairo cairocffi\n#!pip install igraph\n```\n\n## Modularity maximization\n\nLet us showcase how to use `igraph` to detect communities with modularity. We will use the Karate Club Network as an example.\n\n::: {#97538591 .cell execution_count=1}\n``` {.python .cell-code}\nimport igraph\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(10, 8))\ng = igraph.Graph.Famous(\"Zachary\")\nigraph.plot(g, target=ax, vertex_size=20)\nplt.axis('off')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-coding_files/figure-html/cell-2-output-1.png){}\n:::\n:::\n\n\nWhen it comes to maximizing modularity, there are a variety of algorithms to choose from.\nTwo of the most popular ones are the `Louvain` and `Leiden` algorithms, both of which are implemented in `igraph`. The Louvain algorithm has been around for quite some time and is a classic choice, while the Leiden algorithm is a newer bee that often yields better accuracy. For our example, we'll be using the `Leiden` algorithm, and I think you'll find it really effective!\n\n::: {#ae0f9064 .cell execution_count=2}\n``` {.python .cell-code}\ncommunities = g.community_leiden(resolution=1, objective_function= \"modularity\")\n```\n:::\n\n\nWhat is `resolution`? It is a parameter that helps us tackle the resolution limit of the modularity maximization algorithm {footcite}`fortunato2007resolution`!\nIn simple terms, when we use the resolution parameter $\\rho$, the modularity formula can be rewritten as\n follow:\n\n$$\nQ(M) = \\frac{1}{2m} \\sum_{i=1}^n \\sum_{j=1}^n \\left(A_{ij} - \\rho \\frac{k_i k_j}{2m}\\right) \\delta(c_i, c_j)\n$$\n\nHere, the parameter $\\rho$ plays a crucial role in balancing the positive and negative parts of the equation.\nThe resolution limit comes into play because of the diminishing effect of the negative term as the number of edges $m$ increases.\nThe parameter $\\rho$ can adjust this balance and allow us to circumvent the resolution limit.\n\nWhat is `communities`? This is a list of communities, where each community is represented by a list of nodes by their indices.\n\n::: {#8c70a309 .cell execution_count=3}\n``` {.python .cell-code}\nprint(communities.membership)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0, 0, 0, 0, 1, 1, 1, 0, 2, 2, 1, 0, 0, 0, 2, 2, 1, 0, 2, 0, 2, 0, 2, 3, 3, 3, 2, 3, 3, 2, 2, 3, 2, 2]\n```\n:::\n:::\n\n\nLet us visualize the communities by coloring the nodes in the graph.\n\n::: {#ca3d2f4b .cell execution_count=4}\n``` {.python .cell-code}\nimport seaborn as sns\ncommunity_membership = communities.membership\npalette = sns.color_palette().as_hex()\nfig, ax = plt.subplots(figsize=(10, 8))\nigraph.plot(g, target=ax, vertex_color=[palette[i] for i in community_membership])\nplt.axis('off')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-coding_files/figure-html/cell-5-output-1.png){}\n:::\n:::\n\n\n- `community_membership`: This is a list of community membership for each node.\n- `palette`: This is a list of colors to use for the communities.\n- `igraph.plot(g, vertex_color=[palette[i] for i in community_membership])`: This plots the graph 'g' with nodes colored by their community.\n\n## Stochstic Block Model\n\nLet us turn the SBM as our community detection tool using [graph-tool](https://graph-tool.skewed.de/). This is a powerful library for network analysis, with a focus on the stochastic block model.\n\n\n```python\n#\n# Uncomment the following code if you are using Google Colab\n#\n#!wget https://downloads.skewed.de/skewed-keyring/skewed-keyring_1.0_all_$(lsb_release -s -c).deb\n#!dpkg -i skewed-keyring_1.0_all_$(lsb_release -s -c).deb\n#!echo \"deb [signed-by=/usr/share/keyrings/skewed-keyring.gpg] https://downloads.skewed.de/apt $(lsb_release -s -c) main\" > /etc/apt/sources.list.d/skewed.list\n#!apt-get update\n#!apt-get install python3-graph-tool python3-matplotlib python3-cairo\n#!apt purge python3-cairo\n#!apt install libcairo2-dev pkg-config python3-dev\n#!pip install --force-reinstall pycairo\n#!pip install zstandard\n```\n\nWe will identify the communities using the stochastic block model as follows.\nFirst, we will convert the graph object in igraph to that in graph-tool.\n\n::: {#dd7bde50 .cell execution_count=5}\n``` {.python .cell-code}\nimport graph_tool.all  as gt\nimport numpy as np\nimport igraph\n\n# igraph object\ng = igraph.Graph.Famous(\"Zachary\")\n\n# Set random seed for reproducibility\nnp.random.seed(42)\n\n# Convert the graph object in igraph to that in graph-tool\nedges = g.get_edgelist()\nr, c = zip(*edges)\ng_gt = gt.Graph(directed=False)\ng_gt.add_edge_list(np.vstack([r, c]).T)\n```\n:::\n\n\nThen, we will fit the stochastic block model to the graph.\n\n::: {#9076b35c .cell execution_count=6}\n``` {.python .cell-code}\n# Fit the stochastic block model\nstate = gt.minimize_blockmodel_dl(\n     g_gt,\n     state_args={\"deg_corr\": False, \"B_min\":2, \"B_max\":10},\n)\nb = state.get_blocks()\n```\n:::\n\n\n- `B_min` and `B_max` are the minimum and maximum number of communities to consider.\n- `deg_corr` is a boolean flag to switch to the degree-corrected SBM {footcite}`karrer2011stochastic`.\n\n\n::: {.callout-note}\nHere's a fun fact: the likelihood maximization on its own can't figure out how many communities there should be. But `graph-tool` has a clever trick to circumvent this limitation.\n`graph-tool` actually fits multiple SBMs, each with a different number of communities. Then, it picks the most plausible one based on a model selection criterion.\n:::\n\nLet's visualize the communities to see what we got.\n\n::: {#892ed77f .cell execution_count=7}\n``` {.python .cell-code}\n# Convert the block assignments to a list\ncommunity_membership = b.get_array()\n\n# The community labels may consist of non-consecutive integers, e.g., 10, 8, 1, 4, ...\n# So we reassign the community labels to be 0, 1, 2, ...\ncommunity_membership = np.unique(community_membership, return_inverse=True)[1]\ncommunity_membership\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\narray([0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2])\n```\n:::\n:::\n\n\n::: {#ced514fe .cell execution_count=8}\n``` {.python .cell-code}\n# Create a color palette\npalette = sns.color_palette().as_hex()\n# Plot the graph with nodes colored by their community\nfig, ax = plt.subplots(figsize=(10, 8))\nigraph.plot(\n    g,\n    target=ax,\n    vertex_color=[palette[i] for i in community_membership],\n)\nplt.axis('off')\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-coding_files/figure-html/cell-9-output-1.png){}\n:::\n:::\n\n\nWhat we're seeing here isn't a failure at all. In fact, it's the best partition according to our stochastic block model. The model has discovered something called a **core-periphery structure**  [@borgatti2000models]. Let me break that down:\n\n- Think of a major international airport (the core) and smaller regional airports (the periphery).\n- Major international airports have many flights connecting to each other (densely connected).\n- Smaller regional airports have fewer connections among themselves (sparsely connected).\n- Many regional airports have flights to major hubs (periphery connected to the core).\n\nThat's exactly what our model found in this network.\n\nIf we look at the adjacency matrix, we would see something that looks like an upside-down \"L\". This shape is like a signature for core-periphery structures.\n\n::: {#16e51976 .cell execution_count=9}\n``` {.python .cell-code}\n# Convert igraph Graph to adjacency matrix\nA = np.array(g.get_adjacency().data)\n\n# Sort nodes based on their community (core first, then periphery)\nsorted_indices = np.argsort(community_membership)\nA_sorted = A[sorted_indices][:, sorted_indices]\n\n# Plot the sorted adjacency matrix\nplt.figure(figsize=(10, 8))\nplt.imshow(A_sorted, cmap='binary')\nplt.title(\"Sorted Adjacency Matrix: Core-Periphery Structure\")\nplt.xlabel(\"Node Index (sorted)\")\nplt.ylabel(\"Node Index (sorted)\")\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-coding_files/figure-html/cell-10-output-1.png){}\n:::\n:::\n\n\nTo account for\n\n",
    "supporting": [
      "02-coding_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}