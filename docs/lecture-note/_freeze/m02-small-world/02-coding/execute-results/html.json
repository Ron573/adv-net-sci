{
  "hash": "a908511d062ad7c2061168253eb327d6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Efficient Network Representation and Computing Paths\"\njupyter: advnetsci\nexecute:\n    enabled: true\n---\n\n## Convenient libraries for network analysis\n\nThe Python ecosystem offers several powerful libraries for network analysis, each with distinct strengths:\n\n- [networkx](https://networkx.org/) - a beginner-friendly library for network analysis\n- [igraph](https://igraph.org/python/) - a mature library with a wide range of algorithms\n- [graph-tool](https://graph-tool.skewed.de/) - specialized for stochastic block models\n- [scipy](https://scipy.org/) - efficient tools for analyzing large networks\n\nThroughout this course, we'll primarily use `igraph`, a mature and robust library originally developed for R and later ported to Python. While `networkx` is by far the most popular library, `igraph` offers several compelling advantages for serious network analysis: it provides more reliable algorithm implementations (avoiding persistent bugs found in some `networkx` functions like LFR benchmark and weighted degree assortativity), and its optimized C core delivers the performance needed for large-scale network computations.\n\n::: {.column-margin}\n**Installing igraph**\n\n```bash\n# Using pip (with plotting support)\npip install igraph cairocffi\n\n# Using conda (recommended)\nconda install -c conda-forge igraph cairocffi\n\n# Alternative plotting backend\npip install igraph pycairo\n\n# For development version\npip install git+https://github.com/igraph/python-igraph.git\n```\n\nNote: igraph requires compiled C libraries and plotting needs `cairocffi` or `pycairo`. Use conda for easier installation.\n:::\n\nFor advanced users comfortable with `scipy`, the `csgraph` submodule provides an excellent alternative that leverages one of Python's most well-tested and optimized libraries. For example, `csgraph.shortest_path` and `csgraph.connected_components` offer high-performance implementations.\n\n![](../figs/scipy.jpg)\n\n\n### Create a graph\n\nLet us create a graph of 4 nodes and 4 edges. Our edge list is given by\n\n::: {#0c609252 .cell execution_count=1}\n``` {.python .cell-code}\nedge_list = [(0, 1), (1, 2), (0, 2), (0, 3)]\n```\n:::\n\n\n`igraph` has an object `Graph` that stores a graph and provides methods to manipulate and analyze the graph. To create a graph from an edge list, we can use the `add_edges` method.\n\n::: {#6df98d84 .cell execution_count=2}\n``` {.python .cell-code}\nimport igraph\n\ng = igraph.Graph() # Create an empty graph\ng.add_vertices(4) # Add 4 vertices\ng.add_edges(edge_list) # Add edges to the graph\n\n# Plot the graph\nigraph.plot(g, bbox=(150, 150), vertex_label=list(range(4)))\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n![](02-coding_files/figure-html/cell-3-output-1.svg){}\n:::\n:::\n\n\n### Shortest Paths\n\nLet's compute the paths between nodes 2 and 3.\n\n::: {#12aff202 .cell execution_count=3}\n``` {.python .cell-code}\ng.get_all_simple_paths(2, to=3)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n[[2, 0, 3], [2, 1, 0, 3]]\n```\n:::\n:::\n\n\nThis method enumerates all possible simple paths between two nodes. This is OK for small networks but quickly becomes impractical for larger networks, as the number of paths increases exponentially with the size of the network.\n\nOften, we are interested in the shortest path, which is the path with the smallest number of edges. The shortest path can be computed by using the `get_shortest_paths` method.\n\n::: {#5e61a930 .cell execution_count=4}\n``` {.python .cell-code}\ng.get_shortest_paths(2, to=3)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n[[2, 0, 3]]\n```\n:::\n:::\n\n\nNote that there can be multiple shortest paths between two nodes. If we are interested in the \"length\" instead of the path itself, there is a more efficient function `distances`.\n\n::: {#b3c5c122 .cell execution_count=5}\n``` {.python .cell-code}\ng.distances(2, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n[[2]]\n```\n:::\n:::\n\n\n### Connected Components\n\nIn the simple network above, we can see that for every pair of nodes, we can find a path connecting them. This is the definition of a connected graph. We can check this property for a given graph:\n\n::: {#4dbbef54 .cell execution_count=6}\n``` {.python .cell-code}\ncomponents = g.connected_components()\n```\n:::\n\n\nThe `components` is a special object called [VertexClustering](https://python.igraph.org/en/0.11.6/api/igraph.VertexClustering.html) in `igraph`.\nIt has the following useful functions and attributes:\n\n::: {#10b4051d .cell execution_count=7}\n``` {.python .cell-code}\nprint(\"membership: \", components.membership)  # the IDs of the component each node belongs to.\nprint(\"sizes: \", list(components.sizes()))  # the number of nodes in each component.\nprint(\"giant: \", components.giant())  # a subgraph of the largest connected component.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmembership:  [0, 0, 0, 0]\nsizes:  [4]\ngiant:  IGRAPH U--- 4 4 --\n+ edges:\n0--1 1--2 0--2 0--3\n```\n:::\n:::\n\n\n##### Exercise 01 üèãÔ∏è‚Äç‚ôÄÔ∏èüí™üß†\n\n1. Now, let us add two nodes that are not connected to the existing graph, and call `connected_components` again. üîó‚ûï\n\n2. Call `get_shortest_paths` between the two new nodes in different connected components. üõ£Ô∏èüîç\n\n3. Get the largest connected component. üåêüèÜ\n\n### Directed networks\nLet's extend these ideas about paths and connected components to directed graphs.\n\n::: {#3e7aa35d .cell execution_count=8}\n``` {.python .cell-code}\nedge_list =[(0, 1), (1, 2), (2, 1), (2, 3), (2, 5), (3, 1), (3, 4), (3, 5), (4, 5), (5, 3)]\ng = igraph.Graph(directed=True)\ng.add_vertices(6)\ng.add_edges(edge_list)\nigraph.plot(g, bbox=(250, 250), vertex_label=list(range(6)))\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n![](02-coding_files/figure-html/cell-9-output-1.svg){}\n:::\n:::\n\n\nIn directed graphs, edges and paths can be one-way. For instance, in our graph, you can go from node 0 to node 3, but not from 3 to 0.\n\n::: {#db200292 .cell execution_count=9}\n``` {.python .cell-code}\nprint(\"From 0 to 3\", g.get_all_simple_paths(0, to=3))\nprint(\"From 3 to 0\", g.get_all_simple_paths(3, to=0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFrom 0 to 3 [[0, 1, 2, 3], [0, 1, 2, 5, 3]]\nFrom 3 to 0 []\n```\n:::\n:::\n\n\nThe shortest path from 4 to 1 must take a longer route due to edge directions.\n\n::: {#c48c9490 .cell execution_count=10}\n``` {.python .cell-code}\ng.get_shortest_paths(4, 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n[[4, 5, 3, 1]]\n```\n:::\n:::\n\n\nDirected networks have two kinds of connected components.\n\n- **Strongly connected components:** Strongly connected means that there exists a direct path between every pair of nodes, i.e., that from any node to any other nodes while respecting the edge directionality.\n- **Weakly connected components:** Weakly connected means that there exists a path between every pair of nodes when ignoring the edge directionality.\n\n::: {#7ffc4293 .cell execution_count=11}\n``` {.python .cell-code}\nprint(list(g.connected_components(mode=\"strong\")))\nprint(list(g.connected_components(mode=\"weak\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[0], [1, 2, 3, 4, 5]]\n[[0, 1, 2, 3, 4, 5]]\n```\n:::\n:::\n\n\n## Clustering Coefficients\n\nNow let's see how to compute the clustering coefficients you learned about using igraph.\n\nLet's create a more interesting graph to demonstrate clustering:\n\n::: {#cbd5cc86 .cell execution_count=12}\n``` {.python .cell-code}\n# Create a graph with some triangles\nedges = [(0, 1), (0, 2), (1, 2),  # Triangle: 0-1-2\n         (0, 3), (3, 4), (3, 5),  # Node 3 with two neighbors (4,5)\n         (4, 5),                  # Triangle: 3-4-5\n         (1, 6), (6, 7)]          # Linear extension\n\ng_cluster = igraph.Graph()\ng_cluster.add_vertices(8)\ng_cluster.add_edges(edges)\n\n# Plot the graph\nigraph.plot(g_cluster, bbox=(300, 200), vertex_label=list(range(8)))\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n![](02-coding_files/figure-html/cell-13-output-1.svg){}\n:::\n:::\n\n\n### Local Clustering Coefficient\n\nThe `transitivity_local_undirected()` function computes the local clustering coefficient for each node, returning a list of float values (one per node). It returns `NaN` for nodes with degree < 2.\n\n::: {#df157e15 .cell execution_count=13}\n``` {.python .cell-code}\n# Local clustering coefficient for each node\nlocal_clustering = g_cluster.transitivity_local_undirected()\n\nprint(\"Local clustering coefficients:\")\nfor i, coeff in enumerate(local_clustering):\n    print(f\"Node {i}: {coeff:.3f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLocal clustering coefficients:\nNode 0: 0.333\nNode 1: 0.333\nNode 2: 1.000\nNode 3: 0.333\nNode 4: 1.000\nNode 5: 1.000\nNode 6: 0.000\nNode 7: nan\n```\n:::\n:::\n\n\n::: {.column-margin}\n**Understanding the values:**\n- 1.0 = All neighbors are connected (perfect local clustering)\n- 0.0 = No neighbors are connected\n- NaN = Node has degree < 2 (clustering undefined)\n:::\n\nAnalyze how clustering values relate to actual neighborhood connectivity:\n\n::: {#2b553f45 .cell execution_count=14}\n``` {.python .cell-code}\n# Analyze clustering for specific nodes\nfor node in range(g_cluster.vcount()):\n    neighbors = g_cluster.neighbors(node)\n    degree = len(neighbors)\n    clustering = local_clustering[node]\n\n    print(f\"Node {node}: degree={degree}, neighbors={neighbors}, clustering={clustering:.3f}\")\n\n    if degree >= 2:\n        # Count actual triangles\n        possible_edges = degree * (degree - 1) // 2\n        actual_edges = 0\n        for i in range(len(neighbors)):\n            for j in range(i + 1, len(neighbors)):\n                if g_cluster.are_adjacent(neighbors[i], neighbors[j]):\n                    actual_edges += 1\n        print(f\"  -> {actual_edges}/{possible_edges} neighbor pairs connected\")\n    print()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNode 0: degree=3, neighbors=[1, 2, 3], clustering=0.333\n  -> 1/3 neighbor pairs connected\n\nNode 1: degree=3, neighbors=[0, 2, 6], clustering=0.333\n  -> 1/3 neighbor pairs connected\n\nNode 2: degree=2, neighbors=[0, 1], clustering=1.000\n  -> 1/1 neighbor pairs connected\n\nNode 3: degree=3, neighbors=[0, 4, 5], clustering=0.333\n  -> 1/3 neighbor pairs connected\n\nNode 4: degree=2, neighbors=[3, 5], clustering=1.000\n  -> 1/1 neighbor pairs connected\n\nNode 5: degree=2, neighbors=[3, 4], clustering=1.000\n  -> 1/1 neighbor pairs connected\n\nNode 6: degree=2, neighbors=[1, 7], clustering=0.000\n  -> 0/1 neighbor pairs connected\n\nNode 7: degree=1, neighbors=[6], clustering=nan\n\n```\n:::\n:::\n\n\n### Average Local Clustering\n\nThe `transitivity_avglocal_undirected()` function computes the average local clustering coefficient directly, returning a single float value. It automatically ignores NaN values from low-degree nodes.\n\n::: {#b6a20362 .cell execution_count=15}\n``` {.python .cell-code}\n# Average local clustering (mean of local values)\navg_local_clustering = g_cluster.transitivity_avglocal_undirected()\nprint(f\"Average local clustering: {avg_local_clustering:.3f}\")\n\n# Verify by manual calculation\nimport numpy as np\nmanual_avg = np.nanmean(local_clustering)  # nanmean ignores NaN values\nprint(f\"Manual calculation: {manual_avg:.3f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAverage local clustering: 0.571\nManual calculation: 0.571\n```\n:::\n:::\n\n\n### Global Clustering Coefficient\n\nThe `transitivity_undirected()` function computes the global clustering coefficient (transitivity), returning a single float value.\n\n::: {#a8166263 .cell execution_count=16}\n``` {.python .cell-code}\n# Global clustering coefficient\nglobal_clustering = g_cluster.transitivity_undirected()\nprint(f\"Global clustering: {global_clustering:.3f}\")\n\n# Let's understand this calculation using supporting functions\n# list_triangles() returns all triangles in the graph\ntriangles_count = len(g_cluster.list_triangles())\nprint(f\"Number of triangles: {triangles_count}\")\nprint(f\"Triangles in graph: {g_cluster.list_triangles()}\")\n\n# Count connected triples (paths of length 2)\n# degree(node) returns the degree of a specific node\ntriples = 0\nfor node in range(g_cluster.vcount()):\n    degree = g_cluster.degree(node)\n    # Each node with degree d contributes d*(d-1)/2 triples\n    if degree >= 2:\n        triples += degree * (degree - 1) // 2\n\nprint(f\"Connected triples: {triples}\")\nprint(f\"Global clustering = 3 * {triangles_count} / {triples} = {3 * triangles_count / triples:.3f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGlobal clustering: 0.462\nNumber of triangles: 2\nTriangles in graph: [(0, 1, 2), (3, 4, 5)]\nConnected triples: 13\nGlobal clustering = 3 * 2 / 13 = 0.462\n```\n:::\n:::\n\n\n### Comparing Different Networks\n\nWe can use igraph's built-in network generators: `Graph.Full()` creates complete graphs, `Graph.Erdos_Renyi()` creates random graphs, and `Graph.Lattice()` creates regular lattices.\n\n::: {#0bc5d40f .cell execution_count=17}\n``` {.python .cell-code}\n# Create different network types for comparison\nimport numpy as np\n\n# 1. Complete graph (everyone connected to everyone)\nn_complete = 6\ng_complete = igraph.Graph.Full(n_complete)\n\n# 2. Random graph (Erd≈ës‚ÄìR√©nyi)\nn_random = 20\np_random = 0.2\ng_random = igraph.Graph.Erdos_Renyi(n_random, p_random)\n\n# 3. Regular ring lattice (each node connected to k nearest neighbors)\nn_ring = 20\nk_ring = 4\ng_ring = igraph.Graph.Lattice(dim=[n_ring], circular=True, nei=k_ring//2)\n\nnetworks = {\n    \"Complete\": g_complete,\n    \"Random\": g_random,\n    \"Ring Lattice\": g_ring,\n    \"Our Example\": g_cluster\n}\n\nprint(\"Clustering Comparison:\")\nprint(\"-\" * 60)\nprint(f\"{'Network':<15} {'Avg Local':<12} {'Global':<12} {'Nodes':<8} {'Edges':<8}\")\nprint(\"-\" * 60)\n\nfor name, graph in networks.items():\n    avg_local = graph.transitivity_avglocal_undirected()\n    global_clust = graph.transitivity_undirected()\n    nodes = graph.vcount()\n    edges = graph.ecount()\n\n    print(f\"{name:<15} {avg_local:<12.3f} {global_clust:<12.3f} {nodes:<8} {edges:<8}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClustering Comparison:\n------------------------------------------------------------\nNetwork         Avg Local    Global       Nodes    Edges   \n------------------------------------------------------------\nComplete        1.000        1.000        6        15      \nRandom          0.178        0.125        20       32      \nRing Lattice    0.500        0.500        20       40      \nOur Example     0.571        0.462        8        9       \n```\n:::\n:::\n\n\n### Small-World Network Example\n\nThe `Graph.Watts_Strogatz()` function creates small-world networks using the Watts-Strogatz model. The `average_path_length()` function computes the mean shortest path length across all node pairs.\n\n::: {#0b31a161 .cell execution_count=18}\n``` {.python .cell-code}\n# Create a small-world network (Watts-Strogatz model)\n# Start with ring lattice, then rewire some edges randomly\nn_ws = 30\nk_ws = 6\np_rewire = 0.1\n\ng_smallworld = igraph.Graph.Watts_Strogatz(dim=1, size=n_ws, nei=k_ws//2, p=p_rewire)\n\nprint(\"Small-World Network Analysis:\")\nprint(f\"Nodes: {g_smallworld.vcount()}, Edges: {g_smallworld.ecount()}\")\nprint(f\"Average local clustering: {g_smallworld.transitivity_avglocal_undirected():.3f}\")\nprint(f\"Global clustering: {g_smallworld.transitivity_undirected():.3f}\")\nprint(f\"Average path length: {g_smallworld.average_path_length():.3f}\")\n\n# Compare with random graph of same size and density\ng_random_compare = igraph.Graph.Erdos_Renyi(n_ws, g_smallworld.ecount() * 2 / (n_ws * (n_ws - 1)))\n\nprint(\"\\nCompared to random graph with same density:\")\nprint(f\"Random avg local clustering: {g_random_compare.transitivity_avglocal_undirected():.3f}\")\nprint(f\"Random global clustering: {g_random_compare.transitivity_undirected():.3f}\")\nprint(f\"Random average path length: {g_random_compare.average_path_length():.3f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSmall-World Network Analysis:\nNodes: 30, Edges: 90\nAverage local clustering: 0.361\nGlobal clustering: 0.319\nAverage path length: 2.149\n\nCompared to random graph with same density:\nRandom avg local clustering: 0.234\nRandom global clustering: 0.202\nRandom average path length: 2.048\n```\n:::\n:::\n\n\n## Exercise 02 üèãÔ∏è‚Äç‚ôÄÔ∏èüí™üß†\n\nLet's compute the average path length of a network from pre-existing data and check if how long on average it takes to go from any node to any other node.\n\n1. Select a network of your choice from [Netzschleuder](https://networks.skewed.de/). For convenience, choose a network of nodes less than 5000.\n2. Download the csv version of the data by clicking something like \"3KiB\" under `csv` column.\n3. Unzip the file and find \"edges.csv\", open it with a text editor to familiarize yourself with the format.\n4. Load the data using `pandas`.\n5. Get the source and target nodes from the data to create an edge list.\n6. Construct a graph from the edge list, either using `igraph` or `scipy`.\n7. Compute the average path length\n\n**Hint:** Finding all shortest paths is a qubic time operation with respect to the number of nodes, or simply put, it takes a long time to compute. So compute the \"estimate\" by sampling many pairs of nodes uniformly at random and computing the average path length.\n\n",
    "supporting": [
      "02-coding_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}