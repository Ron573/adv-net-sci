{
  "hash": "b1e03459cd90e660396b8b9080588226",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Advanced: Sparse Matrices for Large-Scale Networks\"\njupyter: python3\nexecute:\n    enabled: true\n---\n\n## The Scale Problem: From Königsberg to Global Networks\n\nModern networks have billions of nodes—far beyond Königsberg's 4 landmasses. A dense adjacency matrix for Earth's 8 billion people would require 512 exabytes of memory!\n\nReal networks are **sparse**: most node pairs aren't connected. Edge lists save memory but are inefficient for common operations like finding neighbors or computing degrees.\n\n::: {.column-margin}\n\nThink about the following operations:\n\n- **Degree**: How many friends does a person have?\n- **Neighbors**: Who are the friends of a person?\n\nThese operations are very common in network analysis. To do so, you need to go through **all the edges** in the network. This is not efficient, especially for large networks.\n\n:::\n\n## Solution: Sparse Matrices\n\n\nWe say a matrix is sparse if the matrix has only a handful of non-zero entries. This is indeed the case for most real-world networks. For such networks, we can use a special type of data type called **Compressed Sparse Row (CSR)** or **Compressed Sparse Column (CSC)** to represent the network. This is widely used in many network analysis tools and makes it possible to process large networks in practice.\n\n\nTo learn more, [here is a very good blog post by Matt Eding about efficient network representations](https://matteding.github.io/2019/04/25/sparse-matrices/).\n\n## SciPy's Compressed Sparse Row (CSR) Format\n\n\n::: {.column-margin}\n\nHere is a short video explaining the CSR format. Good one to watch if you are visual learner.\n\n<iframe width=\"250\" height=\"150\" src=\"https://www.youtube.com/embed/a2LXVFmGH_Q?si=F25ylU_vMHkQ0SP1\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\n\n:::\n\n\n\n\n::: {#fig-csr}\n\n![](https://matteding.github.io/images/csr.gif)\n\nA sparse matrix is a matrix with only a handful of non-zero entries represented with a compressed sparse frmat.\n\n:::\n\n\nCSR stores only non-zero matrix entries using three arrays, making it the standard for large-scale network analysis.\n\n### Understanding CSR Structure\n\nCSR format uses three arrays to represent a sparse matrix:\n\n1. **`data`**: Contains all non-zero values\n2. **`indices`**: Column indices of each non-zero value\n3. **`indptr`**: Row pointers indicating where each row starts in the data array\n\n::: {.column-margin}\n**Memory efficiency**: For a sparse matrix with $m$ non-zero entries out of $n^2$ total entries, CSR uses $O(m + n)$ memory instead of $O(n^2)$. For social networks where $m \\ll n^2$, this is a massive saving!\n:::\n\n::: {#96e87361 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy import sparse\n\n# Create a small example network\n# Let's represent the same 5-node network from earlier\ndense_matrix = np.array([\n    [0, 1, 1, 0, 0],  # Node 0 connects to nodes 1, 2\n    [1, 0, 1, 1, 0],  # Node 1 connects to nodes 0, 2, 3\n    [1, 1, 0, 0, 1],  # Node 2 connects to nodes 0, 1, 4\n    [0, 1, 0, 0, 1],  # Node 3 connects to nodes 1, 4\n    [0, 0, 1, 1, 0]   # Node 4 connects to nodes 2, 3\n])\n\n# Convert to CSR format\ncsr_matrix = sparse.csr_matrix(dense_matrix)\n\nprint(\"Dense matrix shape:\", dense_matrix.shape)\nprint(\"CSR matrix shape:\", csr_matrix.shape)\nprint(\"Non-zero entries:\", csr_matrix.nnz)\nprint(\"Memory saved: {:.1f}%\".format((1 - csr_matrix.nnz / dense_matrix.size) * 100))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDense matrix shape: (5, 5)\nCSR matrix shape: (5, 5)\nNon-zero entries: 12\nMemory saved: 52.0%\n```\n:::\n:::\n\n\n### Inside the CSR Format\n\nLet's examine the internal structure of our CSR matrix:\n\n::: {#9d2643a0 .cell execution_count=2}\n``` {.python .cell-code}\nprint(\"CSR internal arrays:\")\nprint(\"data (non-zero values):\", csr_matrix.data)\nprint(\"indices (column positions):\", csr_matrix.indices)\nprint(\"indptr (row pointers):\", csr_matrix.indptr)\n\n# Let's trace through how CSR works\nprint(\"\\nDecoding CSR structure:\")\nfor i in range(len(csr_matrix.indptr) - 1):\n    start = csr_matrix.indptr[i]\n    end = csr_matrix.indptr[i + 1]\n    row_data = csr_matrix.data[start:end]\n    row_indices = csr_matrix.indices[start:end]\n    print(f\"Row {i}: values {row_data} at columns {row_indices}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCSR internal arrays:\ndata (non-zero values): [1 1 1 1 1 1 1 1 1 1 1 1]\nindices (column positions): [1 2 0 2 3 0 1 4 1 4 2 3]\nindptr (row pointers): [ 0  2  5  8 10 12]\n\nDecoding CSR structure:\nRow 0: values [1 1] at columns [1 2]\nRow 1: values [1 1 1] at columns [0 2 3]\nRow 2: values [1 1 1] at columns [0 1 4]\nRow 3: values [1 1] at columns [1 4]\nRow 4: values [1 1] at columns [2 3]\n```\n:::\n:::\n\n\n::: {.callout-note title=\"How CSR Works\"}\nFor row $i$, the non-zero values are stored in `data[indptr[i]:indptr[i+1]]` with their column positions in `indices[indptr[i]:indptr[i+1]]`.\n\nFor example, if `indptr[0] = 0` and `indptr[1] = 2`, then row 0 has non-zero values `data[0:2]` at columns `indices[0:2]`.\n:::\n\n### Creating CSR Matrices from Edge Lists\n\nThe most common way to create network CSR matrices is from edge lists:\n\n::: {#aa883efb .cell execution_count=3}\n``` {.python .cell-code}\n# Define our network as an edge list\nedges = [\n    (0, 1), (0, 2),  # Node 0 connections\n    (1, 2), (1, 3),  # Node 1 connections\n    (2, 4),          # Node 2 connections\n    (3, 4)           # Node 3 connections\n]\n\n# Extract source and target nodes\nsources = [edge[0] for edge in edges]\ntargets = [edge[1] for edge in edges]\n\n# For undirected graphs, add reverse edges\nall_sources = sources + targets\nall_targets = targets + sources\n\n# Create data array (all ones for unweighted graph)\ndata_values = np.ones(len(all_sources))\n\n# Create CSR matrix directly from edge list\nn_nodes = 5\ncsr_from_edges = sparse.csr_matrix(\n    (data_values, (all_sources, all_targets)),\n    shape=(n_nodes, n_nodes)\n)\n\nprint(\"CSR from edge list:\")\nprint(csr_from_edges.toarray())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCSR from edge list:\n[[0. 1. 1. 0. 0.]\n [1. 0. 1. 1. 0.]\n [1. 1. 0. 0. 1.]\n [0. 1. 0. 0. 1.]\n [0. 0. 1. 1. 0.]]\n```\n:::\n:::\n\n\n### Efficient Operations with CSR\n\nCSR format enables efficient network operations that would be slow with dense matrices:\n\n::: {#b8bda54e .cell execution_count=4}\n``` {.python .cell-code}\n# Node degrees - sum each row\ndegrees = np.array(csr_matrix.sum(axis=1)).flatten()\nprint(\"Node degrees:\", degrees)\n\n# Find neighbors of node 1\nnode_1_neighbors = csr_matrix.indices[csr_matrix.indptr[1]:csr_matrix.indptr[2]]\nprint(\"Node 1 neighbors:\", node_1_neighbors)\n\n# Matrix multiplication for 2-hop paths\ntwo_hop_matrix = csr_matrix @ csr_matrix\nprint(\"Two-hop connections (shows paths of length 2):\")\nprint(two_hop_matrix.toarray())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNode degrees: [2 3 3 2 2]\nNode 1 neighbors: [0 2 3]\nTwo-hop connections (shows paths of length 2):\n[[2 1 1 1 1]\n [1 3 1 0 2]\n [1 1 3 2 0]\n [1 0 2 2 0]\n [1 2 0 0 2]]\n```\n:::\n:::\n\n\n::: {.column-margin}\n**Matrix multiplication**: `@` is the matrix multiplication operator in SciPy and NumPy. It is equivalent to `np.dot`.\n:::\n\n\n\n\n\n### Memory Comparison: Dense vs CSR\n\nLet's demonstrate the memory efficiency with a larger, sparser network:\n\n::: {#c22ccf09 .cell execution_count=5}\n``` {.python .cell-code}\n# Create a larger sparse network\nn = 1000\ndensity = 0.01  # Only 1% of edges exist\n\n# Generate random sparse matrix\nnp.random.seed(42)\nlarge_dense = sparse.random(n, n, density=density, format='csr')\n\nprint(f\"Network size: {n} × {n} = {n**2:,} potential edges\")\nprint(f\"Actual edges: {large_dense.nnz:,}\")\nprint(f\"Sparsity: {(1 - large_dense.nnz / (n*n)) * 100:.1f}% zeros\")\nprint(f\"CSR memory usage: ~{(large_dense.nnz * 2 + n) * 4 / 1024:.1f} KB\")\nprint(f\"Dense memory usage: ~{n*n * 4 / 1024:.1f} KB\")\nprint(f\"Memory savings: {((n*n * 4) - (large_dense.nnz * 2 + n) * 4) / (n*n * 4) * 100:.1f}%\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNetwork size: 1000 × 1000 = 1,000,000 potential edges\nActual edges: 10,000\nSparsity: 99.0% zeros\nCSR memory usage: ~82.0 KB\nDense memory usage: ~3906.2 KB\nMemory savings: 97.9%\n```\n:::\n:::\n\n\n### CSR for Network Analysis Algorithms\n\nCSR format integrates seamlessly with our previously defined functions:\n\n::: {#8fb7fb6e .cell execution_count=6}\n``` {.python .cell-code}\ndef is_walk_sparse(sequence, csr_matrix):\n    \"\"\"\n    Check if a sequence forms a valid walk using sparse CSR matrix.\n    \"\"\"\n    if len(sequence) < 2:\n        return True\n\n    sequence = np.array(sequence)\n    current_nodes = sequence[:-1]\n    next_nodes = sequence[1:]\n\n    # Use CSR matrix indexing - still works with advanced indexing!\n    edges_exist = csr_matrix[(current_nodes, next_nodes)]\n\n    # Convert sparse result to array and check\n    return np.all(edges_exist == 1)\n\n# Test with our CSR matrix\ntest_walk = [0, 1, 2, 4, 3, 1]\nprint(f\"Walk {test_walk} is valid: {is_walk_sparse(test_walk, csr_matrix)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWalk [0, 1, 2, 4, 3, 1] is valid: True\n```\n:::\n:::\n\n\n::: {.callout-tip title=\"Best Practices\"}\n**When to use CSR**:\n- Sparse matrices\n- Row-based operations (computing degrees, finding neighbors)\n- Matrix-vector multiplication\n\n**When to use dense matrices**:\n- Small networks\n- Dense networks\n- Frequent random access to individual entries\n:::\n\n::: {.column-margin}\n\nThere are several different sparse matrix formats such as COO, CSC, and LIL. If you are interested in learning more, you can check out [this blog post by Matt Eding](https://matteding.github.io/2019/04/25/sparse-matrices/). The following video is also a good one to watch.\n\n<iframe width=\"250\" height=\"150\" src=\"https://www.youtube.com/embed/SRgFScHYTy4?si=C75vxEnUjuLCerWF\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\n:::\n\n\n### Advanced CSR Features\n\n::: {#ab61bd1a .cell execution_count=7}\n``` {.python .cell-code}\n# Submatrix extraction - get connections for subset of nodes\nsubset_nodes = [0, 1, 2]\nsubgraph = csr_matrix[subset_nodes][:, subset_nodes]\nprint(\"Subgraph for nodes [0, 1, 2]:\")\nprint(subgraph.toarray())\n\n# Efficient boolean operations\n# Find nodes with degree > 2\nhigh_degree_nodes = np.where(degrees > 2)[0]\nprint(\"High degree nodes (> 2 connections):\", high_degree_nodes)\n\n# Matrix powers for path counting\npaths_3 = csr_matrix ** 3  # Counts 3-step paths\nprint(\"3-step path counts:\")\nprint(paths_3.toarray())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSubgraph for nodes [0, 1, 2]:\n[[0 1 1]\n [1 0 1]\n [1 1 0]]\nHigh degree nodes (> 2 connections): [1 2]\n3-step path counts:\n[[2 4 4 2 2]\n [4 2 6 5 1]\n [4 6 2 1 5]\n [2 5 1 0 4]\n [2 1 5 4 0]]\n```\n:::\n:::\n\n\nThe CSR format transforms network analysis from impossible to practical for large-scale networks. By storing only the essential information (non-zero connections), we can analyze networks with millions of nodes and billions of edges on standard hardware—something that would require exabytes of memory with dense matrices!\n\n",
    "supporting": [
      "04-advanced_files"
    ],
    "filters": [],
    "includes": {}
  }
}