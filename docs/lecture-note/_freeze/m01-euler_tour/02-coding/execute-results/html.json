{
  "hash": "412035c8abf2ccd1d7a6c9a98b5baf9d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Coding Networks in Python\njupyter: python3\nexecute:\n    enabled: true\n---\n\nNow that you understand the conceptual foundation from Euler's work, let's explore how to represent and analyze networks computationally. Given a network of any size, our goal is to create a function that can tell us whether the network has an Euler path or not.\n\n```python\ndef has_euler_path(A):\n    \"\"\"\n    Check if a graph has an Euler path based on node degrees.\n    Complete this function based on Euler's theorem.\n\n    A: network (assumed to be an adjacency matrix)\n    return: True if the network has an Euler path, False otherwise\n    \"\"\"\n    # Calculate degrees of all nodes\n    degrees = A.sum(axis=1)\n\n    # Count nodes with odd degrees\n    odd_degree_count = 0\n    for degree in degrees:\n        if degree % 2 != 0:\n            odd_degree_count += 1\n\n    # According to Euler's theorem, an Euler path exists if:\n    # 1. The graph is connected (we assume this for now)\n    # 2. Exactly 0 or 2 nodes have odd degrees\n    return odd_degree_count == 0 or odd_degree_count == 2\n```\n\nWe'll work through both general network representations and apply them specifically to the Königsberg bridge problem.\n\n## Network Representations: From Pictures to Data Structures\n\nConsider this network with 5 nodes and 6 edges:\n\n::: {#fig-small-graph}\n\n![](https://www.tandfonline.com/cms/asset/2820b951-1747-4621-802c-8d04263f106c/tcon_a_1707286_f0001_oc.jpg){width=200px}\n\nA small graph of five nodes and six edges.\n\n:::\n\nHow do we represent this graph in a format that a computer can understand and manipulate? Just as Euler needed to abstract Königsberg's bridges, we need data structures that capture the network's essential connectivity while enabling efficient analysis.\n\n::: {.column-margin}\nThe choice of representation can dramatically affect computational efficiency. For sparse networks (few edges), adjacency lists are memory-efficient. For dense networks or matrix operations, adjacency matrices are preferred.\n:::\n\nLet's explore three fundamental approaches that form the backbone of all network algorithms.\n\n### Edge Table: The Direct Approach\n\nThe edge table directly lists connections as pairs—the most intuitive way to store network data.\n\n::: {.column-margin}\nEdge tables are also called \"edge lists\" and are the most common format for storing large-scale network data in files. Social media platforms like Twitter and Facebook store billions of connections this way.\n:::\n\n::: {#9f7a6bdd .cell execution_count=1}\n``` {.python .cell-code}\n# Each row represents one edge (connection between two nodes)\nedges = [\n    (0, 1),  # Node 0 connects to Node 1\n    (0, 2),  # Node 0 connects to Node 2\n    (1, 2),  # Node 1 connects to Node 2\n    (1, 3),  # Node 1 connects to Node 3\n    (2, 4),  # Node 2 connects to Node 4\n    (3, 4)   # Node 3 connects to Node 4\n]\n\nprint(f\"Network has {len(edges)} edges\")\nprint(\"Edge list:\", edges)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNetwork has 6 edges\nEdge list: [(0, 1), (0, 2), (1, 2), (1, 3), (2, 4), (3, 4)]\n```\n:::\n:::\n\n\nThis mirrors how we'd naturally describe the network: \"Node 0 connects to nodes 1 and 2, node 1 connects to nodes 0, 2, and 3...\" It's the digital equivalent of Euler's original approach—simply listing which bridges connect which landmasses.\n\n### Adjacency List: The Neighborhood Map\n\nThe adjacency list stores each node's neighbors in a dictionary—like a social network where each person has a list of friends.\n\n::: {.column-margin}\nMost graph algorithms prefer adjacency lists because they allow fast iteration over a node's neighbors. This is crucial for algorithms like breadth-first search or computing clustering coefficients.\n:::\n\n::: {#e4415151 .cell execution_count=2}\n``` {.python .cell-code}\n# Define adjacency list directly as a dictionary\nneighbors = {\n    0: [1, 2],     # Node 0 connects to nodes 1 and 2\n    1: [0, 2, 3],  # Node 1 connects to nodes 0, 2, and 3\n    2: [0, 1, 4],  # Node 2 connects to nodes 0, 1, and 4\n    3: [1, 4],     # Node 3 connects to nodes 1 and 4\n    4: [2, 3]      # Node 4 connects to nodes 2 and 3\n}\n\nprint(\"Adjacency list representation:\")\nfor node, neighbor_list in neighbors.items():\n    print(f\"Node {node}: {neighbor_list}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAdjacency list representation:\nNode 0: [1, 2]\nNode 1: [0, 2, 3]\nNode 2: [0, 1, 4]\nNode 3: [1, 4]\nNode 4: [2, 3]\n```\n:::\n:::\n\n\n### Adjacency Matrix\n\nThe adjacency matrix uses a grid where entry (i,j) = 1 if nodes are connected—the mathematician's favorite representation.\n\n::: {.column-margin}\nAdjacency matrices enable powerful mathematical operations. Matrix multiplication reveals paths of different lengths, and eigenvalue analysis can uncover community structure. Google's PageRank algorithm fundamentally relies on matrix operations.\n:::\n\n::: {#58bd16c0 .cell execution_count=3}\n``` {.python .cell-code}\n# Define adjacency matrix directly\nimport numpy as np\n\nmatrix = np.array([\n    [0, 1, 1, 0, 0],  # Node 0 connects to nodes 1, 2\n    [1, 0, 1, 1, 0],  # Node 1 connects to nodes 0, 2, 3\n    [1, 1, 0, 0, 1],  # Node 2 connects to nodes 0, 1, 4\n    [0, 1, 0, 0, 1],  # Node 3 connects to nodes 1, 4\n    [0, 0, 1, 1, 0]   # Node 4 connects to nodes 2, 3\n])\n\nprint(\"Adjacency matrix:\")\nprint(matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAdjacency matrix:\n[[0 1 1 0 0]\n [1 0 1 1 0]\n [1 1 0 0 1]\n [0 1 0 0 1]\n [0 0 1 1 0]]\n```\n:::\n:::\n\n\nNotice the symmetry: if node i connects to node j, then node j connects to node i (for undirected networks). This symmetry disappears in directed networks, where relationships can be one-way.\n\n## Node Degrees\n\nThe degree of a node is the number of edges connected to it. This simple concept was central to Euler's proof—he realized that a valid bridge walk requires each landmass to have an even degree (except possibly the starting and ending points).\n\n::: {.column-margin}\nIn Königsberg, all four landmasses had odd degree, making the bridge walk impossible. This insight—that global properties emerge from local structure—remains fundamental to network analysis today.\n:::\n\nHere's how to compute degrees using each representation:\n\n### From Edge Table\n\nCount how many times each node appears in the edge list.\n\n::: {#e30fad39 .cell execution_count=4}\n``` {.python .cell-code}\n_degrees = [0] * 5\nfor node1, node2 in edges:\n    _degrees[node1] += 1\n    _degrees[node2] += 1\nprint(\"Degrees from edge list:\", _degrees)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDegrees from edge list: [2, 3, 3, 2, 2]\n```\n:::\n:::\n\n\n::: {.column-margin}\nWe increment the degree counter for both nodes in each edge because every edge contributes to two nodes' degrees. This is why the total degree always equals twice the number of edges.\n:::\n\n### From Adjacency List\n\nCount the length of each node's neighbor list—the most direct approach.\n\n::: {#46cb21ae .cell execution_count=5}\n``` {.python .cell-code}\n_degrees = [len(neighbors[i]) for i in range(5)]\nprint(\"Degrees from adjacency list:\", _degrees)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDegrees from adjacency list: [2, 3, 3, 2, 2]\n```\n:::\n:::\n\n\n### From Adjacency Matrix\n\nSum each row (or column) of the matrix—leveraging vectorized operations.\n\n::: {#6be2ce4c .cell execution_count=6}\n``` {.python .cell-code}\n_degrees = matrix.sum(axis=1)  # Sum rows\nprint(\"Degrees from adjacency matrix:\", _degrees)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDegrees from adjacency matrix: [2 3 3 2 2]\n```\n:::\n:::\n\n\n::: {.column-margin}\nFor undirected networks, row sums equal column sums. For directed networks, row sums give out-degree (outgoing connections) while column sums give in-degree (incoming connections).\n:::\n\n## Checking for Trails, Walks, and Paths\n\nNow that we understand how to represent networks and compute degrees, let's implement functions to verify whether a sequence of nodes represents a valid walk, trail, path, or cycle. These verification algorithms are essential for network analysis and implementing graph traversal algorithms.\n\n### Verifying a Walk\n\nA **walk** is the most permissive—we simply need to check that each consecutive pair of nodes is connected by an edge.\n\n::: {#76d2976c .cell execution_count=7}\n``` {.python .cell-code}\ndef is_walk(sequence, adjacency_matrix):\n    \"\"\"\n    Check if a sequence of nodes forms a valid walk.\n\n    Args:\n        sequence: List of node indices [v0, v1, v2, ...]\n        adjacency_matrix: 2D numpy array representing the graph\n\n    Returns:\n        bool: True if sequence is a valid walk, False otherwise\n    \"\"\"\n    if len(sequence) < 2:\n        return True  # Single node or empty sequence is trivially a walk\n\n    # Use NumPy vectorized operations for efficient edge checking\n    sequence = np.array(sequence)\n    current_nodes = sequence[:-1]  # All nodes except the last\n    next_nodes = sequence[1:]      # All nodes except the first\n\n    # Simple but slower: for loop version (slower but more explicit)\n    # for i, j in zip(current_nodes, next_nodes):\n    #     if adjacency_matrix[i, j] == 0:\n    #         return False\n    # return True\n\n    # Check all edges at once using advanced indexing\n    edges_exist = adjacency_matrix[current_nodes, next_nodes]\n\n    # All edges must exist (all values must be 1)\n    return np.all(edges_exist == 1)\n\n\n# Test with our sample network\ntest_sequence = [0, 1, 2, 4, 3, 1]\nprint(f\"Sequence {test_sequence} is a valid walk: {is_walk(test_sequence, matrix)}\")\n\n# Test an invalid walk\ninvalid_sequence = [0, 3]  # No direct edge between 0 and 3\nprint(f\"Sequence {invalid_sequence} is a valid walk: {is_walk(invalid_sequence, matrix)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSequence [0, 1, 2, 4, 3, 1] is a valid walk: True\nSequence [0, 3] is a valid walk: False\n```\n:::\n:::\n\n\n::: {.callout-note title = \"Mind the loops!\"}\nFor loops in Python is the notorious source of computational bottlenecks.\nAvoiding for loops significantly boosts the speed. In `is_walk`, we use one for loop but you can avoid it by using NumPy's advanced indexing, i.e., `adjacency_matrix[(current_nodes, next_nodes)]`. The way to think about this is that `(current_nodes, next_nodes)` is a tuple of indices, acting as a multi-dimensional index.\n`adjacency_matrix[(current_nodes, next_nodes)]` is 1d array of length the same as `current_nodes` and `next_nodes`. If the value is 0, then the edge does not exist. We can then check if all the values are not zero.\n:::\n\n### Verifying a Trail\n\nA **trail** requires all edges to be distinct, but nodes can repeat.\n\n::: {#8a0eeda8 .cell execution_count=8}\n``` {.python .cell-code}\ndef is_trail(sequence, adjacency_matrix):\n    \"\"\"\n    Check if a sequence of nodes forms a valid trail.\n\n    Args:\n        sequence: List of node indices [v0, v1, v2, ...]\n        adjacency_matrix: 2D numpy array representing the graph\n\n    Returns:\n        bool: True if sequence is a valid trail, False otherwise\n    \"\"\"\n    if not is_walk(sequence, adjacency_matrix):\n        return False  # Must be a valid walk first\n\n    if len(sequence) < 2:\n        return True\n\n    # Convert to numpy for efficient operations\n    sequence = np.array(sequence)\n    current_nodes = sequence[:-1]\n    next_nodes = sequence[1:]\n\n    # Use complex numbers to represent edges!\n    # For undirected graph: smaller_node + 1j * larger_node\n    # This ensures edge (1,2) and (2,1) both become 1+2j\n    edge_starts = np.minimum(current_nodes, next_nodes)  # Real part\n    edge_ends = np.maximum(current_nodes, next_nodes)    # Imaginary part\n    complex_edges = edge_starts + 1j * edge_ends\n\n    # Check uniqueness directly with NumPy\n    return len(complex_edges) == len(np.unique(complex_edges))\n\n    # Alternative: Original for loop version (slower but more explicit)\n    # used_edges = set()\n    # for i in range(len(sequence) - 1):\n    #     current_node = sequence[i]\n    #     next_node = sequence[i + 1]\n    #     # Create edge tuple (smaller index first for undirected graphs)\n    #     edge = (min(current_node, next_node), max(current_node, next_node))\n    #     if edge in used_edges:\n    #         return False  # Edge already used\n    #     used_edges.add(edge)\n    # return True\n\n# Test trail verification\ntrail_sequence = [0, 1, 3, 4, 2]\nprint(f\"Sequence {trail_sequence} is a valid trail: {is_trail(trail_sequence, matrix)}\")\n\n# Test invalid trail (reuses edge 1-2)\ninvalid_trail = [0, 1, 2, 1, 3]\nprint(f\"Sequence {invalid_trail} is a valid trail: {is_trail(invalid_trail, matrix)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSequence [0, 1, 3, 4, 2] is a valid trail: True\nSequence [0, 1, 2, 1, 3] is a valid trail: False\n```\n:::\n:::\n\n\n::: {.column-margin}\n`np.unique` is a powerful function that can handle complex numbers natively.\n:::\n\n::: {.callout-note title=\"Complex Numbers for Edge Representation\"}\nWe use complex numbers to represent edges! Each edge becomes `smaller_node + 1j * larger_node`. For example, edge (1,2) becomes `1+2j`, and edge (2,1) also becomes `1+2j` (normalized).\nThink of complex numbers as natural 2D coordinates for representing node pairs.\n:::\n\n### Verifying a Path\n\nA **path** requires all nodes (except possibly start/end for cycles) to be distinct.\n\n::: {#093cab78 .cell execution_count=9}\n``` {.python .cell-code}\ndef is_path(sequence, adjacency_matrix):\n    \"\"\"\n    Check if a sequence of nodes forms a valid path.\n\n    Args:\n        sequence: List of node indices [v0, v1, v2, ...]\n        adjacency_matrix: 2D numpy array representing the graph\n        allow_cycle: If True, allows start node = end node (cycle)\n\n    Returns:\n        bool: True if sequence is a valid path, False otherwise\n    \"\"\"\n    if not is_walk(sequence, adjacency_matrix):\n        return False  # Must be a valid walk first\n\n    if len(sequence) < 2:\n        return True\n\n    sequence = np.array(sequence)\n\n    return len(sequence) == len(np.unique(sequence))\n\n# Test path verification\npath_sequence = [0, 1, 3, 4]\nprint(f\"Sequence {path_sequence} is a valid path: {is_path(path_sequence, matrix)}\")\n\n# Test invalid path (repeats node 1)\ninvalid_path = [0, 1, 2, 1, 3]\nprint(f\"Sequence {invalid_path} is a valid path: {is_path(invalid_path, matrix)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSequence [0, 1, 3, 4] is a valid path: True\nSequence [0, 1, 2, 1, 3] is a valid path: False\n```\n:::\n:::\n\n\n## Connected Components\n\nConnected components are the maximal sets of nodes where every pair is connected by some path. For Euler path analysis, this is crucial—an Euler path can only exist if the entire graph forms a single connected component (or if we're only considering the component containing edges).\n\n::: {.column-margin}\nIn Königsberg, all landmasses were connected by bridges, forming one component. If one landmass were isolated, no Euler path could traverse the entire city. This connectivity requirement is the first condition in Euler's theorem.\n:::\n\n### The Algorithm: Depth-First Search\n\nA simple way to find connected components is to systematically explore from each unvisited node using depth-first search (DFS). This works because DFS can only reach nodes that are connected through some path.\n\n**Algorithm steps:**\n1. Mark all nodes as unvisited\n2. For each unvisited node:\n   - Start a new component\n   - Use DFS to explore all reachable nodes\n   - Add all reached nodes to this component\n3. Return the list of components\n\n::: {#fd9d189e .cell execution_count=10}\n``` {.python .cell-code}\ndef connected_components(adjacency_matrix):\n    \"\"\"\n    Find connected components in an undirected graph using adjacency matrix.\n\n    Args:\n        adjacency_matrix: 2D numpy array (square)\n\n    Returns:\n        List of lists, each sublist contains node indices in a component\n    \"\"\"\n    import numpy as np\n    n = adjacency_matrix.shape[0]\n    visited = np.zeros(n, dtype=bool)\n    components = []\n\n    def dfs(node, component):\n        \"\"\"Depth-first search to explore a component\"\"\"\n        # Mark the current node as visited and add it to current component\n        visited[node] = True\n        component.append(node)\n\n        # Find all neighbors of the current node using vectorized operation\n        neighbors = np.where(adjacency_matrix[node] > 0)[0]\n\n        # Recursively visit unvisited neighbors\n        for neighbor in neighbors:\n            if not visited[neighbor]:\n                dfs(neighbor, component)\n\n    # Main algorithm: iterate through all nodes\n    for v in range(n):\n        if not visited[v]:  # Found a new component\n            component = []\n            dfs(v, component)  # Explore entire component\n            components.append(component)\n\n    return components\n\n# Test with our original connected graph\nprint(\"Testing with connected graph:\")\ncomponents = connected_components(matrix)\nprint(\"Connected components:\", components)\nprint(f\"Number of components: {len(components)}\")\n\n# Create a disconnected graph to demonstrate multiple components\ndisconnected_matrix = np.array([\n    [0, 1, 0, 0, 0],  # Component 1: nodes 0,1,2\n    [1, 0, 1, 0, 0],\n    [0, 1, 0, 0, 0],\n    [0, 0, 0, 0, 1],  # Component 2: nodes 3,4\n    [0, 0, 0, 1, 0]\n])\n\nprint(\"\\nTesting with disconnected graph:\")\ndisconnected_components = connected_components(disconnected_matrix)\nprint(\"Connected components:\", disconnected_components)\nprint(f\"Number of components: {len(disconnected_components)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTesting with connected graph:\nConnected components: [[0, np.int64(1), np.int64(2), np.int64(4), np.int64(3)]]\nNumber of components: 1\n\nTesting with disconnected graph:\nConnected components: [[0, np.int64(1), np.int64(2)], [3, np.int64(4)]]\nNumber of components: 2\n```\n:::\n:::\n\n\n::: {.column-margin}\nDFS naturally explores as \"deep\" as possible before backtracking. This makes it perfect for component finding because once we start exploring from a node, we want to find ALL nodes in its component before moving to the next component.\n:::\n\n### Improved Euler Path Checker\n\nNow we can enhance our Euler path function to include the connectivity requirement:\n\n::: {#44e501fc .cell execution_count=11}\n``` {.python .cell-code}\ndef has_euler_path_complete(adjacency_matrix):\n    \"\"\"\n    Complete Euler path checker with connectivity verification.\n\n    Args:\n        adjacency_matrix: 2D numpy array representing the graph\n\n    Returns:\n        bool: True if graph has an Euler path, False otherwise\n    \"\"\"\n    # Check if graph is connected (ignoring isolated nodes)\n    components = connected_components(adjacency_matrix)\n\n    # Find nodes with at least one edge (degree > 0)\n    degrees = adjacency_matrix.sum(axis=1)\n    non_isolated_nodes = np.where(degrees > 0)[0]\n\n    if len(non_isolated_nodes) == 0:\n        return True  # Empty graph has Euler path trivially\n\n    # Check if all non-isolated nodes are in the same component\n    component_with_edges = None\n    for component in components:\n        if non_isolated_nodes[0] in component:\n            component_with_edges = set(component)\n            break\n\n    # All nodes with edges must be in the same component\n    if not all(node in component_with_edges for node in non_isolated_nodes):\n        return False  # Graph is disconnected\n\n    # Count nodes with odd degrees (among non-isolated nodes)\n    non_isolated_degrees = degrees[non_isolated_nodes]\n    odd_degree_count = np.sum(non_isolated_degrees % 2)\n\n    # Euler's theorem: exactly 0 or 2 nodes with odd degrees\n    return odd_degree_count == 0 or odd_degree_count == 2\n\n# Test with connected graph\nprint(\"Connected graph has Euler path:\", has_euler_path_complete(matrix))\n\n# Test with disconnected graph\nprint(\"Disconnected graph has Euler path:\", has_euler_path_complete(disconnected_matrix))\n\n# Test the classic Königsberg bridge problem (all odd degrees)\nkonigsberg = np.array([\n    [0, 1, 1, 1],  # Landmass 0 connects to all others (degree 3)\n    [1, 0, 1, 1],  # Landmass 1 connects to all others (degree 3)\n    [1, 1, 0, 1],  # Landmass 2 connects to all others (degree 3)\n    [1, 1, 1, 0]   # Landmass 3 connects to all others (degree 3)\n])\nprint(\"Königsberg bridges have Euler path:\", has_euler_path_complete(konigsberg))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nConnected graph has Euler path: True\nDisconnected graph has Euler path: False\nKönigsberg bridges have Euler path: False\n```\n:::\n:::\n\n\n::: {.callout-important title=\"Why Connectivity Matters\"}\nEven if a graph has exactly 2 odd-degree nodes, an Euler path cannot exist if those nodes are in different connected components. You cannot traverse from one component to another without existing edges, making a single continuous path impossible.\n:::\n\n## Summary\n\nYou now understand how to:\n\n1. **Represent networks** using edge lists, adjacency lists, and adjacency matrices—each optimized for different computational tasks\n2. **Compute node degrees** efficiently using vectorized operations across all representations\n3. **Verify walks, trails, paths, and cycles** with robust algorithms that handle edge cases\n4. **Find connected components** using depth-first search to identify disconnected parts of networks\n5. **Apply Euler's theorem completely** by checking both degree conditions and connectivity requirements\n\n::: {.callout-tip title=\"Computational Complexity\"}\n- Degree calculation: O(n²) for adjacency matrix, O(E) for edge list, O(1) for adjacency list\n- Walk verification: O(k) where k is sequence length\n- Connected components: O(n²) for adjacency matrix representation using DFS\n- Complete Euler path check: O(n²) dominated by connectivity check\n:::\n\nThese fundamental algorithms form the building blocks for more sophisticated network analysis. Whether you're analyzing social networks, transportation systems, or molecular structures, these core concepts of connectivity, traversal, and structural analysis remain essential.\n\nFrom Euler's original insight about Königsberg's bridges to modern network science, the mathematical principles you've implemented here continue to solve real-world problems—from GPS routing algorithms to understanding brain connectivity patterns.\n\n",
    "supporting": [
      "02-coding_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}