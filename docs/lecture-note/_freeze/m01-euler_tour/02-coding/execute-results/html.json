{
  "hash": "261d9f559617b8210e9f324774a6adfd",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Coding Networks in Python\nfilters:\n  - marimo-team/marimo\n  - tikz\ntikz:\n  cache: false\n  save-tex: true  # Enable saving intermediate .tex files\n  tex-dir: tikz-tex  # Optional: Specify directory to save .tex files\njupyter: python3\n---\n\nNow that you understand the conceptual foundation from Euler's work, let's explore how to represent and analyze networks computationally. We'll work through both general network representations and apply them specifically to the Königsberg bridge problem.\n\n## How to Run This Notebook\n\n::: {.callout-tip}\n## Running with Marimo\n\nTo run the notebook, first download it as a .py file, then use the following steps:\n\n1. **Install marimo:**\n   ```bash\n   pip install marimo\n   ```\n\n2. **Install uv** (a Python package manager that automatically manages dependencies):\n   ```bash\n   pip install uv\n   ```\n\n3. **Launch the notebook:**\n   ```bash\n   marimo edit --sandbox <filename>.py\n   ```\n\nThe notebook will open in your web browser. All necessary packages will be installed automatically in a dedicated virtual environment managed by uv.\n:::\n\n## Network Representations: From Pictures to Data Structures\n\nConsider this network with 5 nodes and 6 edges:\n\n\n![](https://www.tandfonline.com/cms/asset/2820b951-1747-4621-802c-8d04263f106c/tcon_a_1707286_f0001_oc.jpg)\n\nHow do we represent this graph in a format that a computer can understand and manipulate? Just as Euler needed to abstract Königsberg's bridges, we need data structures that capture the network's essential connectivity while enabling efficient analysis.\n\n::: {.column-margin}\nThe choice of representation can dramatically affect computational efficiency. For sparse networks (few edges), adjacency lists are memory-efficient. For dense networks or matrix operations, adjacency matrices are preferred.\n:::\n\nLet's explore three fundamental approaches that form the backbone of all network algorithms.\n\n### Edge Table: The Direct Approach\n\nThe edge table directly lists connections as pairs—the most intuitive way to store network data.\n\n::: {.column-margin}\nEdge tables are also called \"edge lists\" and are the most common format for storing large-scale network data in files. Social media platforms like Twitter and Facebook store billions of connections this way.\n:::\n\n::: {#17568ee1 .cell execution_count=1}\n``` {.python .cell-code}\n# Each row represents one edge (connection between two nodes)\nedges = [\n    (0, 1),  # Node 0 connects to Node 1\n    (0, 2),  # Node 0 connects to Node 2\n    (1, 2),  # Node 1 connects to Node 2\n    (1, 3),  # Node 1 connects to Node 3\n    (2, 4),  # Node 2 connects to Node 4\n    (3, 4)   # Node 3 connects to Node 4\n]\n\nprint(f\"Network has {len(edges)} edges\")\nprint(\"Edge list:\", edges)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNetwork has 6 edges\nEdge list: [(0, 1), (0, 2), (1, 2), (1, 3), (2, 4), (3, 4)]\n```\n:::\n:::\n\n\nThis mirrors how we'd naturally describe the network: \"Node 0 connects to nodes 1 and 2, node 1 connects to nodes 0, 2, and 3...\" It's the digital equivalent of Euler's original approach—simply listing which bridges connect which landmasses.\n\n### Adjacency List: The Neighborhood Map\n\nThe adjacency list stores each node's neighbors in a dictionary—like a social network where each person has a list of friends.\n\n::: {.column-margin}\nMost graph algorithms prefer adjacency lists because they allow fast iteration over a node's neighbors. This is crucial for algorithms like breadth-first search or computing clustering coefficients.\n:::\n\n::: {#68a89018 .cell execution_count=2}\n``` {.python .cell-code}\n# Define adjacency list directly as a dictionary\nneighbors = {\n    0: [1, 2],     # Node 0 connects to nodes 1 and 2\n    1: [0, 2, 3],  # Node 1 connects to nodes 0, 2, and 3\n    2: [0, 1, 4],  # Node 2 connects to nodes 0, 1, and 4\n    3: [1, 4],     # Node 3 connects to nodes 1 and 4\n    4: [2, 3]      # Node 4 connects to nodes 2 and 3\n}\n\nprint(\"Adjacency list representation:\")\nfor node, neighbor_list in neighbors.items():\n    print(f\"Node {node}: {neighbor_list}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAdjacency list representation:\nNode 0: [1, 2]\nNode 1: [0, 2, 3]\nNode 2: [0, 1, 4]\nNode 3: [1, 4]\nNode 4: [2, 3]\n```\n:::\n:::\n\n\n### Adjacency Matrix: The Mathematical Grid\n\nThe adjacency matrix uses a grid where entry (i,j) = 1 if nodes are connected—the mathematician's favorite representation.\n\n::: {.column-margin}\nAdjacency matrices enable powerful mathematical operations. Matrix multiplication reveals paths of different lengths, and eigenvalue analysis can uncover community structure. Google's PageRank algorithm fundamentally relies on matrix operations.\n:::\n\n::: {#325e5b53 .cell execution_count=3}\n``` {.python .cell-code}\n# Define adjacency matrix directly\nimport numpy as np\n\nmatrix = np.array([\n    [0, 1, 1, 0, 0],  # Node 0 connects to nodes 1, 2\n    [1, 0, 1, 1, 0],  # Node 1 connects to nodes 0, 2, 3\n    [1, 1, 0, 0, 1],  # Node 2 connects to nodes 0, 1, 4\n    [0, 1, 0, 0, 1],  # Node 3 connects to nodes 1, 4\n    [0, 0, 1, 1, 0]   # Node 4 connects to nodes 2, 3\n])\n\nprint(\"Adjacency matrix:\")\nprint(matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAdjacency matrix:\n[[0 1 1 0 0]\n [1 0 1 1 0]\n [1 1 0 0 1]\n [0 1 0 0 1]\n [0 0 1 1 0]]\n```\n:::\n:::\n\n\nNotice the symmetry: if node i connects to node j, then node j connects to node i (for undirected networks). This symmetry disappears in directed networks, where relationships can be one-way.\n\n## Counting Node Degrees: Euler's Key Insight\n\nThe degree of a node is the number of edges connected to it. This simple concept was central to Euler's proof—he realized that a valid bridge walk requires each landmass to have an even degree (except possibly the starting and ending points).\n\n::: {.column-margin}\nIn Königsberg, all four landmasses had odd degree, making the bridge walk impossible. This insight—that global properties emerge from local structure—remains fundamental to network analysis today.\n:::\n\nHere's how to compute degrees using each representation:\n\n### From Edge Table: Counting Appearances\n\nCount how many times each node appears in the edge list.\n\n::: {#fdfe86a4 .cell execution_count=4}\n``` {.python .cell-code}\n_degrees = [0] * 5\nfor node1, node2 in edges:\n    _degrees[node1] += 1\n    _degrees[node2] += 1\nprint(\"Degrees from edge list:\", _degrees)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDegrees from edge list: [2, 3, 3, 2, 2]\n```\n:::\n:::\n\n\n::: {.column-margin}\nWe increment the degree counter for both nodes in each edge because every edge contributes to two nodes' degrees. This is why the total degree always equals twice the number of edges.\n:::\n\n### From Adjacency List: Counting Friends\n\nCount the length of each node's neighbor list—the most direct approach.\n\n::: {#c893849a .cell execution_count=5}\n``` {.python .cell-code}\n_degrees = [len(neighbors[i]) for i in range(5)]\nprint(\"Degrees from adjacency list:\", _degrees)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDegrees from adjacency list: [2, 3, 3, 2, 2]\n```\n:::\n:::\n\n\n### From Adjacency Matrix: Linear Algebra Power\n\nSum each row (or column) of the matrix—leveraging vectorized operations.\n\n::: {#bbbcbbce .cell execution_count=6}\n``` {.python .cell-code}\n_degrees = matrix.sum(axis=1)  # Sum rows\nprint(\"Degrees from adjacency matrix:\", _degrees)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDegrees from adjacency matrix: [2 3 3 2 2]\n```\n:::\n:::\n\n\n::: {.column-margin}\nFor undirected networks, row sums equal column sums. For directed networks, row sums give out-degree (outgoing connections) while column sums give in-degree (incoming connections).\n:::\n\n## The Königsberg Bridge Problem in Code\n\n![](https://towardsdatascience.com/wp-content/uploads/2024/05/15n0gkvpktkGYtAase5oYuw-1.png)\n\nNow let's apply these concepts to the original Königsberg bridge problem. The network has 4 nodes (landmasses) and 7 edges (bridges).\n\n### Representing the Königsberg Network\n\nThe Königsberg graph can be represented by a list of edges. Note that some bridges appear twice because there were multiple bridges between the same landmasses.\n\n::: {#b02ed3db .cell execution_count=7}\n``` {.python .cell-code}\n# Königsberg bridge network\nkoenigsberg_edges = [(0,1), (0, 1), (0, 3), (1, 2), (1, 2), (1, 3), (2, 3)]\nprint(\"Königsberg edges:\", koenigsberg_edges)\nprint(\"Total bridges:\", len(koenigsberg_edges))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKönigsberg edges: [(0, 1), (0, 1), (0, 3), (1, 2), (1, 2), (1, 3), (2, 3)]\nTotal bridges: 7\n```\n:::\n:::\n\n\n### Building the Adjacency Matrix\n\nLet's create the adjacency matrix for the Königsberg network:\n\n::: {#efbc8954 .cell execution_count=8}\n``` {.python .cell-code}\n# Create adjacency matrix for Königsberg\nA = np.zeros((4, 4))\nfor i, j in koenigsberg_edges:\n    A[i][j] += 1\n    A[j][i] += 1\n\nprint(\"Königsberg adjacency matrix:\")\nprint(A.astype(int))  # Convert to int for cleaner display\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKönigsberg adjacency matrix:\n[[0 2 0 1]\n [2 0 2 1]\n [0 2 0 1]\n [1 1 1 0]]\n```\n:::\n:::\n\n\n::: {.callout-note}\n\nIn the Königsberg graph, the edges are *undirected*, meaning edge (i,j) is the same as edge (j,i), which is why we increment both entries $(i,j)$ and $(j,i)$ in the for loop. If the edges are *directed*, we treat (i,j) and (j,i) as two different edges, and increment only (i,j).\n\n:::\n\n### Analyzing the Network\n\nLet's use our computational tools to analyze the Königsberg network:\n\n::: {#4246d794 .cell execution_count=9}\n``` {.python .cell-code}\n# Count total edges\n_total_edges = np.sum(A) / 2  # Divide by 2 because each edge is counted twice\nprint(f\"Total edges: {_total_edges}\")\n\n# Compute node degrees\ndegrees = np.sum(A, axis=1)\nprint(\"Node degrees:\", degrees.astype(int))\n\n# Check for odd degrees\n_is_odd = degrees % 2 == 1\n_num_odd_nodes = np.sum(_is_odd)\nprint(f\"Nodes with odd degree: {_num_odd_nodes}\")\nprint(f\"Odd degree nodes: {np.where(_is_odd)[0]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal edges: 7.0\nNode degrees: [3 5 3 3]\nNodes with odd degree: 4\nOdd degree nodes: [0 1 2 3]\n```\n:::\n:::\n\n\n::: {.callout-important}\n\nThe number of edges connected to a node is called the ***degree*** of the node.\n\n:::\n\n### Applying Euler's Theorem Computationally\n\nNow we can implement Euler's theorem as code:\n\n::: {#3f2fa6b7 .cell execution_count=10}\n``` {.python .cell-code}\ndef has_euler_path(degrees):\n    \"\"\"\n    Check if a graph has an Euler path based on node degrees.\n\n    Euler's theorem: A graph has an Euler path if and only if:\n    - All nodes have even degree, OR\n    - Exactly two nodes have odd degree\n    \"\"\"\n    odd_count = np.sum(degrees % 2 == 1)\n\n    if odd_count == 0:\n        return True, \"Euler circuit exists (all nodes have even degree)\"\n    elif odd_count == 2:\n        return True, \"Euler path exists (exactly 2 nodes have odd degree)\"\n    else:\n        return False, f\"No Euler path ({odd_count} nodes have odd degree)\"\n\n# Test on Königsberg\n_has_path, _reason = has_euler_path(degrees)\nprint(f\"Königsberg network: {_has_path}\")\nprint(f\"Reason: {_reason}\")\n\n# Test on our simple example network\n_simple_degrees = matrix.sum(axis=1)\n_has_path_simple, _reason_simple = has_euler_path(_simple_degrees)\nprint(f\"\\nSimple network: {_has_path_simple}\")\nprint(f\"Reason: {_reason_simple}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKönigsberg network: False\nReason: No Euler path (4 nodes have odd degree)\n\nSimple network: True\nReason: Euler path exists (exactly 2 nodes have odd degree)\n```\n:::\n:::\n\n\n::: {.callout-tip}\n\nThe `np.sum(A, axis = 1)` computes the row sum of `A`. Alternatively, `np.sum(A, axis = 0)` computes the column sum of `A`.\nCheck out the numpy [documentation](https://numpy.org/doc/stable/reference/generated/numpy.sum.html) for more details.\n\n:::\n\n\n## Summary: From Euler's Insight to Modern Computation\n\nYou now understand how to:\n\n1. **Represent networks** using edge lists, adjacency lists, and adjacency matrices\n2. **Convert between representations** as needed for different algorithms\n3. **Compute node degrees** efficiently using different data structures\n4. **Apply Euler's theorem** computationally to determine if Euler paths exist\n5. **Handle large networks** using sparse matrix representations\n\nThese computational tools, built on Euler's 300-year-old insight, now power everything from GPS navigation systems to social media algorithms. The fundamental principle remains the same: ***abstract the essential structure, then apply mathematical reasoning to solve concrete problems***.\n\nThe next step is to practice these concepts with real network data and explore more advanced network analysis techniques!\n\n",
    "supporting": [
      "02-coding_files"
    ],
    "filters": [],
    "includes": {}
  }
}