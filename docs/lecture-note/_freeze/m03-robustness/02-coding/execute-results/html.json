{
  "hash": "5a27a7fff4f2d92975a4f45fd83a76e3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Coding - Network Robustness Analysis\"\njupyter: advnetsci\nexecute:\n    enabled: true\n---\n\n## Key robustness concepts in `igraph`\n\nNetwork robustness analysis focuses on understanding how networks behave when nodes or edges are removed, whether through random failures or targeted attacks. The Python ecosystem provides powerful tools for analyzing these phenomena:\n\n- [igraph](https://igraph.org/python/) - comprehensive network analysis with robust algorithms for connectivity analysis\n- [scipy.sparse.csgraph](https://docs.scipy.org/doc/scipy/reference/sparse.csgraph.html) - efficient connected component algorithms for large networks\n- [networkx](https://networkx.org/) - alternative approach with different robustness metrics\n\nThroughout this analysis, we'll use `igraph` for its reliable implementations and performance advantages when working with connectivity measures and component analysis.\n\n::: {.column-margin}\n**Installing igraph**\n\n```bash\n# Using pip (with plotting support)\npip install igraph cairocffi\n\n# Using conda (recommended)\nconda install -c conda-forge igraph cairocffi\n\n# Alternative plotting backend\npip install igraph pycairo\n```\n\nNote: igraph requires compiled C libraries and plotting needs `cairocffi` or `pycairo`. Use conda for easier installation.\n:::\n\nFor advanced users comfortable with `scipy`, the `csgraph` submodule provides an excellent alternative that leverages one of Python's most well-tested and optimized libraries. For example, `csgraph.shortest_path` and `csgraph.connected_components` offer high-performance implementations.\n\n### Create a robust test network\n\nLet's start by creating a network using the famous Zachary's karate club, which provides an excellent testbed for robustness analysis:\n\n::: {#0f31b4fa .cell execution_count=1}\n``` {.python .cell-code}\nimport igraph\n\n# Create the famous Zachary's karate club network\ng = igraph.Graph.Famous('Zachary')\n\n# Visualize the network\nigraph.plot(g, bbox=(300, 200), vertex_size=20, vertex_label=list(range(g.vcount())))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](02-coding_files/figure-html/cell-2-output-1.svg){}\n:::\n:::\n\n\n::: {.column-margin}\n**About Zachary's Karate Club**\n\n[Zachary's karate club](https://en.wikipedia.org/wiki/Zachary%27s_karate_club) is a famous network of 34 members of a karate club documenting friendships between members. The network is undirected and originally unweighted, making it an excellent testbed for robustness analysis.\n:::\n\n### Connected Components\n\nBefore analyzing robustness, let's understand how to measure network connectivity. In network analysis, we often need to identify connected components:\n\n::: {#a41bda85 .cell execution_count=2}\n``` {.python .cell-code}\ncomponents = g.connected_components()\nprint(\"Number of components:\", len(components))\nprint(\"Component sizes:\", list(components.sizes()))\nprint(\"Largest component size:\", components.giant().vcount())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of components: 1\nComponent sizes: [34]\nLargest component size: 34\n```\n:::\n:::\n\n\nThe connectivity of a network is typically measured as the fraction of nodes in the largest connected component:\n\n::: {#82d7273d .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\n\ndef network_connectivity(graph, original_size=None):\n    \"\"\"Calculate network connectivity as fraction of nodes in largest component\"\"\"\n    if original_size is None:\n        original_size = graph.vcount()\n\n    if graph.vcount() == 0:\n        return 0.0\n\n    components = graph.connected_components()\n    return max(components.sizes()) / original_size\n\n# Test the function\nconnectivity = network_connectivity(g)\nprint(f\"Current connectivity: {connectivity:.3f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCurrent connectivity: 1.000\n```\n:::\n:::\n\n\n## Network Robustness Analysis\n\nNow let's explore how networks behave when nodes fail or are attacked systematically.\n\n<a target=\"_blank\" href=\"https://colab.research.google.com/github/skojaku/adv-net-sci/blob/main/notebooks/m03-robustness/exercise.ipynb\">\n  <img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/>\n</a>\n\n::: {#4ea4e8aa .cell execution_count=4}\n``` {.python .cell-code}\n# If you are using Google Colab, uncomment the following line to install igraph\n# !sudo apt install libcairo2-dev pkg-config python3-dev\n# !pip install pycairo cairocffi\n# !pip install igraph\n```\n:::\n\n\n### Random Attack Simulation\n\nRandom attacks simulate random failures where nodes are removed with equal probability. Let's implement a systematic approach:\n\n::: {#c36a5faa .cell execution_count=5}\n``` {.python .cell-code}\nimport pandas as pd\n\ndef simulate_random_attack(graph):\n    \"\"\"Simulate random node removal and measure connectivity\"\"\"\n    g_test = graph.copy()\n    original_size = g_test.vcount()\n    results = []\n\n    for i in range(original_size - 1):  # Remove all but one node\n        # Randomly select and remove a node\n        node_idx = np.random.choice(g_test.vs.indices)\n        g_test.delete_vertices(node_idx)\n\n        # Measure connectivity\n        connectivity = network_connectivity(g_test, original_size)\n\n        # Store results\n        results.append({\n            \"connectivity\": connectivity,\n            \"frac_nodes_removed\": (i + 1) / original_size,\n        })\n\n    return pd.DataFrame(results)\n\n# Run the simulation\ndf_random = simulate_random_attack(g)\n```\n:::\n\n\nLet's visualize the robustness profile:\n\n::: {#bc0e1293 .cell execution_count=6}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.set(style='white', font_scale=1.2)\nsns.set_style('ticks')\n\nfig, ax = plt.subplots(figsize=(6, 5))\nax.plot(df_random[\"frac_nodes_removed\"],\n        df_random[\"connectivity\"],\n        'o-', linewidth=2, markersize=4, label=\"Random attack\")\nax.set_xlabel(\"Proportion of nodes removed\")\nax.set_ylabel(\"Connectivity\")\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\nsns.despine()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-coding_files/figure-html/cell-7-output-1.png){}\n:::\n:::\n\n\n### Targeted Attack Simulation\n\nTargeted attacks remove nodes based on specific criteria, such as degree centrality. High-degree nodes (hubs) often play crucial roles in network connectivity:\n\n::: {#b3bc6581 .cell execution_count=7}\n``` {.python .cell-code}\ndef simulate_targeted_attack(graph, criterion=\"degree\"):\n    \"\"\"Simulate targeted node removal based on specified criterion\"\"\"\n    g_test = graph.copy()\n    original_size = g_test.vcount()\n    results = []\n\n    for i in range(original_size - 1):\n        # Remove node with highest degree\n        if criterion == \"degree\":\n            degrees = g_test.degree()\n            node_idx = g_test.vs.indices[np.argmax(degrees)]\n\n        g_test.delete_vertices(node_idx)\n\n        # Measure connectivity\n        connectivity = network_connectivity(g_test, original_size)\n\n        # Store results\n        results.append({\n            \"connectivity\": connectivity,\n            \"frac_nodes_removed\": (i + 1) / original_size,\n        })\n\n    return pd.DataFrame(results)\n\n# Run targeted attack simulation\ndf_targeted = simulate_targeted_attack(g)\n```\n:::\n\n\nNow let's compare both attack strategies:\n\n::: {#3fba3415 .cell execution_count=8}\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=(7, 5))\n\nax.plot(df_random[\"frac_nodes_removed\"],\n        df_random[\"connectivity\"],\n        'o-', linewidth=2, markersize=4, label=\"Random attack\", alpha=0.8)\n\nax.plot(df_targeted[\"frac_nodes_removed\"],\n        df_targeted[\"connectivity\"],\n        's-', linewidth=2, markersize=4, label=\"Targeted attack\", alpha=0.8)\n\nax.set_xlabel(\"Proportion of nodes removed\")\nax.set_ylabel(\"Connectivity\")\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\nax.legend(frameon=False)\nsns.despine()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-coding_files/figure-html/cell-9-output-1.png){}\n:::\n:::\n\n\nThe comparison reveals a key insight: while networks are often robust against random failures, they can be vulnerable to targeted attacks on high-degree nodes.\n\n##### Exercise 01 üèãÔ∏è‚Äç‚ôÄÔ∏èüí™üß†\n\n1. Examine the degree distribution of the Zachary network and identify the nodes with highest degrees. üìäüîç\n\n2. Create a visualization showing which nodes are removed first in the targeted attack. üéØüìà\n\n3. Try implementing a targeted attack based on betweenness centrality instead of degree. How does it compare? üåê‚ö°\n\n## Minimum Spanning Tree Analysis\n\nUnderstanding network structure through minimum spanning trees can provide insights into network robustness. Let's explore this concept:\n\n::: {#21b1f24b .cell execution_count=9}\n``` {.python .cell-code}\nimport random\n\n# Create a weighted version of our network for MST analysis\ng_weighted = g.copy()\ng_weighted.es[\"weight\"] = [random.randint(1, 10) for _ in g_weighted.es]\n\n# Visualize weighted network\nigraph.plot(g_weighted, bbox=(300, 200),\n           edge_width=[w/3 for w in g_weighted.es[\"weight\"]],\n           vertex_label=list(range(g_weighted.vcount())))\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](02-coding_files/figure-html/cell-10-output-1.svg){}\n:::\n:::\n\n\n### Computing the Minimum Spanning Tree\n\nThe minimum spanning tree represents the most efficient way to connect all nodes:\n\n::: {#bac01553 .cell execution_count=10}\n``` {.python .cell-code}\n# Find minimum spanning tree\nmst = g_weighted.spanning_tree(weights=g_weighted.es[\"weight\"])\n\n# Visualize the MST\nigraph.plot(mst, bbox=(300, 200),\n           edge_width=[w/3 for w in mst.es[\"weight\"]],\n           vertex_label=list(range(mst.vcount())))\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](02-coding_files/figure-html/cell-11-output-1.svg){}\n:::\n:::\n\n\nThe MST identifies the most critical connections for maintaining network connectivity, which relates directly to robustness analysis.\n\n## Percolation Theory\n\nNetwork robustness can be viewed as the inverse process of **percolation**. In percolation theory, we study how connectivity emerges as we randomly add nodes to a network.\n\n::: {#be33a413 .cell execution_count=11}\n``` {.python .cell-code}\ndef percolation_simulation(lattice_size=100, p_values=None):\n    \"\"\"Simulate percolation on a 2D lattice\"\"\"\n    if p_values is None:\n        p_values = np.linspace(0, 1, 20)\n\n    # Create 2D lattice\n    g_lattice = igraph.Graph.Lattice([lattice_size, lattice_size],\n                                    nei=1, directed=False,\n                                    mutual=False, circular=False)\n\n    results = []\n    for p in p_values:\n        # Randomly keep nodes with probability p\n        keep_nodes = np.where(np.random.rand(g_lattice.vcount()) < p)[0]\n\n        if len(keep_nodes) > 0:\n            g_sub = g_lattice.subgraph(keep_nodes)\n            largest_size = network_connectivity(g_sub, g_lattice.vcount())\n        else:\n            largest_size = 0\n\n        results.append({\"p\": p, \"largest_component_fraction\": largest_size})\n\n    return pd.DataFrame(results)\n\n# Run percolation simulation\ndf_percolation = percolation_simulation(lattice_size=50)\n```\n:::\n\n\n::: {#c05a37da .cell execution_count=12}\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=(6, 5))\n\nax.plot(df_percolation[\"p\"],\n        df_percolation[\"largest_component_fraction\"],\n        'o-', linewidth=2, markersize=4)\n\n# Mark theoretical critical point for 2D lattice\ncritical_p = 0.593  # Theoretical value for 2D square lattice\nax.axvline(x=critical_p, color='red', linestyle='--', alpha=0.7,\n           label=f'Critical point (p_c ‚âà {critical_p})')\n\nax.set_xlabel(\"Probability (p)\")\nax.set_ylabel(\"Fractional largest component size\")\nax.set_title(\"Percolation on 2D Lattice\")\nax.legend(frameon=False)\nsns.despine()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-coding_files/figure-html/cell-13-output-1.png){}\n:::\n:::\n\n\n::: {.column-margin}\n**Phase Transition**\n\nThe sharp transition around p_c demonstrates a **phase transition** - a sudden change from a disconnected to connected state as we cross the critical threshold.\n:::\n\n```{note}\n\nWant to see this in action? üåü Check out this interactive simulation.\nPlay around with it and watch how the puddles grow and connect. üåä\n\n[Bernoulli Percolation Simulation üåê](https://visualize-it.github.io/bernoulli_percolation/simulation.html) üîó\n\n```\n\n\n\n## Exercise 02 üèãÔ∏è‚Äç‚ôÄÔ∏è\n\nLet's explore robustness in real-world networks by analyzing data from [Netzschleuder](https://networks.skewed.de/).\n\n1. Select a network with fewer than 5000 nodes from Netzschleuder\n2. Download the CSV version and load it using `pandas`\n3. Create the network using `igraph`\n4. Compare random vs. targeted attack robustness profiles\n5. Calculate theoretical predictions using the Molloy-Reed criterion\n\n**Hint:** For large networks, consider sampling node pairs to estimate average path length rather than computing all pairwise distances.\n\n::: {#4df66729 .cell execution_count=13}\n``` {.python .cell-code}\n# Your implementation here\n```\n:::\n\n\n## Real-World Case Study: Airport Network\n\nLet's analyze a more complex real-world network to see robustness principles in action:\n\n::: {#e7f61d7f .cell execution_count=14}\n``` {.python .cell-code}\n# Load airport network data\ndf_airports = pd.read_csv(\"https://raw.githubusercontent.com/skojaku/core-periphery-detection/master/data/edge-table-airport.csv\")\n\n# Process edge data\nedges = df_airports[[\"source\", \"target\"]].to_numpy()\nedges = np.unique(edges.reshape(-1), return_inverse=True)[1]\nedges = edges.reshape(-1, 2)\n\n# Create network\ng_airports = igraph.Graph()\ng_airports.add_vertices(np.max(edges) + 1)\ng_airports.add_edges([tuple(edge) for edge in edges])\n\nprint(f\"Airport network: {g_airports.vcount()} nodes, {g_airports.ecount()} edges\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAirport network: 2905 nodes, 30442 edges\n```\n:::\n:::\n\n\n### Theoretical Prediction using Molloy-Reed Criterion\n\nThe Molloy-Reed criterion provides a theoretical framework for predicting network robustness:\n\n::: {#c9cac041 .cell execution_count=15}\n``` {.python .cell-code}\n# Calculate degree statistics\ndegrees = np.array(g_airports.degree())\nk_mean = np.mean(degrees)\nk_squared_mean = np.mean(degrees**2)\n\n# Molloy-Reed criterion: kappa_0 > 2 for giant component\nkappa_0 = k_squared_mean / k_mean\nprint(f\"Œ∫‚ÇÄ = <k¬≤>/<k> = {kappa_0:.3f}\")\n\n# Critical fraction for network breakdown\nf_c = 1 - 1 / (kappa_0 - 1)\nprint(f\"Predicted critical fraction f_c = {f_c:.3f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nŒ∫‚ÇÄ = <k¬≤>/<k> = 110.937\nPredicted critical fraction f_c = 0.991\n```\n:::\n:::\n\n\nThe high f_c value indicates the airport network is extremely robust to random failures, maintaining connectivity until almost all nodes are removed.\n\n::: {#be46e83d .cell execution_count=16}\n``` {.python .cell-code}\n# Simulate and visualize (using subset for efficiency)\nn_samples = min(500, g_airports.vcount() - 1)  # Sample for computational efficiency\nsample_indices = np.linspace(0, g_airports.vcount() - 2, n_samples, dtype=int)\n\ndf_airport_robustness = simulate_random_attack(g_airports)\ndf_airport_sample = df_airport_robustness.iloc[sample_indices]\n\nfig, ax = plt.subplots(figsize=(6, 5))\nax.plot(df_airport_sample[\"frac_nodes_removed\"],\n        df_airport_sample[\"connectivity\"],\n        'o-', linewidth=2, markersize=3, alpha=0.8)\n\n# Add theoretical prediction\nax.axvline(x=f_c, color='red', linestyle='--', alpha=0.7,\n           label=f'Theoretical f_c = {f_c:.3f}')\n\n# Add diagonal reference line\nax.plot([0, 1], [1, 0], 'gray', linestyle=':', alpha=0.5, label='Linear decline')\n\nax.set_xlabel(\"Proportion of nodes removed\")\nax.set_ylabel(\"Connectivity\")\nax.set_title(\"Airport Network Robustness\")\nax.legend(frameon=False)\nsns.despine()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02-coding_files/figure-html/cell-17-output-1.png){}\n:::\n:::\n\n\n### Key Design Principles for Robust Networks\n\nBased on percolation theory and empirical analysis, robust networks share several characteristics:\n\n1. **Degree heterogeneity**: Networks with diverse degree distributions (high Œ∫‚ÇÄ) maintain connectivity better\n2. **Distributed hubs**: Resilience improves when connectivity doesn't depend on single critical nodes\n3. **Redundant pathways**: Multiple paths between node pairs provide backup routes when primary connections fail\n\nUnderstanding these principles helps in designing resilient infrastructure networks, from transportation systems to communication networks.\n\n",
    "supporting": [
      "02-coding_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}