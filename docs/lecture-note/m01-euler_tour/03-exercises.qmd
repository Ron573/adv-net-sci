---
title: Exercises
filters:
  - marimo-team/marimo
jupyter: python3
---

#  Exercise

## How to Run This Notebook

::: {.callout-tip}
## Running with Marimo

To run the notebook, first download it as a .py file, then use the following steps:

```bash
marimo edit --sandbox <filename>.py
```

The notebook will open in your web browser. All necessary packages will be installed automatically in a dedicated virtual environment managed by uv.
:::


## The Königsberg Bridge Problem in Code

![](https://towardsdatascience.com/wp-content/uploads/2024/05/15n0gkvpktkGYtAase5oYuw-1.png)

Let's apply the network representation concepts to the original Königsberg bridge problem. The network has 4 nodes (landmasses) and 7 edges (bridges).

### Representing the Königsberg Network

The Königsberg graph can be represented by a list of edges. Note that some bridges appear twice because there were multiple bridges between the same landmasses.

```{python}
import numpy as np

# Königsberg bridge network
koenigsberg_edges = [(0,1), (0, 1), (0, 3), (1, 2), (1, 2), (1, 3), (2, 3)]
print("Königsberg edges:", koenigsberg_edges)
print("Total bridges:", len(koenigsberg_edges))
```

### Building the Adjacency Matrix

Let's create the adjacency matrix for the Königsberg network:

```{python}
# Create adjacency matrix for Königsberg
A = np.zeros((4, 4))
for i, j in koenigsberg_edges:
    A[i][j] += 1
    A[j][i] += 1

print("Königsberg adjacency matrix:")
print(A.astype(int))  # Convert to int for cleaner display
```

::: {.callout-note}

In the Königsberg graph, the edges are *undirected*, meaning edge (i,j) is the same as edge (j,i), which is why we increment both entries $(i,j)$ and $(j,i)$ in the for loop. If the edges are *directed*, we treat (i,j) and (j,i) as two different edges, and increment only (i,j).

:::

### Analyzing the Network

Let's use our computational tools to analyze the Königsberg network:

```{python}
# Count total edges
_total_edges = np.sum(A) / 2  # Divide by 2 because each edge is counted twice
print(f"Total edges: {_total_edges}")

# Compute node degrees
degrees = np.sum(A, axis=1)
print("Node degrees:", degrees.astype(int))

# Check for odd degrees
_is_odd = degrees % 2 == 1
_num_odd_nodes = np.sum(_is_odd)
print(f"Nodes with odd degree: {_num_odd_nodes}")
print(f"Odd degree nodes: {np.where(_is_odd)[0]}")
```

::: {.callout-important}

The number of edges connected to a node is called the ***degree*** of the node.

:::

### Applying Euler's Theorem Computationally

Now we can implement Euler's theorem as code:

```{python}
def has_euler_path(degrees):
    """
    Check if a graph has an Euler path based on node degrees.

    Euler's theorem: A graph has an Euler path if and only if:
    - All nodes have even degree, OR
    - Exactly two nodes have odd degree
    """
    odd_count = np.sum(degrees % 2 == 1)

    if odd_count == 0:
        return True, "Euler circuit exists (all nodes have even degree)"
    elif odd_count == 2:
        return True, "Euler path exists (exactly 2 nodes have odd degree)"
    else:
        return False, f"No Euler path ({odd_count} nodes have odd degree)"

# Test on Königsberg
_has_path, _reason = has_euler_path(degrees)
print(f"Königsberg network: {_has_path}")
print(f"Reason: {_reason}")
```

::: {.callout-tip}

The `np.sum(A, axis = 1)` computes the row sum of `A`. Alternatively, `np.sum(A, axis = 0)` computes the column sum of `A`.
Check out the numpy [documentation](https://numpy.org/doc/stable/reference/generated/numpy.sum.html) for more details.

:::

---

## Exercise 01

1. Create a network of landmasses and bridges of Binghamton, NY.
2. Find an Euler path that crosses all the bridges of Binghamton, NY exactly once.

![Binghamton Map](https://github.com/skojaku/adv-net-sci/raw/main/docs/lecture-note/figs/binghamton-map.jpg)


```{python}
# If you are using colab, uncomment the following line
# !sudo apt install libcairo2-dev pkg-config python3-dev
# !pip install pycairo cairocffi
# !pip install igraph

```

Define the edges
```{python}
# This is a placeholder for your code for the exercise
edges = ...
```


Define the adjacnecy matrix (without for loops!)
```{python}
A = ...
```

Visualize the graph
```{python}
import igraph
import matplotlib.pyplot as plt
import numpy as np

def visualize_graph(A, **params):
  A = np.array(A)
  src, trg = np.where(A)
  g = igraph.Graph(directed=False)
  g.add_vertices(A.shape[0])
  for s, t in zip(src, trg):
    for _ in range(A[s, t]):
      g.add_edge(s, t)
  return igraph.plot(g, **params)

visualize_graph(A)
```

Check if the graph has an Euler path
```{python}
# Use the has_euler_path function defined above
degrees_binghamton = np.sum(A, axis=1)
_has_path, _reason = has_euler_path(degrees_binghamton) 
print(f"Binghamton network: {_has_path}")
print(f"Reason: {_reason}")
```


##  Exercise 02

Let's create a network from pre-existing data and check if it has an Euler path.

1. Select a network of your choice from [Netzschleuder](https://networks.skewed.de/). For convenience, choose a network of nodes less than 5000.
2. Download the csv version of the data by clicking something like "3KiB" under `csv` column.
3. Unzip the file and find "edges.csv", open it with a text editor to familiarize yourself with the format.
4. Load the data using `pandas`.
5. Get the source and target nodes from the data to create an edge list.
6. Construct the adjacency matrix from the edge list.
7. Draw the graph using `igraph`.
8. Check if the graph has an Euler path.


Load the data by
```{python}
import pandas as pd
df = pd.read_csv('edges.csv') # load the data
display(df)
```

Then, get the srce and target nodes to compose an edge list
```{python}
src = ...
trg = ...
edges = ...
```

Create the adjacency matrix from the edge list
```{python}
```

Get the degree of each node
```{code-cell} ipython3
deg = ...
```

Visualize the graph
```{python}
visualize_graph(A)
```

Check if the graph has an Euler path
```{python}
# Use the has_euler_path function defined above
_has_path, _reason = has_euler_path(deg)
print(f"Network: {_has_path}")
print(f"Reason: {_reason}")
```