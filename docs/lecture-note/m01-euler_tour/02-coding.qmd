---
title: Coding Networks in Python
jupyter: python3
execute:
    enabled: true
---
import numpy as np

Now that you understand the conceptual foundation from Euler's work, let's explore how to represent and analyze networks computationally. Given a network of any size, our goal is to create a function that can tell us whether the network has an Euler path or not.

```python
def has_euler_path(A):
    """
    Check if a graph has an Euler path based on node degrees.
    Complete this function based on Euler's theorem.

    A: network (assumed to be an adjacency matrix)
    return: True if the network has an Euler path, False otherwise
    """
    # Calculate degrees of all nodes
    degrees = A.sum(axis=1)

    # Count nodes with odd degrees
    odd_degree_count = 0
    for degree in degrees:
        if degree % 2 != 0:
            odd_degree_count += 1

    # According to Euler's theorem, an Euler path exists if:
    # 1. The graph is connected (we assume this for now)
    # 2. Exactly 0 or 2 nodes have odd degrees
    return odd_degree_count == 0 or odd_degree_count == 2
```

We'll work through both general network representations and apply them specifically to the Königsberg bridge problem.

## Network Representations: From Pictures to Data Structures

Consider this network with 5 nodes and 6 edges:

::: {#fig-small-graph}

![](https://www.tandfonline.com/cms/asset/2820b951-1747-4621-802c-8d04263f106c/tcon_a_1707286_f0001_oc.jpg){width=200px}

A small graph of five nodes and six edges.

:::

How do we represent this graph in a format that a computer can understand and manipulate? Just as Euler needed to abstract Königsberg's bridges, we need data structures that capture the network's essential connectivity while enabling efficient analysis.

::: {.column-margin}
The choice of representation can dramatically affect computational efficiency. For sparse networks (few edges), adjacency lists are memory-efficient. For dense networks or matrix operations, adjacency matrices are preferred.
:::

Let's explore three fundamental approaches that form the backbone of all network algorithms.

### Edge Table: The Direct Approach

The edge table directly lists connections as pairs—the most intuitive way to store network data.

::: {.column-margin}
Edge tables are also called "edge lists" and are the most common format for storing large-scale network data in files. Social media platforms like Twitter and Facebook store billions of connections this way.
:::

```{python}
# Each row represents one edge (connection between two nodes)
edges = [
    (0, 1),  # Node 0 connects to Node 1
    (0, 2),  # Node 0 connects to Node 2
    (1, 2),  # Node 1 connects to Node 2
    (1, 3),  # Node 1 connects to Node 3
    (2, 4),  # Node 2 connects to Node 4
    (3, 4)   # Node 3 connects to Node 4
]

print(f"Network has {len(edges)} edges")
print("Edge list:", edges)
```

This mirrors how we'd naturally describe the network: "Node 0 connects to nodes 1 and 2, node 1 connects to nodes 0, 2, and 3..." It's the digital equivalent of Euler's original approach—simply listing which bridges connect which landmasses.

### Adjacency List: The Neighborhood Map

The adjacency list stores each node's neighbors in a dictionary—like a social network where each person has a list of friends.

::: {.column-margin}
Most graph algorithms prefer adjacency lists because they allow fast iteration over a node's neighbors. This is crucial for algorithms like breadth-first search or computing clustering coefficients.
:::

```{python}
# Define adjacency list directly as a dictionary
neighbors = {
    0: [1, 2],     # Node 0 connects to nodes 1 and 2
    1: [0, 2, 3],  # Node 1 connects to nodes 0, 2, and 3
    2: [0, 1, 4],  # Node 2 connects to nodes 0, 1, and 4
    3: [1, 4],     # Node 3 connects to nodes 1 and 4
    4: [2, 3]      # Node 4 connects to nodes 2 and 3
}

print("Adjacency list representation:")
for node, neighbor_list in neighbors.items():
    print(f"Node {node}: {neighbor_list}")
```

### Adjacency Matrix

The adjacency matrix uses a grid where entry (i,j) = 1 if nodes are connected—the mathematician's favorite representation.

::: {.column-margin}
Adjacency matrices enable powerful mathematical operations. Matrix multiplication reveals paths of different lengths, and eigenvalue analysis can uncover community structure. Google's PageRank algorithm fundamentally relies on matrix operations.
:::

```{python}
# Define adjacency matrix directly
import numpy as np

matrix = np.array([
    [0, 1, 1, 0, 0],  # Node 0 connects to nodes 1, 2
    [1, 0, 1, 1, 0],  # Node 1 connects to nodes 0, 2, 3
    [1, 1, 0, 0, 1],  # Node 2 connects to nodes 0, 1, 4
    [0, 1, 0, 0, 1],  # Node 3 connects to nodes 1, 4
    [0, 0, 1, 1, 0]   # Node 4 connects to nodes 2, 3
])

print("Adjacency matrix:")
print(matrix)
```

Notice the symmetry: if node i connects to node j, then node j connects to node i (for undirected networks). This symmetry disappears in directed networks, where relationships can be one-way.

## Node Degrees

The degree of a node is the number of edges connected to it. This simple concept was central to Euler's proof—he realized that a valid bridge walk requires each landmass to have an even degree (except possibly the starting and ending points).

::: {.column-margin}
In Königsberg, all four landmasses had odd degree, making the bridge walk impossible. This insight—that global properties emerge from local structure—remains fundamental to network analysis today.
:::

Here's how to compute degrees using each representation:

### From Edge Table

Count how many times each node appears in the edge list.

```{python}
_degrees = [0] * 5
for node1, node2 in edges:
    _degrees[node1] += 1
    _degrees[node2] += 1
print("Degrees from edge list:", _degrees)
```

::: {.column-margin}
We increment the degree counter for both nodes in each edge because every edge contributes to two nodes' degrees. This is why the total degree always equals twice the number of edges.
:::

### From Adjacency List

Count the length of each node's neighbor list—the most direct approach.

```{python}
_degrees = [len(neighbors[i]) for i in range(5)]
print("Degrees from adjacency list:", _degrees)
```

### From Adjacency Matrix

Sum each row (or column) of the matrix—leveraging vectorized operations.

```{python}
_degrees = matrix.sum(axis=1)  # Sum rows
print("Degrees from adjacency matrix:", _degrees)
```

::: {.column-margin}
For undirected networks, row sums equal column sums. For directed networks, row sums give out-degree (outgoing connections) while column sums give in-degree (incoming connections).
:::

## Checking for Trails, Walks, and Paths

Now that we understand how to represent networks and compute degrees, let's implement functions to verify whether a sequence of nodes represents a valid walk, trail, path, or cycle. These verification algorithms are essential for network analysis and implementing graph traversal algorithms.

### Verifying a Walk

A **walk** is the most permissive—we simply need to check that each consecutive pair of nodes is connected by an edge.

```{python}
def is_walk(sequence, adjacency_matrix):
    """
    Check if a sequence of nodes forms a valid walk.

    Args:
        sequence: List of node indices [v0, v1, v2, ...]
        adjacency_matrix: 2D numpy array representing the graph

    Returns:
        bool: True if sequence is a valid walk, False otherwise
    """
    if len(sequence) < 2:
        return True  # Single node or empty sequence is trivially a walk

    # Use NumPy vectorized operations for efficient edge checking
    sequence = np.array(sequence)
    current_nodes = sequence[:-1]  # All nodes except the last
    next_nodes = sequence[1:]      # All nodes except the first

    # Simple but slower: for loop version (slower but more explicit)
    # for i, j in zip(current_nodes, next_nodes):
    #     if adjacency_matrix[i, j] == 0:
    #         return False
    # return True

    # Check all edges at once using advanced indexing
    edges_exist = adjacency_matrix[current_nodes, next_nodes]

    # All edges must exist (all values must be 1)
    return np.all(edges_exist == 1)


# Test with our sample network
test_sequence = [0, 1, 2, 4, 3, 1]
print(f"Sequence {test_sequence} is a valid walk: {is_walk(test_sequence, matrix)}")

# Test an invalid walk
invalid_sequence = [0, 3]  # No direct edge between 0 and 3
print(f"Sequence {invalid_sequence} is a valid walk: {is_walk(invalid_sequence, matrix)}")
```


::: {.callout-note title = "Mind the loops!"}
For loops in Python is the notorious source of computational bottlenecks.
Avoiding for loops significantly boosts the speed. In `is_walk`, we use one for loop but you can avoid it by using NumPy's advanced indexing, i.e., `adjacency_matrix[(current_nodes, next_nodes)]`. The way to think about this is that `(current_nodes, next_nodes)` is a tuple of indices, acting as a multi-dimensional index.
`adjacency_matrix[(current_nodes, next_nodes)]` is 1d array of length the same as `current_nodes` and `next_nodes`. If the value is 0, then the edge does not exist. We can then check if all the values are not zero.
:::

### Verifying a Trail

A **trail** requires all edges to be distinct, but nodes can repeat.

```{python}
def is_trail(sequence, adjacency_matrix):
    """
    Check if a sequence of nodes forms a valid trail.

    Args:
        sequence: List of node indices [v0, v1, v2, ...]
        adjacency_matrix: 2D numpy array representing the graph

    Returns:
        bool: True if sequence is a valid trail, False otherwise
    """
    if not is_walk(sequence, adjacency_matrix):
        return False  # Must be a valid walk first

    if len(sequence) < 2:
        return True

    # Convert to numpy for efficient operations
    sequence = np.array(sequence)
    current_nodes = sequence[:-1]
    next_nodes = sequence[1:]
    
    # Create normalized edge pairs (smaller index first for undirected graphs)
    # Using np.minimum and np.maximum for vectorized min/max operations
    edge_starts = np.minimum(current_nodes, next_nodes)
    edge_ends = np.maximum(current_nodes, next_nodes)
    
    # Stack to create array of edge pairs, then convert to tuples for set operations
    edges = np.column_stack((edge_starts, edge_ends))
    edge_tuples = [tuple(edge) for edge in edges]
    
    # Check if all edges are unique using set comparison
    return len(edge_tuples) == len(set(edge_tuples))
    
    # Alternative: Original for loop version (slower but more explicit)
    # used_edges = set()
    # for i in range(len(sequence) - 1):
    #     current_node = sequence[i]
    #     next_node = sequence[i + 1]
    #     # Create edge tuple (smaller index first for undirected graphs)
    #     edge = (min(current_node, next_node), max(current_node, next_node))
    #     if edge in used_edges:
    #         return False  # Edge already used
    #     used_edges.add(edge)
    # return True

# Test trail verification
trail_sequence = [0, 1, 3, 4, 2]
print(f"Sequence {trail_sequence} is a valid trail: {is_trail(trail_sequence, matrix)}")

# Test invalid trail (reuses edge 1-2)
invalid_trail = [0, 1, 2, 1, 3]
print(f"Sequence {invalid_trail} is a valid trail: {is_trail(invalid_trail, matrix)}")
```

::: {.callout-note title="NumPy Trail Optimization"}
For trail verification, we use **vectorized min/max operations** (`np.minimum`, `np.maximum`) instead of loops to create normalized edge pairs. The key insight is using `np.column_stack()` to efficiently create edge tuples, then leveraging Python's set operations for uniqueness checking. This approach scales much better than the nested loop version for long sequences.
:::

### Verifying a Path

A **path** requires all nodes (except possibly start/end for cycles) to be distinct.

```{python}
def is_path(sequence, adjacency_matrix, allow_cycle=False):
    """
    Check if a sequence of nodes forms a valid path.

    Args:
        sequence: List of node indices [v0, v1, v2, ...]
        adjacency_matrix: 2D numpy array representing the graph
        allow_cycle: If True, allows start node = end node (cycle)

    Returns:
        bool: True if sequence is a valid path, False otherwise
    """
    if not is_walk(sequence, adjacency_matrix):
        return False  # Must be a valid walk first

    if len(sequence) < 2:
        return True

    sequence = np.array(sequence)

    # NumPy optimized version: Check node uniqueness using np.unique
    if allow_cycle and len(sequence) > 2:
        # For cycles, all intermediate nodes must be unique
        if sequence[0] == sequence[-1]:
            # Check if all intermediate nodes are unique
            intermediate_nodes = sequence[1:-1]
            return len(intermediate_nodes) == len(np.unique(intermediate_nodes))
        else:
            # Not a cycle, so all nodes must be unique
            return len(sequence) == len(np.unique(sequence))
    else:
        # Standard path: all nodes must be unique
        return len(sequence) == len(np.unique(sequence))
    
    # Alternative: Set-based version (can be faster for small sequences)
    # if allow_cycle and len(sequence) > 2:
    #     if sequence[0] == sequence[-1]:
    #         intermediate_nodes = sequence[1:-1]
    #         return len(intermediate_nodes) == len(set(intermediate_nodes))
    #     else:
    #         return len(sequence) == len(set(sequence))
    # else:
    #     return len(sequence) == len(set(sequence))

# Test path verification
path_sequence = [0, 1, 3, 4]
print(f"Sequence {path_sequence} is a valid path: {is_path(path_sequence, matrix)}")

# Test cycle
cycle_sequence = [0, 1, 2, 0]
print(f"Sequence {cycle_sequence} is a valid cycle: {is_path(cycle_sequence, matrix, allow_cycle=True)}")

# Test invalid path (repeats node 1)
invalid_path = [0, 1, 2, 1, 3]
print(f"Sequence {invalid_path} is a valid path: {is_path(invalid_path, matrix)}")
```

::: {.callout-note title="Path Uniqueness Check"}
Path verification uses `np.unique()` which implements efficient sorting-based uniqueness detection. For very small sequences (< 10 elements), Python's `set()` might be faster due to lower overhead, but `np.unique()` scales better and integrates seamlessly with other NumPy operations.
:::

### Complete Classification Function

Let's create a comprehensive function that classifies any sequence:

```{python}
def classify_sequence(sequence, adjacency_matrix):
    """
    Classify a sequence of nodes as walk, trail, path, cycle, or circuit.

    Args:
        sequence: List of node indices
        adjacency_matrix: 2D numpy array representing the graph

    Returns:
        str: Classification of the sequence
    """
    if len(sequence) < 2:
        return "trivial path (single node)"

    # Check basic connectivity
    if not is_walk(sequence, adjacency_matrix):
        return "invalid (not connected)"

    sequence = np.array(sequence)

    # Check if it's closed (starts and ends at same node)
    is_closed = sequence[0] == sequence[-1] and len(sequence) > 2

    # Check node and edge uniqueness using NumPy
    nodes_unique = len(sequence) == len(np.unique(sequence))

    # For closed sequences, check if all intermediate nodes are unique
    if is_closed:
        intermediate_nodes = sequence[1:-1]
        intermediate_unique = len(intermediate_nodes) == len(np.unique(intermediate_nodes))
    else:
        intermediate_unique = nodes_unique

    edges_unique = is_trail(sequence, adjacency_matrix)

    # Classify based on properties
    if is_closed:
        if intermediate_unique:
            return "cycle"
        elif edges_unique:
            return "circuit"
        else:
            return "closed walk"
    else:
        if nodes_unique:
            return "path"
        elif edges_unique:
            return "trail"
        else:
            return "walk"

# Test various sequences
test_sequences = [
    [0, 1, 2, 4],           # Expected: path
    [0, 1, 2, 0],           # Expected: cycle
    [0, 1, 2, 1, 3],        # Expected: trail
    [0, 1, 2, 4, 3, 1, 0],  # Expected: circuit or closed walk
    [0, 1, 2, 1, 2, 4]      # Expected: walk
]

print("Sequence Classification:")
for seq in test_sequences:
    classification = classify_sequence(seq, matrix)
    print(f"{seq} → {classification}")
```

### Practical Applications

These verification functions are building blocks for more complex algorithms:

```{python}
def find_all_paths(adjacency_matrix, start, end, max_length=None):
    """
    Find all simple paths between two nodes using depth-first search.
    Uses NumPy operations for efficient neighbor finding.

    Args:
        adjacency_matrix: 2D numpy array representing the graph
        start: Starting node index
        end: Ending node index
        max_length: Maximum path length to consider

    Returns:
        List of paths (each path is a list of node indices)
    """
    adjacency_matrix = np.array(adjacency_matrix)
    all_paths = []

    def dfs(current_path, visited):
        current_node = current_path[-1]

        if current_node == end and len(current_path) > 1:
            all_paths.append(current_path.copy())
            return

        if max_length and len(current_path) >= max_length:
            return

        # Use NumPy to find neighbors efficiently
        neighbors = np.where(adjacency_matrix[current_node] == 1)[0]

        for neighbor in neighbors:
            if neighbor not in visited:
                current_path.append(neighbor)
                visited.add(neighbor)
                dfs(current_path, visited)
                current_path.pop()
                visited.remove(neighbor)

    dfs([start], {start})
    return all_paths

# Find all paths from node 0 to node 4
paths = find_all_paths(matrix, start=0, end=4, max_length=5)
print(f"\nAll paths from node 0 to node 4:")
for i, path in enumerate(paths, 1):
    print(f"Path {i}: {path}")
    print(f"  Classification: {classify_sequence(path, matrix)}")
```

::: {.callout-tip title="Performance Notes"}
**Time Complexity**:
- Walk verification: O(n) where n is sequence length
- Trail verification: O(n) for sequence, O(n) for edge tracking
- Path verification: O(n) for uniqueness checking

**Space Complexity**:
- Walk: O(1) additional space
- Trail: O(n) for edge set storage
- Path: O(n) for node set storage (if using sets for uniqueness)

For large networks, consider using more efficient data structures like hash sets for faster lookups.
:::

## Summary: From Euler's Insight to Modern Computation

You now understand how to:

1. **Represent networks** using edge lists, adjacency lists, and adjacency matrices
2. **Compute node degrees** efficiently using different data structures

The next step is to practice these concepts with real network data and explore more advanced network analysis techniques!