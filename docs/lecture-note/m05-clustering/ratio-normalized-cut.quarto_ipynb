{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Balanced cut\n",
        "\n",
        "## Ratio Cut\n",
        "\n",
        "Graph cut often provide unbalanced communities, e.g., a community consisting of a single node, and another consisting of all other nodes. For example, if the network has a node with degree one (e.g., one edge), an optimal cut will be to place this node in its own community, resulting in a cut of one.\n",
        "\n",
        "**Ratio cut** addresses this issue by introducing a normalization factor to balance the cut.\n",
        "Suppose we cut the network into two communities $V_1$ and $V_2$, then the ratio cut is defined as\n",
        "\n",
        "$$\n",
        "\\text{Ratio cut}(V_1, V_2) = \\frac{1}{|V_1| \\cdot |V_2|} \\sum_{i \\in V_1} \\sum_{j \\in V_2} A_{ij}\n",
        "$$\n",
        "\n",
        "- $|V_1|$ (or |V_2|) is the number of nodes in the community $V_1$ (or $V_2$).\n",
        "\n",
        "The normalization factor $1/(|V_1| |V_2|)$ balances the community sizes. It's smallest when communities are equal ($|V_1| = |V_2|$) and largest when one community has only one node ($|V_1| = 1$ or $|V_2| = 1$).\n"
      ],
      "id": "20f7b2f1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        ":tags: [\"hide-input\"]\n",
        "\n",
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "\n",
        "# Total number of nodes\n",
        "total_nodes = 100\n",
        "\n",
        "# Create an array of possible sizes for V1\n",
        "V1_sizes = np.arange(1, total_nodes)\n",
        "\n",
        "# Calculate corresponding sizes for V2\n",
        "V2_sizes = total_nodes - V1_sizes\n",
        "\n",
        "# Calculate the normalization factor\n",
        "normalization_factor = 1 / (V1_sizes * V2_sizes)\n",
        "\n",
        "# Create the plot\n",
        "fig = plt.figure(figsize=(5, 3))\n",
        "plt.plot(V1_sizes, normalization_factor)\n",
        "plt.title('Normalization Factor vs. Community Size')\n",
        "plt.xlabel('Size of V1')\n",
        "plt.ylabel('1 / (|V1| * |V2|)')\n",
        "plt.yscale('log')  # Use log scale for y-axis due to large range of values\n",
        "plt.grid(True)"
      ],
      "id": "5b9935eb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Normalized cut\n",
        "\n",
        "**Normalized cut**{footcite}`shi2000normalized` balances communities based on edge count, unlike Ratio cut which uses node count. It is defined as:\n",
        "\n",
        "$$\n",
        "\\text{Normalized cut}(V_1, V_2) = \\frac{1}{|E_1| \\cdot |E_2|} \\sum_{i \\in V_1} \\sum_{j \\in V_2} A_{ij}\n",
        "$$\n",
        "\n",
        "- $|E_1|$ and $|E_2|$ are the number of edges in the communities $V_1$ and $V_2$, respectively.\n",
        "\n",
        "\n",
        "\n",
        "::: {.callout-note title=\"Exercise\"}\n",
        ":class: tip\n",
        "\n",
        "Compute the ratio cut and normalized cut for the following network. The red edges should be cut.\n",
        "\n",
        "::: {#fig-fig-graph-cut}\n",
        ":name: fig-graph-cut\n",
        "\n",
        "```\n",
        "\n",
        "::: {.callout collapse=\"true\"}\n",
        "## Click here to reveal the answer\n",
        "\n",
        "The graph consists of two cliques, each with 5 nodes ($|V_1| = |V_2| = 5$).\n",
        "Each clique has 10 internal edges and 2 edges connecting to the other clique.\n",
        "Therefore, $|E_1| = |E_2| = 10 + 2 = 12$.\n",
        "We can now calculate:\n",
        "\n",
        "- **Ratio cut**: $2 / (5 \\times 5) = 0.08$.\n",
        "- **Normalized cut**: $2 / (12 \\times 12) = 0.01388889$.\n",
        "\n",
        ":::"
      ],
      "id": "ed191cf8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        ":tags: [\"hide-input\", \"remove-output\"]\n",
        "\n",
        "import igraph as ig\n",
        "import matplotlib.pyplot as plt\n",
        "from myst_nb import glue\n",
        "\n",
        "# Create two cliques of size 5\n",
        "G1 = ig.Graph.Full(5)\n",
        "G2 = ig.Graph.Full(5)\n",
        "\n",
        "# Combine the two cliques\n",
        "G = G1 + G2\n",
        "\n",
        "# Add an edge between the two cliques\n",
        "G.add_edge(0, 5)\n",
        "G.add_edge(1, 6)\n",
        "\n",
        "# Draw the graph\n",
        "layout = G.layout_fruchterman_reingold()\n",
        "\n",
        "# Set up the plot\n",
        "fig, ax = plt.subplots(figsize=(5, 5))\n",
        "\n",
        "# Draw the connecting edge in red\n",
        "ig.plot(\n",
        "    G,\n",
        "    target=ax,\n",
        "    layout=layout,\n",
        "    vertex_color='lightblue',\n",
        "    vertex_size=20,\n",
        "    edge_color='gray',\n",
        "    edge_width=1\n",
        ")\n",
        "\n",
        "# Draw the connecting edge in red behind the graph\n",
        "ax.plot([layout[0][0], layout[5][0]], [layout[0][1], layout[5][1]], color='red', linewidth=2, zorder=0)\n",
        "ax.plot([layout[1][0], layout[6][0]], [layout[1][1], layout[6][1]], color='red', linewidth=2, zorder=0)\n",
        "\n",
        "ig.plot(\n",
        "    G,\n",
        "    target=ax,\n",
        "    layout=layout,\n",
        "    vertex_color='white',\n",
        "    vertex_size=20,\n",
        "    edge_color='black',\n",
        "    edge_width=1\n",
        ")\n",
        "\n",
        "# Add labels to the nodes\n",
        "for i, coords in enumerate(layout):\n",
        "    ax.annotate(str(i), coords, ha='center', va='center')\n",
        "\n",
        "plt.title(\"Two Cliques Connected by One Edge\")\n",
        "plt.axis('off')\n",
        "plt.tight_layout()\n",
        "\n",
        "glue(\"fig-graph-cut\", fig, display=False)"
      ],
      "id": "27eea735",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        ":::\n",
        "\n",
        "## Cut into more than two communities\n",
        "\n",
        "Ratio cut and Normalized cut can be extended to cut into more than two communities. Specifically, we can extend them to cut into $k$ communities, i.e., $V_1, V_2, \\dots, V_k$ by defining\n",
        "\n",
        "$$\n",
        "\\begin{align}\n",
        "\\text{Ratio cut}(V_1, V_2, \\dots, V_k) &= \\sum_{k=1}^K \\frac{1}{|V_k|} \\left(\\sum_{i \\in V_k} \\sum_{j \\notin V_{k}} A_{ij} \\right) \\\\\n",
        "\\text{Normalized cut}(V_1, V_2, \\dots, V_k) &= \\sum_{k=1}^K \\frac{1}{|E_k|} \\left(\\sum_{i \\in V_k} \\sum_{j \\notin V_{k}} A_{ij} \\right)\n",
        "\\end{align}\n",
        "$$\n",
        "\n",
        "## Algorithms to find the best cut\n",
        "\n",
        "For both ratio and normalized cut, finding the best cut is a NP-hard problem. Yet, there are some heuristics to find a good cut.\n",
        "Interested students are encouraged to refer to [Ulrike von Luxburg \"A Tutorial on Spectral Clustering\"](https://arxiv.org/abs/0711.0189) for more details.\n",
        "\n",
        "## Issue of Ratio cut and Normalized cut\n",
        "\n",
        "While Ratio cut and Normalized cut methods are clever approaches, they do come with a couple of challenges we should be aware of.\n",
        "\n",
        "Firstly, these methods ask us to decide upfront how many communities we want to find. This can be tricky because, in real-world networks, we often don't know this number in advance. It requires us to make a guess on how many different groups of friends we have before actually looking at our social circle.\n",
        "\n",
        "Secondly, and perhaps more critically, these methods *favor* communities of roughly the same size.\n",
        "It's as if they're assuming all our friend groups should have about the same number of people.\n",
        "But as we know from real life, that's not always the case.\n",
        "Some of us might have a large group of college friends and a smaller group of childhood buddies.\n",
        "Research has shown that in many real-world networks, communities can indeed be quite different in size {footcite}`palla2005uncovering,clauset2004finding`.\n",
        "\n",
        "These limitations don't mean these methods should not be used, but they do remind us the importance of understanding the underlying assumptions and limitations of methods we use üòâ.\n",
        "It's always good to keep these points in mind when we're working with network data. üï∏Ô∏èüí°\n",
        "\n",
        "```{footbibliography}\n",
        "```"
      ],
      "id": "507fb57c"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "netdatasci",
      "language": "python",
      "display_name": "netdatasci",
      "path": "/Users/skojaku-admin/Library/Jupyter/kernels/netdatasci"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}