---
title: "Core Concepts"
---

## What to learn in this module

In this module, we will learn community detection, one of the most widely-used yet controversial techniques in network analysis. We will learn:

- What is community structure in networks?
- How to operationalize community structure?
- How to find communities in networks?
- Limitations of community detection
- **Keywords**: community detection, assortativity, modularity, resolution limit, rugged landscape, random graph, label switching algorithm, Louvain algorithm, stochastic block model, the configuration model.

## Understanding communities in networks

Birds of a feather flock together, and so do many other things. For instance, we have a group of friends with similar interests who hang out together frequently but may not interact as much with other groups.

![Birds of a feather](https://t4.ftcdn.net/jpg/08/10/89/17/360_F_810891701_xy4NsqgdqllMfKDfV6V27ycrw8FLFqrw.jpg)

In networks, communities are groups of nodes that share similar connection patterns. These communities do not always mean densely-connected nodes. Sometimes, a community can be nodes that are not connected to each other, but connect similarly to other groups. For instance, in a user-movie rating network, a community might be users with similar movie tastes, even if they don't directly connect to each other.

![Community structure in a social network](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f4/Network_Community_Structure.svg/220px-Network_Community_Structure.svg.png)

Communities reflect underlying mechanisms of network formation and underpin the dynamics of information propagation. Examples include:

1. Homophily: The tendency of similar nodes to form connections.
2. Functional groups: Nodes that collaborate for specific purposes.
3. Hierarchical structure: Smaller communities existing within larger ones.
4. Information flow: The patterns of information, influence, or disease propagation through the network.

This is why network scientists are sooo obsessed with community structure in networks. See [@fortunato2010community], [@fortunato2016community], [@peixoto2019bayesian] for comprehensive reviews on network communities.

## Pattern matching approach

Community detection is an abstract unsupervised problem. It is abstract because there is no clear-cut definition or ground truth to compare against. The concept of a community in a network is subjective and highly context-dependent.

A classical approach to community detection is based on *pattern matching*. Namely, we first explicitly define a community by a specific connectivity pattern of its members. Then, we search for these communities in the network.

::: {#fig-clique}

<img src="https://pythonhosted.org/trustedanalytics/R_images/k-clique_201508281155.png" alt="Clique graph" width="80%">

Cliques of different sizes. Taken from [https://pythonhosted.org/trustedanalytics/python_api/graphs/graph-/kclique_percolation.html](https://pythonhosted.org/trustedanalytics/python_api/graphs/graph-/kclique_percolation.html)
:::

Perhaps, the strictest definition of a community is a *clique*: a group of nodes all connected to each other. Examples include triangles (3-node cliques) and fully-connected squares (4-node cliques). However, cliques are often too rigid for real-world networks. In social networks, for instance, large groups of friends rarely have every member connected to every other, yet we want to accept such "in-perfect" social circles as communities. This leads to the idea of relaxed versions of cliques, called **pseudo-cliques**.

Pseudo-cliques are defined by relaxing at least one of the following three dimensions of strictness, i.e., degree, density, and distance. We will walk through each of them in details as follows.

### Degree relaxation
Degree relaxation acknowledges that real-world groups rarely have perfect connectivity among all members. The *k-plex* [@seidman1978graph] is a classic example: it allows each node in a group to miss connections to up to $k$ other members, making it possible to model social circles where not everyone knows everyone else. Similarly, the **k-core** [@seidman1983network] requires each node to have at least $k$ connections within the group, capturing the idea of a "core" of well-connected individuals. These approaches reflect the reality that cohesive groups can exist even when some connections are missing, and they help distinguish between core and peripheral members in a network.

::: {#fig-degree-relaxation}
```{dot}
//| fig-width: 6
//| fig-height: 3
//| fig-align: center

graph G {
    layout=fdp;
    node [shape=circle, style=filled, fontsize=12, width=0.6];
    edge [len=1.5];

    // k-plex: qualifies (2-plex allows each node to miss 1 connection)
    subgraph cluster_kplex {
        label="✅ k-plex (k=2)\nEach node misses ≤1 connection";
        style=filled;
        fillcolor="#e8f5e8";

        a [pos="0.5,2.5!", fillcolor="#4ecdc4"];
        b [pos="1.5,3!", fillcolor="#4ecdc4"];
        c [pos="2,2!", fillcolor="#4ecdc4"];
        d [pos="1.5,1!", fillcolor="#4ecdc4"];
        e [pos="0.5,1.5!", fillcolor="#4ecdc4"];

        a -- b; a -- d; a -- e;
        b -- c; b -- e;
        c -- d;
        d -- e;
        // Each node connected to 3 out of 4 others (misses exactly 1)
    }

    // Almost k-plex: does not qualify (some nodes miss >1 connections)
    subgraph cluster_not_kplex {
        label="❌ NOT k-plex (k=2)\nSome nodes miss >1 connection";
        style=filled;
        fillcolor="#ffe8e8";

        f [pos="5.5,2.5!", fillcolor="#ff9999"];
        g [pos="6.5,3!", fillcolor="#ff9999"];
        h [pos="7,2!", fillcolor="#ff9999"];
        i [pos="6.5,1!", fillcolor="#ff9999"];
        j [pos="5.5,1.5!", fillcolor="#ff9999"];

        f -- g; f -- j;
        g -- h;
        h -- i;
        i -- j;
        // Node f misses 2 connections (to h, i), violating k=2 constraint
    }
}
```

Comparison of k-plex: The left group qualifies as a 2-plex since each node misses at most 1 connection. The right group fails because some nodes miss more than 1 connection.
:::

### Density relaxation
Density relaxation shifts the focus from individual connections to the overall cohesiveness of the group. Instead of requiring every possible connection, a **$\rho$-dense subgraph** [@goldberg1984finding] enforces that the group contains at least a fraction $\rho$ of all possible internal edges. This approach is useful for identifying communities that are highly, but not perfectly, interconnected—such as a friend group where most, but not all, pairs know each other.

::: {#fig-density-relaxation}
```{dot}
//| fig-width: 6
//| fig-height: 3
//| fig-align: center

graph G {
    layout=fdp;
    node [shape=circle, style=filled, fontsize=12, width=0.6];
    edge [len=1.5];

    // ρ-dense: qualifies (has 8/10 = 80% > 75% threshold)
    subgraph cluster_dense {
        label="✅ ρ-dense (ρ=0.75)\n8/10 edges = 80% density";
        style=filled;
        fillcolor="#e8f5e8";

        a [pos="0.5,2.5!", fillcolor="#45b7d1"];
        b [pos="1.5,3!", fillcolor="#45b7d1"];
        c [pos="2,2!", fillcolor="#45b7d1"];
        d [pos="1.5,1!", fillcolor="#45b7d1"];
        e [pos="0.5,1.5!", fillcolor="#45b7d1"];

        a -- b; a -- d; a -- e;
        b -- c; b -- e;
        c -- d; c -- e;
        d -- e;
        // Missing: a -- c, b -- d (has 8 out of 10 possible edges = 80%)
    }

    // Not ρ-dense: fails (has 4/10 = 40% < 75% threshold)
    subgraph cluster_not_dense {
        label="❌ NOT ρ-dense (ρ=0.75)\n4/10 edges = 40% density";
        style=filled;
        fillcolor="#ffe8e8";

        f [pos="5.5,2.5!", fillcolor="#ff9999"];
        g [pos="6.5,3!", fillcolor="#ff9999"];
        h [pos="7,2!", fillcolor="#ff9999"];
        i [pos="6.5,1!", fillcolor="#ff9999"];
        j [pos="5.5,1.5!", fillcolor="#ff9999"];

        f -- g;
        g -- h;
        i -- j;
        j -- f;
        // Missing 6 edges: has only 4 out of 10 possible edges = 40%
    }
}
```

Comparison of ρ-dense subgraphs: The left group qualifies as a 0.75-dense subgraph with 80% edge density. The right group fails with only 40% density.
:::

### Distance relaxation
Distance relaxation allows for the inclusion of nodes that are not directly connected but are still close in terms of network steps. The **$n$-clique** [@luce1950connectivity] is a group where every pair of nodes is within $n$ steps of each other, so members can be connected through mutual friends. However, this can sometimes include connections that pass through nodes outside the group, which led to refinements such as the **$n$-clan** and **$n$-club** [@mokken1979cliques], where all paths between members must remain within the group itself. These definitions help capture the idea of communities that are tightly knit not just by direct ties, but also by short, internal paths.

::: {#fig-distance-relaxation}
```{dot}
//| fig-width: 6
//| fig-height: 3
//| fig-align: center

graph G {
    layout=fdp;
    node [shape=circle, style=filled, fontsize=12, width=0.6];
    edge [len=1.5, color="#666666"];

    // n-clique: qualifies (all nodes within distance 2)
    subgraph cluster_nclique {
        label="✅ 2-clique\nAll nodes within distance 2";
        style=filled;
        fillcolor="#e8f5e8";

        a [pos="0.5,2.5!", fillcolor="#96ceb4"];
        b [pos="1.5,3!", fillcolor="#96ceb4"];
        c [pos="2,2!", fillcolor="#96ceb4"];
        d [pos="1.5,1!", fillcolor="#96ceb4"];
        e [pos="0.5,1.5!", fillcolor="#96ceb4"];

        a -- b; a -- e;
        b -- c;
        c -- d;
        d -- e;
        // All pairs are within distance 2 (some via intermediate nodes)
    }

    // Not n-clique: fails (some nodes >2 steps apart)
    subgraph cluster_not_nclique {
        label="❌ NOT 2-clique\nSome nodes >2 steps apart";
        style=filled;
        fillcolor="#ffe8e8";

        f [pos="5.5,2.5!", fillcolor="#ff9999"];
        g [pos="6.5,3!", fillcolor="#ff9999"];
        h [pos="7,2!", fillcolor="#ff9999"];
        i [pos="6.5,1!", fillcolor="#ff9999"];
        j [pos="5.5,1.5!", fillcolor="#ff9999"];

        f -- g;
        h -- i;
        j -- f;
        // Note: g and h are distance 3+ apart (no path ≤2 steps)
    }

    // Add dashed lines to show distance-2 paths in the valid case
    a -- c [style=dashed, color="#4CAF50"];
    a -- d [style=dashed, color="#4CAF50"];
    b -- d [style=dashed, color="#4CAF50"];
    b -- e [style=dashed, color="#4CAF50"];
    c -- e [style=dashed, color="#4CAF50"];
}
```

Comparison of n-cliques: The left group qualifies as a 2-clique since all pairs are within 2 steps (dashed green lines show distance-2 connections). The right group fails because some nodes are >2 steps apart.
:::

### Hybrid approaches
Hybrid approaches combine these dimensions to capture even more nuanced community structures. The **$k$-truss** [@saito2008extracting; @cohen2009graph; @wang2010triangulation] requires that every edge in the group participates in at least $k-2$ triangles, emphasizing the importance of triadic relationships for group stability. The **$\rho$-dense core** [@koujaku2016dense] balances high internal density with sparse external connections, identifying groups that are not only cohesive inside but also well-separated from the rest of the network. These hybrid definitions reflect the complex and overlapping nature of real-world communities, where both internal cohesion and clear boundaries matter.

::: {#fig-hybrid-approaches}
```{dot}
//| fig-width: 6
//| fig-height: 3
//| fig-align: center

graph G {
    layout=fdp;
    node [shape=circle, style=filled, fontsize=12, width=0.6];
    edge [len=1.5];

    // k-truss: qualifies (each edge in ≥k-2=2 triangles)
    subgraph cluster_truss {
        label="✅ 4-truss\nEach edge in ≥2 triangles";
        style=filled;
        fillcolor="#e8f5e8";

        a [pos="0.5,2.5!", fillcolor="#e056fd"];
        b [pos="1.5,3!", fillcolor="#e056fd"];
        c [pos="2,2!", fillcolor="#e056fd"];
        d [pos="1.5,1!", fillcolor="#e056fd"];
        e [pos="0.5,1.5!", fillcolor="#e056fd"];

        a -- b; a -- d; a -- e;
        b -- c; b -- d;
        c -- d; c -- e;
        d -- e;
        // Every edge participates in at least 2 triangles
    }

    // Not k-truss: fails (some edges in <k-2 triangles)
    subgraph cluster_not_truss {
        label="❌ NOT 4-truss\nSome edges in <2 triangles";
        style=filled;
        fillcolor="#ffe8e8";

        f [pos="5.5,2.5!", fillcolor="#ff9999"];
        g [pos="6.5,3!", fillcolor="#ff9999"];
        h [pos="7,2!", fillcolor="#ff9999"];
        i [pos="6.5,1!", fillcolor="#ff9999"];
        j [pos="5.5,1.5!", fillcolor="#ff9999"];

        f -- g; f -- j;
        g -- h;
        h -- i;
        i -- j;
        // Some edges (like g-h) participate in <2 triangles
    }
}
```

Comparison of k-truss: The left group qualifies as a 4-truss since every edge participates in at least 2 triangles. The right group fails because some edges participate in fewer than 2 triangles.
:::


#### Choosing Your Tool: A Practical Guide

When to use each approach:

| Your Question | Best Pseudo-Clique |
|---------------|-------------------|
| "Who are the core members?" | k-core |
| "Which groups are tightly knit?" | k-truss |
| "How far can influence spread?" | n-clique |
| "What if some people don't know each other?" | k-plex |
| "How cohesive is this group overall?" | ρ-dense subgraph |
| "Does this group have clear boundaries?" | ρ-dense core |

::: {.callout-note title="Try It Yourself"}
Take a small network you know well (your workplace, school department, or social media connections) and try identifying groups using different pseudo-clique definitions. How do the results differ? Which definition best captures your intuitive sense of "who belongs together"?
:::

::: {#fig-clique-pattern}

<img src="https://ars.els-cdn.com/content/image/1-s2.0-S0378873315000520-gr1.jpg" alt="Pseudo-clique patterns" width="80%" style="display: block; margin-left: auto; margin-right: auto;">

Illustation of different pseudo cliques. Taken from {footcite}`koujaku2016dense`.

:::

## Graph cut optimization approach

Another approach from computer science is to treat a community detection problem as an *optimization* problem. An early example is the **graph cut** problem, which asks to find the minimum number of edges to cut the graph into two disconnected components.

Specifically, let us consider cutting the network into two communities. Let $V_1$ and $V_2$ be the set of nodes in the two communities. Then, the cut is the number of edges between the two communities, which is given by

$$
\begin{align}
\text{Cut}(V_1, V_2) = \sum_{i \in V_1} \sum_{j \in V_2} A_{ij}
\end{align}
$$

Now, the community detection problem is translated into **an optimization problem**, with the goal of finding a cut $V_1, V_2$ that minimizes $\text{Cut}(V_1, V_2)$.

The description of this problem is not complete 😈. Let's find out what is missing by playing with the optimization problem.

::: {.callout-note title="Exercise"}
:class: tip

Can you identify what is missing in the description of the graph cut problem? Without this, the best cut is trivial. {{ "<a href='BASE_URL/vis/community-detection/index.html?scoreType=graphcut&numCommunities=2&randomness=1&dataFile=two-cliques.json'>Graph Cut Problem 🎮</a>".replace('BASE_URL', base_url) }}

::: {.callout collapse="true"}
**Click to reveal the answer!**

The missing element is a constraint: each community must contain at least one node. Without this, the trivial solution of placing all nodes in a single community would always yield a cut of zero.
:::

:::

## Modularity: measuring assortativity against null models

**Modularity** is by far the most widely used method for community detection. Modularity can be derived in many ways, but we will follow the one derived from assortativity.

**Assortativity** is a measure of the tendency of nodes to connect with nodes of the same attribute. The attribute, in our case, is the community that the node belongs to, and we say that a network is assortative if nodes of the same community are more likely to connect with each other than nodes of different communities.

Let's think about assortativity by using color balls and strings! 🎨🧵

Imagine we're playing a game as follows:

1. Picture each connection in our network as two colored balls joined by a piece of string. 🔴🟢--🔵🟡
2. The color of each ball shows which community it belongs to.
3. Now, let's toss all these ball-and-string pairs into a big bag.
4. We'll keep pulling out strings with replacement and checking if the balls on each end match colors.

The more color matches we find, the more assortative our network is. But, there's a catch! What if we got lots of matches just by luck? For example, if all our balls were the same color, we'd always get a match. But that doesn't tell us much about our communities. So, to be extra clever, we compare our results to a "random" version (null model):

1. We snip all the strings and mix up all the balls.
2. Then we draw pairs of balls at random *with replacement* and see how often the colors match.

By comparing our original network to this mixed-up version, we can see if our communities are really sticking together more than we'd expect by chance. This comparison against the random version is the heart of modularity. Unlike graph cut methods that aim to maximize assortativity directly, modularity measures assortativity *relative* to *a null model*.

::: {#fig-fig-modularity-game}

<img src="../figs/modularity.jpg" alt="Single node failure" width="100%">

Illustration of how modularity measures assortativity relative to a null model.
:::

Now, let's put on our math hats and make this colorful game a bit more precise. Let's introduce some helpful symbols to describe our network:
- $N$: This is our total number of nodes (or balls in our game)
- $M$: The number of edges (or strings) connecting our nodes
- $A_{ij}$: Adjacency matrix. If $A_{ij} = 1$, it means node $i$ and node $j$ are connected. If $A_{ij} = 0$, they're not connected.
- $k_i$: Degree of node $i$, i.e., how many edges a node has.
- $c_i$: Community of node $i$, i.e., which community a node belongs to.
- $\delta(c_i, c_j)$: Kronecker delta function. It gives us 1 if nodes $i$ and $j$ are the same color, and 0 if they're different.

::: {.callout-note title="Exercise"}
:class: tip

What is the probability of color matches for a given network? Derive the probability by using $\sum, M, A_{ij}, \delta(c_i, c_j)$.

::: {.callout-note collapse="true" title="Hint"}
Let's think about our colorful bag of balls and strings! 🎨🧵
First, ask yourself:
1. How many strings do we have in total? (This is our M!)
2. Now, out of all these strings, how many are the same color on both ends?
:::

:::

::: {.callout-note title="Exercise"}
:class: tip

What is the probability of color matches for the random version? Derive the probability by using $\sum, M, \delta(c_i, c_j), k_i,k_j$.

::: {.callout collapse="true"}
**Hint**
1. Imagine a big bag full of colorful balls, but this time without any strings. 🔴🟢🔵🟡
2. Now, think about picking one ball out of the bag. What are the chances of picking a specific color?
3. Then, put that ball back and pick another one. What are the odds this second ball matches the color of the first one?
:::

:::

The full modularity formula is covered in the coding section 😉.

## Pen and Paper Exercise

✍️ [Pen and Paper Exercise](./pen-and-paper/exercise.pdf) 🚢

```{footbibliography}
```