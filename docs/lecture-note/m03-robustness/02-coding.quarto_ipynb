{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Coding: Minimum Spanning Trees and Network Robustness\n",
        "\n",
        "## Minimum spanning tree\n",
        "\n",
        "Many networks are surprisingly sparse, with most nodes having only a few connections, in part because connections are costly.\n",
        "Like cables in power grids and human-to-human communications, networks are often built with cost constraints, and it is often of a great interest to find the most cost-effective structure.\n",
        "\n",
        "**Minimum spanning tree** is a tree that connects all the nodes in a network with the minimum total weight of edges.\n",
        "The term involves the following two concepts:\n",
        "\n",
        "- **Tree**: A network is a tree if it is connected and has no cycles.\n",
        "- **Spanning tree**: A spanning tree is a tree that spans all the nodes in a network.\n",
        "\n",
        "The minimum spanning tree may not be unique, meaning there can be multiple spanning trees with the same minimum total weight of edges for a network.\n",
        "\n",
        "![](../figs/minimum-spanning-tree.jpg){#fig-minimum-spanning-tree fig-alt=\"Minimum spanning tree of a network.\"}\n",
        "\n",
        ": Minimum spanning tree of a network. {#fig-minimum-spanning-tree}\n",
        "\n",
        "### How to find the minimum spanning tree\n",
        "\n",
        "**Kruskal's algorithm** and **Prim's algorithms** are two common methods to find a minimum spanning tree.\n",
        "Both start with an empty edge set and add the smallest weight edge iteratively, while ensuring that the edges form a tree, until all nodes are included.\n",
        "The difference between the two algorithms lies in the order of edge addition.\n",
        "\n",
        "**Kruskal's algorithm** operates as follows:\n",
        "1. Sort the edges by *the increasing order of the edge weights*.\n",
        "2. Select the edge with the smallest weight that does not form a cycle with the edges already in the tree.\n",
        "3. Repeat step 2 until all the nodes are connected.\n",
        "\n",
        "**Prim's algorithm**:\n",
        "1. Start with a singleton network $G$ consisting of a randomly chosen node.\n",
        "2. Add the smallest weight edge connecting $G$ to a node not in $G$.\n",
        "3. Repeat step 2 until all nodes are connected.\n",
        "\n",
        "{{ '[üöÄ Check out the Demo for Kruskal\\'s and Prim\\'s algorithm üåê]( BASE_URL/vis/kruskal-vs-prime.html)'.replace('BASE_URL', base_url) }}\n",
        "\n",
        "Kruskal's algorithm sorts the edges globally at the beginning, while Prim's algorithm sorts the edges locally at each step.\n",
        "Both algorithms find the same minimum spanning tree, provided that all edge weights are distinct.\n",
        "Otherwise, they may yield different trees.\n",
        "\n",
        "### Code\n",
        "\n",
        "`igraph` provides a function `igraph.Graph.spanning_tree` to find a minimum spanning tree in a given network.\n",
        "\n",
        "Let's first create a network with random edge weights."
      ],
      "id": "6ddef273"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import igraph\n",
        "import random\n",
        "\n",
        "g = igraph.Graph.Famous('Zachary')\n",
        "g.es[\"weight\"] = [random.randint(1, 10) for _ in g.es]\n",
        "igraph.plot(g, edge_width = g.es[\"weight\"])"
      ],
      "id": "0c9b701b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-note}\n",
        "[Zachary's karate club](https://en.wikipedia.org/wiki/Zachary%27s_karate_club) is a famous network of 34 members of a karate club and documents of their links between friends.\n",
        "The network is undirected and unweighted.\n",
        ":::\n",
        "\n",
        "The minimum spanning tree of the network can be found by the following code."
      ],
      "id": "cb102ae0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "gmst = g.spanning_tree(weights=g.es[\"weight\"]) # If not `weights` are not specified, the edges are assumed to be unweighted\n",
        "igraph.plot(gmst, edge_width = gmst.es[\"weight\"])"
      ],
      "id": "b1069e31",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Hands-on: Robustness (Random attack)\n",
        "\n",
        "<a target=\"_blank\" href=\"https://colab.research.google.com/github/skojaku/adv-net-sci/blob/main/notebooks/exercise-m03-robustness.ipynb\">\n",
        "  <img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/>\n",
        "</a>"
      ],
      "id": "3504ecb2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# If you are using Google Colab, uncomment the following line to install igraph\n",
        "# !sudo apt install libcairo2-dev pkg-config python3-dev\n",
        "# !pip install pycairo cairocffi\n",
        "# !pip install igraph"
      ],
      "id": "a3ad5a6c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We consider a small social network of 34 members in a university karate club, called Zachary's karate club network."
      ],
      "id": "4042cf17"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import igraph\n",
        "g = igraph.Graph.Famous(\"Zachary\")\n",
        "igraph.plot(g, vertex_size=20)"
      ],
      "id": "ac13efeb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Let's break the network üòà!\n",
        "We will remove nodes one by one and see how the connectivity of the network changes at each step.\n",
        "It is useful to create a copy of the network to keep the original network unchanged."
      ],
      "id": "a8984aed"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "g_original = g.copy()"
      ],
      "id": "ef4494c7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Robustness against random failures\n",
        "\n",
        "Let us remove a single node from the network. To this end, we need to first identify which nodes are in the network. With `igraph`, the IDs of the nodes in a graph are accessible through `Graph.vs.indices` as follows:"
      ],
      "id": "9b895e2f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(g.vs.indices)"
      ],
      "id": "b1308ef5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We randomly choose a node and remove it from the network by using `Graph.delete_vertices`."
      ],
      "id": "8f3ec34b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "node_idx = np.random.choice(g.vs.indices)\n",
        "g.delete_vertices(node_idx)\n",
        "print(\"Node removed:\", node_idx)\n",
        "print(\"Nodes remaining:\", g.vs.indices)"
      ],
      "id": "6d7f1555",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-note}\n",
        "`np.random.choice(array)` takes an array `array` and returns a single element from the array.\n",
        "For example, `np.random.choice(np.array([1, 2, 3]))` returns either 1, 2, or 3 with equal probability.\n",
        "See [the documentation](https://numpy.org/doc/stable/reference/random/generated/numpy.random.choice.html) for more details.\n",
        ":::\n",
        "\n",
        "The connectivity of the network is the fraction of nodes in the largest connected component of the network after node removal.\n",
        "We can get the connected components of the network by using `Graph.connected_components`."
      ],
      "id": "1d972877"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "components = g.connected_components()"
      ],
      "id": "c2f6575f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The sizes of the connected components are accessible via `Graph.connected_components.sizes`."
      ],
      "id": "c3bcacf4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "components.sizes()"
      ],
      "id": "ff5f4107",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Thus, the connectivity of the network can be computed by"
      ],
      "id": "388162ba"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "components = g.connected_components()\n",
        "connectivity = np.max(components.sizes()) / g_original.vcount()\n",
        "connectivity"
      ],
      "id": "b4e30f95",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Putting together the above code, let us compute the robustness profile of the network."
      ],
      "id": "df9065f1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "\n",
        "g = g_original.copy() # restore the network\n",
        "n_nodes = g.vcount()  # Number of nodes\n",
        "\n",
        "results = []\n",
        "for i in range(n_nodes -1):  # Loop if the network has at least one node\n",
        "\n",
        "    # Remove a randomly selected node\n",
        "    node_idx = np.random.choice(g.vs.indices)\n",
        "    g.delete_vertices(node_idx)\n",
        "\n",
        "    # Evaluate the connectivity\n",
        "    components = g.connected_components()\n",
        "    connectivity = np.max(components.sizes()) / g_original.vcount()\n",
        "\n",
        "    # Save the results\n",
        "    results.append(\n",
        "        {\n",
        "            \"connectivity\": connectivity,\n",
        "            \"frac_nodes_removed\": (i + 1) / n_nodes,\n",
        "        }\n",
        "    )\n",
        "\n",
        "df_robustness_profile = pd.DataFrame(results)"
      ],
      "id": "4799e606",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Let us plot the robustness profile."
      ],
      "id": "c3393972"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "\n",
        "sns.set(style='white', font_scale=1.2)\n",
        "sns.set_style('ticks')\n",
        "\n",
        "ax = df_robustness_profile.plot(\n",
        "    x=\"frac_nodes_removed\",\n",
        "    y=\"connectivity\",\n",
        "    kind=\"line\",\n",
        "    figsize=(5, 5),\n",
        "    label=\"Random attack\",\n",
        ")\n",
        "plt.xlabel(\"Proportion of nodes removed\")\n",
        "plt.ylabel(\"Connectivity\")\n",
        "plt.legend().remove()\n",
        "plt.show()"
      ],
      "id": "80ea9d99",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Targeted attack\n",
        "\n",
        "In a targeted attack, nodes are removed based on specific criteria rather than randomly.\n",
        "One common strategy is to remove nodes from the largest node degree to the smallest, based on the idea that removing nodes with many edges is more likely to disrupt the network connectivity.\n",
        "\n",
        "The degree of the nodes is accessible via `Graph.degree`."
      ],
      "id": "308cd0e3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(g_original.degree())"
      ],
      "id": "df2ea02d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We compute the robustness profile by removing nodes with the largest degree and measuring the connectivity of the network after each removal."
      ],
      "id": "e42e613b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "g = g_original.copy() # restore the network\n",
        "n_nodes = g.vcount()  # Number of nodes\n",
        "\n",
        "results = []\n",
        "for i in range(n_nodes -1):  # Loop if the network has at least one node\n",
        "\n",
        "    # Remove the nodes with thelargest degree\n",
        "    node_idx = g.vs.indices[np.argmax(g.degree())]\n",
        "    g.delete_vertices(node_idx)\n",
        "\n",
        "    # Evaluate the connectivity\n",
        "    components = g.connected_components()\n",
        "    connectivity = np.max(components.sizes()) / g_original.vcount()\n",
        "\n",
        "    # Save the results\n",
        "    results.append(\n",
        "        {\n",
        "            \"connectivity\": connectivity,\n",
        "            \"frac_nodes_removed\": (i + 1) / n_nodes,\n",
        "        }\n",
        "    )\n",
        "\n",
        "df_robustness_profile_targeted = pd.DataFrame(results)"
      ],
      "id": "b8cac529",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "sns.set(style='white', font_scale=1.2)\n",
        "sns.set_style('ticks')\n",
        "\n",
        "sns.set(style=\"white\", font_scale=1.2)\n",
        "sns.set_style(\"ticks\")\n",
        "\n",
        "ax = df_robustness_profile.plot(\n",
        "    x=\"frac_nodes_removed\",\n",
        "    y=\"connectivity\",\n",
        "    kind=\"line\",\n",
        "    figsize=(5, 5),\n",
        "    label=\"Random attack\",\n",
        ")\n",
        "ax = df_robustness_profile_targeted.plot(\n",
        "    x=\"frac_nodes_removed\",\n",
        "    y=\"connectivity\",\n",
        "    kind=\"line\",\n",
        "    label=\"Targeted attack\",\n",
        "    ax=ax,\n",
        ")\n",
        "ax.set_xlabel(\"Proportion of nodes removed\")\n",
        "ax.set_ylabel(\"Connectivity\")\n",
        "ax.legend(frameon=False)\n",
        "plt.show()"
      ],
      "id": "7716e073",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "While the network is robust against the random attacks, it is vulnerable to the degree-based targeted attack.\n",
        "\n",
        "## Percolation\n",
        "\n",
        "Network robustness can be viewed as a inverse process of **percolation** on a network. What is percolation?\n",
        "Imagine a grid where each square has a chance to become a little puddle. Two puddles are connected if they are next to each other. As more puddles appear, they start connecting with their neighbors to form bigger puddles. This is basically what percolation is all about!\n",
        "Random failure can be viewed as an inverse process of percolation, where a puddle is dried up (i.e., removed from the network),\n",
        "\n",
        "```{figure-md} percolation\n",
        "\n",
        "![](https://jamesmccaffrey.wordpress.com/wp-content/uploads/2021/07/percolation.jpg?w=584&h=389)\n",
        "\n",
        "Image taken from https://jamesmccaffrey.wordpress.com/2021/07/12/whatever-happened-to-percolation-theory/\n",
        "\n",
        "```\n",
        "\n",
        "Now, the big question is: When the probability of a node being puddle is $p$, how big can our largest puddle get? üåä\n",
        "As we increase the chance of puddles appearing (that's our $p$), the biggest puddle does not grow slowly but explodes in size when $p$ reaches a critical value $p_c$. This sudden change is what we call a *phase transition*! From the percolation perspective, we approach to the critical point from disconnected phase, whereas from the network robustness perspective, we approach to the critical point from connected phase."
      ],
      "id": "764a1f9c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        ":tags: [\"hide-input\"]\n",
        "\n",
        "import igraph as ig\n",
        "import numpy as np\n",
        "import seaborn as sns\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "\n",
        "def percolate(g, p):\n",
        "    return g.subgraph(np.where(np.random.rand(g.vcount()) < p)[0])\n",
        "\n",
        "\n",
        "def largest_cluster_size(g):\n",
        "    return g.connected_components().giant().vcount()\n",
        "\n",
        "\n",
        "n, nei = 500, 1\n",
        "g = ig.Graph.Lattice([n, n], nei=nei, directed=False, mutual=False, circular=False)\n",
        "\n",
        "p_values = np.linspace(0, 1, 20)\n",
        "largest_sizes = [largest_cluster_size(percolate(g, p)) / n**2 for p in p_values]\n",
        "\n",
        "sns.set(style=\"ticks\", font_scale=1.2)\n",
        "fig, ax = plt.subplots(figsize=(5, 5))\n",
        "sns.lineplot(x=p_values, y=largest_sizes, ax=ax, marker=\"o\")\n",
        "ax.set(\n",
        "    xlabel=\"Probability (p)\",\n",
        "    ylabel=\"Fractional Largest Cluster Size\",\n",
        "    title=\"Percolation on a 500x500 Lattice\",\n",
        ")\n",
        "sns.despine()\n",
        "\n",
        "critical_p = 0.592746  # Critical probability for 2D square lattice\n",
        "colors = sns.color_palette(\"colorblind\", 3)\n",
        "ax.axvline(x=critical_p, color=\"k\", linestyle=\"--\", alpha=0.7)\n",
        "ax.fill_betweenx(\n",
        "    y=[0, 1], x1=0, x2=critical_p, alpha=0.2, color=colors[0], label=\"Disconnected\"\n",
        ")\n",
        "ax.fill_betweenx(\n",
        "    y=[0, 1], x1=critical_p, x2=1, alpha=0.2, color=colors[1], label=\"Connected\"\n",
        ")\n",
        "ax.legend().remove()\n",
        "\n",
        "ax.annotate(\n",
        "    \"Disconnected\",\n",
        "    xy=(0.3, 0.5),\n",
        "    xytext=(0.4, 0.1),\n",
        "    textcoords=\"data\",\n",
        "    horizontalalignment=\"right\",\n",
        "    verticalalignment=\"center\",\n",
        "    fontsize=14,\n",
        "    fontweight=\"bold\",\n",
        ")\n",
        "ax.annotate(\n",
        "    \"Connected\",\n",
        "    xy=(0.9, 0.5),\n",
        "    xytext=(0.7, 0.1),\n",
        "    textcoords=\"data\",\n",
        "    horizontalalignment=\"left\",\n",
        "    verticalalignment=\"center\",\n",
        "    fontsize=14,\n",
        "    fontweight=\"bold\",\n",
        ")\n",
        "ax.set_xlim(0, 1)\n"
      ],
      "id": "7fc1a0cb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{note}\n",
        "\n",
        "Want to see this in action? üåü Check out this interactive simulation.\n",
        "Play around with it and watch how the puddles grow and connect. üåä\n",
        "\n",
        "[Bernoulli Percolation Simulation üåê](https://visualize-it.github.io/bernoulli_percolation/simulation.html) üîó\n",
        "\n",
        "```\n",
        "\n",
        "```{note}\n",
        "\n",
        "The transition at $p_c$ is discontinuous in the limit of large $N$, called *first-order phase transition*.\n",
        "In practice, it is often a continuous transition because of the finite size of the network.\n",
        "\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "### A criterion for the giant component\n",
        "\n",
        "Percolation theory focuses on lattice, a regular structure that is rare in real-world networks. What happens if the network has a complex structure?\n",
        "The Molloy-Reed criterion {footcite}`molloy1995critical` provides a simple condition for the existence of a giant component in a rewired network. It states that a giant component is likely to exist if:\n",
        "\n",
        "$$\n",
        "\\kappa_0 := \\frac{\\langle k^2 \\rangle}{\\langle k \\rangle} > 2\n",
        "$$\n",
        "\n",
        "where $k$ is the degree of a node, and $\\langle k \\rangle$ and $\\langle k^2 \\rangle$ are the average degree and the average of the square of the degree, respectively. The variable $\\kappa_0$ is a shorthand for the ratio. See the [Appendix](./04-appendix.md) for the derivation of this criterion.\n",
        "\n",
        "What does $\\kappa_0$ represent? It represents the heterogeneity of the degree distribution. For example, a high $\\kappa_0$ indicates that there are a few nodes with very high degrees and many nodes with low degrees. When $\\kappa_0$ is small, the nodes have similar degree. And Molloy-Reed criterion tells us an important fact about the role of degree distributions on the robustness of networks:\n",
        "the more heterogeneous the degree distribution is, the more likely the network is to have a giant component."
      ],
      "id": "ae04bb5f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        ":tags: [\"remove-input\"]\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "from scipy.stats import uniform, poisson, lognorm\n",
        "# Set Seaborn style\n",
        "sns.set_style('white')\n",
        "sns.set(font_scale=1.5)\n",
        "sns.set_style('ticks')\n",
        "\n",
        "# Set up the plot\n",
        "fig, axs = plt.subplots(1, 3, figsize=(15, 5))\n",
        "fig.suptitle('Degree distributions with different $\\\\kappa_0$ values with the same mean $\\\\langle k \\\\rangle=5$')\n",
        "\n",
        "# Set the average degree\n",
        "avg_k = 5\n",
        "samples = 3000\n",
        "\n",
        "# Uniform distribution\n",
        "k_uniform = np.array([avg_k] * samples)\n",
        "\n",
        "# Poisson distribution\n",
        "k_poisson = np.random.poisson(avg_k, size=samples)\n",
        "\n",
        "# Log-normal distribution\n",
        "k_lognorm = np.random.lognormal(mean=0, sigma=1, size=samples)\n",
        "k_lognorm = k_lognorm * avg_k / np.mean(k_lognorm)\n",
        "\n",
        "\n",
        "# Plot histograms\n",
        "sns.histplot(k_uniform, ax=axs[0], kde=True, stat=\"density\", discrete=True)\n",
        "axs[0].set_title(f'Uniform\\n$\\\\kappa_0 = {np.mean(k_uniform**2) / np.mean(k_uniform):.2f}$')\n",
        "axs[0].set_xlim(0, 10)\n",
        "\n",
        "sns.histplot(k_poisson, ax=axs[1], kde=True, stat=\"density\", discrete=True)\n",
        "axs[1].set_title(f'Poisson\\n$\\\\kappa_0 = {np.mean(k_poisson**2) / np.mean(k_poisson):.2f}$')\n",
        "\n",
        "sns.histplot(k_lognorm, ax=axs[2], kde=True, stat=\"density\", bins=20)\n",
        "axs[2].set_title(f'Log-normal\\n$\\\\kappa_0 = {np.mean(k_lognorm**2) / np.mean(k_lognorm):.2f}$')\n",
        "\n",
        "# Set labels and adjust layout\n",
        "for ax in axs:\n",
        "    ax.set_xlabel('Degree (k)')\n",
        "    ax.set_ylabel('Density')\n",
        "\n",
        "plt.tight_layout()\n",
        "sns.despine()"
      ],
      "id": "622031f4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{note}\n",
        "The rewired network considered here is **the configuration model**, where the edges are rewired randomly while keeping the degree distribution fixed. We will discuss more about the configuration model later.\n",
        "\n",
        "```\n",
        "\n",
        "### How many nodes are needed to break a network?\n",
        "\n",
        "When does a network become disconnected? Based on the Molloy-Reed criterion, we can identify the critical fraction of nodes $f_c$ that need to be removed for the giant component to disappear in a network with an arbitrary degree distribution. This critical point is given by {footcite}`cohen2000resilience`:\n",
        "\n",
        "$$\n",
        "f_c = 1 - \\frac{1}{\\frac{\\langle k^2 \\rangle}{\\langle k \\rangle} - 1}\n",
        "$$\n",
        "\n",
        "See the [Appendix](./04-appendix.md) for the derivation of this criterion.\n",
        "\n",
        "Let us illustrate this by considering two kinds of networks:\n",
        "\n",
        "**Degree homogeneous network**:\n",
        "\n",
        "In case of a degree homogeneous network like a random network considered in the exercise above,\n",
        "\n",
        "$$\n",
        "f_c = 1 - \\frac{1}{\\langle k \\rangle}\n",
        "$$\n",
        "\n",
        "This suggests that the threshold is determined by the average degree $\\langle k \\rangle$. A large $\\langle k \\rangle$ results in a larger $f_c$, meaning that the network is more robust against random failures.\n",
        "\n",
        "**Degree heterogeneous network**:\n",
        "\n",
        "Most real-world networks are degree heterogeneous, i.e., the degree distribution $P(k) \\sim k^{-\\gamma}$ follows a power law (called *scale-free* network).\n",
        "In this case, $f_c$ is given by\n",
        "\n",
        "$$\n",
        "f_c =\n",
        "\\begin{cases}\n",
        "1 - \\dfrac{1}{\\frac{\\gamma-2}{3-\\gamma} k_{\\text{min}} ^{\\gamma-2} k_{\\text{max}}^{3-\\gamma} -1} & \\text{if } 2 < \\gamma < 3 \\\\\n",
        "1 - \\dfrac{1}{\\frac{\\gamma-2}{3-\\gamma} k_{\\text{min}} - 1} & \\text{if } \\gamma > 3 \\\\\n",
        "\\end{cases}\n",
        "$$\n",
        "\n",
        "where $k_{\\text{min}}$ and $k_{\\text{max}}$ are the minimum and maximum degree, respectively.\n",
        "The variable $\\gamma$ is the exponent of the power law degree distribution, controlling the degree heterogeneity, where a lower $\\gamma$ results in a more degree heterogeneous network.\n",
        "\n",
        "- For regime $2 < \\gamma < 3$, the critical threshold $f_c$ is determined by the extreme values of the degree distribution, $k_{\\text{min}}$ and $k_{\\text{max}}$.\n",
        "And $f_c \\rightarrow 1$ when the maximum degree $k_{\\text{max}} \\in [k_{\\text{min}}, N-1]$ increases.\n",
        "Notably, in this regime, the maximum degree $k_{\\text{max}}$ increases as the network size $N$ increases, and this makes $f_c \\rightarrow 1$.\n",
        "\n",
        "- For regime $\\gamma > 3$, the critical threshold $f_c$ is influenced by the minimum degree $k_{\\text{min}}$. In contrast to $k_{\\text{max}}$, $k_{\\text{min}}$ remains constant as the network size $N$ grows. Consequently, the network disintegrates when a finite fraction of its nodes are removed.\n",
        "\n",
        "### Case study: Airport network\n",
        "\n",
        "Let's consider an empirical network of international airports, where nodes are airports and edges denote a regular commercial flight between two airports.\n",
        "\n",
        "\n",
        "Data loading:"
      ],
      "id": "2c2b0769"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        ":tags: [\"hide-input\", \"hide-output\"]\n",
        "\n",
        "# Import necessary libraries\n",
        "import igraph as ig\n",
        "import numpy as np\n",
        "import seaborn as sns\n",
        "import matplotlib.pyplot as plt\n",
        "import pandas as pd\n",
        "\n",
        "# Load the airport network data from a CSV file\n",
        "df = pd.read_csv(\"https://raw.githubusercontent.com/skojaku/core-periphery-detection/master/data/edge-table-airport.csv\")\n",
        "\n",
        "# Process the edge data\n",
        "edges = df[[\"source\", \"target\"]].to_numpy()\n",
        "edges = np.unique(edges.reshape(-1), return_inverse=True)[1]\n",
        "edges = edges.reshape(-1, 2)\n",
        "\n",
        "# Create the original graph\n",
        "g = ig.Graph()\n",
        "g.add_vertices(np.unique(edges) + 1)\n",
        "g.add_edges([tuple(edge) for edge in edges])"
      ],
      "id": "de4a2bcd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Based on the argument above, we can predict the critical point $f_c$ for the airport network as follows:"
      ],
      "id": "f8da45ed"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "g # igraph object of the airport network\n",
        "\n",
        "# Compute the degree distribution\n",
        "deg = np.array(g.degree())\n",
        "\n",
        "k_ave = np.mean(deg)\n",
        "k_2 = np.mean(deg **2)\n",
        "\n",
        "# Compute the critical fraction of nodes that need to be removed (prediction)\n",
        "f_c = 1 - 1 / (k_2 / k_ave - 1)\n",
        "print(f\"The critical fraction of nodes that need to be removed is predicted to be {f_c:.3f}\")"
      ],
      "id": "11df5775",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The $f_c$ is very close to 1, meaning that the network is highly robust to random failures that it keeps the giant component until when almost all nodes are removed.\n",
        "Let us confirm this by simulating the random failures."
      ],
      "id": "58aa63d1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        ":tags: [\"hide-input\"]\n",
        "\n",
        "# Create a copy of the original graph for manipulation\n",
        "g_damaged = g.copy()\n",
        "n_nodes = g.vcount()  # Number of nodes in the graph\n",
        "\n",
        "# Initialize list to store results\n",
        "results = []\n",
        "\n",
        "# Simulate random node removal and measure network connectivity\n",
        "for i in range(n_nodes - 1):  # Loop until only one node remains\n",
        "\n",
        "    # Randomly select and remove a node\n",
        "    node_idx = np.random.choice(g_damaged.vs.indices)\n",
        "    g_damaged.delete_vertices(node_idx)\n",
        "\n",
        "    # Evaluate the connectivity of the remaining network\n",
        "    components = g_damaged.connected_components()\n",
        "    connectivity = np.max(components.sizes()) / g.vcount()\n",
        "\n",
        "    # Save the results\n",
        "    results.append(\n",
        "        {\n",
        "            \"connectivity\": connectivity,\n",
        "            \"frac_nodes_removed\": (i + 1) / n_nodes,\n",
        "        }\n",
        "    )\n",
        "\n",
        "# Convert results to a DataFrame\n",
        "df_robustness_profile = pd.DataFrame(results)\n",
        "\n",
        "# Set up the plot style\n",
        "sns.set(style='white', font_scale=1.2)\n",
        "sns.set_style('ticks')\n",
        "\n",
        "# Create the plot\n",
        "ax = df_robustness_profile.plot(\n",
        "    x=\"frac_nodes_removed\",\n",
        "    y=\"connectivity\",\n",
        "    kind=\"line\",\n",
        "    figsize=(5, 5),\n",
        "    label=\"Random attack\",\n",
        "    linewidth=2,\n",
        "    color = sns.color_palette()[0]\n",
        ")\n",
        "\n",
        "# Set labels for x and y axes\n",
        "plt.xlabel(\"Proportion of nodes removed\")\n",
        "plt.ylabel(\"Fractional size of largest component\")\n",
        "\n",
        "# Remove the legend\n",
        "plt.legend().remove()\n",
        "\n",
        "# Add a diagonal line from top left to bottom right\n",
        "ax.plot([0, 1], [1, 0], color='gray', linestyle='--')\n",
        "\n",
        "# Adjust the plot limits to ensure the diagonal line is visible\n",
        "ax.set_xlim(0, 1)\n",
        "ax.set_ylim(0, 1)\n",
        "\n",
        "# Add a vertical line at the critical fraction\n",
        "ax.axvline(x=f_c, color='red', linestyle='--', alpha=0.7, label=\"Critical fraction\")\n",
        "\n",
        "# Remove top and right spines of the plot\n",
        "sns.despine()"
      ],
      "id": "095d7342",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The robustness profile of the airport network shows a very robust nature of the network, i.e., the airport network keeps the giant component until almost all nodes are removed.\n",
        "\n",
        "\n",
        "### Targeted attacks\n",
        "\n",
        "A key implication of the random failures is that a hub plays a critical role in holding the network together. This also implies a vulnerability of the network to targeted attacks. Namely, if we remove the hub preferentially, the network can be quickly disconnected into small components.\n",
        "\n",
        "One can consider a targeted attack as a process of reducing the degree of nodes in a network. The degree-based attack, for example, reduces the maximum degree of the network, together with the degrees of neighboring nodes.\n",
        "An effective attack is one that quickly breaks the Molloy-Reed criterion, and from this perspective, the degree-based attack is not effective because it reduces the maximum degree of the network, a major contributor to the degree heterogeneity, $\\kappa_0$.\n",
        "\n",
        "\n",
        "### How to design a robust network?\n",
        "\n",
        "Based on the percolation theory, how we do we design a network that is robust against random failures and targeted attacks? Two key ingredients are:\n",
        "\n",
        "1. **Degree heterogeneity**: As we have seen in the percolation theory, the more heterogeneous the degree distribution is, the more likely the network is to have a giant component.\n",
        "\n",
        "2. **Resilience to hub removal**: A network is vulnerable to targeted attacks if the removal of a single node significantly decreases the heterogeneity of the degree distribution. The most susceptible structure is a star graph, where a central node connects to all other nodes, as removing this central node will disconnect the network.\n",
        "\n",
        "```{footbibliography}\n",
        "```"
      ],
      "id": "f2ee8107"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "netdatasci",
      "language": "python",
      "display_name": "netdatasci",
      "path": "/Users/skojaku-admin/Library/Jupyter/kernels/netdatasci"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}