{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Minimum spanning tree\n",
        "\n",
        "Many networks are surprisingly sparse, with most nodes having only a few connections, in part because connections are costly.\n",
        "Like cables in power grids and human-to-human communications, networks are often built with cost constraints, and it is often of a great interest to find the most cost-effective structure.\n",
        "\n",
        "**Minimum spanning tree** is a tree that connects all the nodes in a network with the minimum total weight of edges.\n",
        "The term involves the following two concepts:\n",
        "\n",
        "- **Tree**: A network is a tree if it is connected and has no cycles.\n",
        "- **Spanning tree**: A spanning tree is a tree that spans all the nodes in a network.\n",
        "\n",
        "The minimum spanning tree may not be unique, meaning there can be multiple spanning trees with the same minimum total weight of edges for a network.\n",
        "\n",
        "![](../figs/minimum-spanning-tree.jpg){#fig-minimum-spanning-tree fig-alt=\"Minimum spanning tree of a network.\"}\n",
        "\n",
        ": Minimum spanning tree of a network. {#fig-minimum-spanning-tree}\n",
        "\n",
        "## How to find the minimum spanning tree\n",
        "\n",
        "**Kruskal's algorithm** and **Prim's algorithms** are two common methods to find a minimum spanning tree.\n",
        "Both start with an empty edge set and add the smallest weight edge iteratively, while ensuring that the edges form a tree, until all nodes are included.\n",
        "The difference between the two algorithms lies in the order of edge addition.\n",
        "\n",
        "**Kruskal's algorithm** operates as follows:\n",
        "1. Sort the edges by *the increasing order of the edge weights*.\n",
        "2. Select the edge with the smallest weight that does not form a cycle with the edges already in the tree.\n",
        "3. Repeat step 2 until all the nodes are connected.\n",
        "\n",
        "**Prim's algorithm**:\n",
        "1. Start with a singleton network $G$ consisting of a randomly chosen node.\n",
        "2. Add the smallest weight edge connecting $G$ to a node not in $G$.\n",
        "3. Repeat step 2 until all nodes are connected.\n",
        "\n",
        "{{ '[üöÄ Check out the Demo for Kruskal\\'s and Prim\\'s algorithm üåê]( BASE_URL/vis/kruskal-vs-prime.html)'.replace('BASE_URL', base_url) }}\n",
        "\n",
        "Kruskal's algorithm sorts the edges globally at the beginning, while Prim's algorithm sorts the edges locally at each step.\n",
        "Both algorithms find the same minimum spanning tree, provided that all edge weights are distinct.\n",
        "Otherwise, they may yield different trees.\n",
        "\n",
        "## Code\n",
        "\n",
        "`igraph` provides a function `igraph.Graph.spanning_tree` to find a minimum spanning tree in a given network.\n",
        "\n",
        "Let's first create a network with random edge weights."
      ],
      "id": "43f8ed99"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import igraph\n",
        "import random\n",
        "\n",
        "g = igraph.Graph.Famous('Zachary')\n",
        "g.es[\"weight\"] = [random.randint(1, 10) for _ in g.es]\n",
        "igraph.plot(g, edge_width = g.es[\"weight\"])"
      ],
      "id": "22dc4d56",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-note}\n",
        "[Zachary's karate club](https://en.wikipedia.org/wiki/Zachary%27s_karate_club) is a famous network of 34 members of a karate club and documents of their links between friends.\n",
        "The network is undirected and unweighted.\n",
        ":::\n",
        "\n",
        "The minimum spanning tree of the network can be found by the following code."
      ],
      "id": "be269b88"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "gmst = g.spanning_tree(weights=g.es[\"weight\"]) # If not `weights` are not specified, the edges are assumed to be unweighted\n",
        "igraph.plot(gmst, edge_width = gmst.es[\"weight\"])"
      ],
      "id": "79b00e7a",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "advnetsci",
      "language": "python",
      "display_name": "Python (advnetsci)",
      "path": "/Users/skojaku-admin/Library/Jupyter/kernels/advnetsci"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}