"""Main Discord bot implementation."""

import asyncio
from typing import Optional
import discord
from discord import app_commands
from discord.ext import commands

from config.settings import settings, ModuleConfig
from config.logging_config import configure_logging, get_logger, LogContext
from content.cache_manager import cache_manager
from bot.commands.conversation_handler import ConversationHandler
from bot.utils.message_parser import MessageParser
from bot.utils.context_manager import context_manager
from llm.prompt_templates import PromptTemplates

# Configure logging
configure_logging()
logger = get_logger(__name__)


class AITutorBot(commands.Bot):
    """AI Tutor Discord Bot."""

    def __init__(self):
        # Configure bot intents
        intents = discord.Intents.default()
        intents.message_content = True
        intents.members = True

        super().__init__(
            command_prefix='/',
            intents=intents,
            help_command=None,  # We'll implement custom help
            case_insensitive=True
        )

        # Initialize unified handler
        self.conversation_handler = ConversationHandler()
        self.message_parser = MessageParser()

    async def setup_hook(self):
        """Initialize bot components."""
        logger.info("Starting AI Tutor Bot setup...")

        try:
            # Initialize cache manager
            await cache_manager.initialize()

            # Start context manager
            from bot.utils.context_manager import context_manager
            await context_manager.start()

            # Clear existing slash commands first to ensure clean slate
            self.tree.clear_commands(guild=None)  # Clear global commands

            # Add commands
            await self._setup_commands()

            # Add slash commands
            await self._setup_slash_commands()

            # Sync commands with Discord
            await self.tree.sync()

            logger.info("Bot setup completed successfully - slash commands synced")

        except Exception as e:
            logger.error("Bot setup failed", **LogContext.error("bot_setup", error=str(e)))
            raise

    async def on_ready(self):
        """Called when bot is ready."""
        logger.info("Bot is ready",
                   bot_name=self.user.name,
                   guild_count=len(self.guilds),
                   user_count=sum(guild.member_count for guild in self.guilds))

        # Set bot status
        activity = discord.Activity(
            type=discord.ActivityType.watching,
            name="students learn | /help for commands"
        )
        await self.change_presence(activity=activity)

        # Join existing threads in all guilds
        await self._join_existing_threads()

    async def on_guild_join(self, guild):
        """Called when bot joins a new guild."""
        logger.info("Joined new guild",
                   guild_name=guild.name,
                   guild_id=guild.id,
                   member_count=guild.member_count)

    async def on_thread_create(self, thread):
        """Called when a new thread is created."""
        try:
            # Automatically join new threads so the bot can respond
            await thread.join()
            logger.info("Auto-joined new thread",
                       thread_id=thread.id,
                       thread_name=thread.name,
                       guild_id=thread.guild.id)
        except discord.Forbidden:
            logger.warning("Cannot join thread - insufficient permissions",
                         thread_id=thread.id,
                         guild_id=thread.guild.id)
        except discord.HTTPException as e:
            logger.error("Failed to auto-join thread",
                       thread_id=thread.id,
                       guild_id=thread.guild.id,
                       error=str(e))

    async def on_message(self, message):
        """Handle incoming messages."""
        # Ignore bot messages
        if message.author.bot:
            return

        # Log user activity
        is_dm = isinstance(message.channel, discord.DMChannel)
        is_thread = isinstance(message.channel, discord.Thread)
        logger.debug("Message received",
                    user_id=message.author.id,
                    guild_id=message.guild.id if message.guild else None,
                    channel_id=message.channel.id,
                    content_length=len(message.content),
                    is_dm=is_dm,
                    is_thread=is_thread)

        # Handle DM messages
        if is_dm:
            await self._handle_dm_message(message)
            return

        # For threads, ensure bot can respond (may need to join thread)
        if is_thread and message.guild:
            try:
                # Check if bot is a member of the thread
                thread = message.channel
                if not thread.me:
                    # Bot is not in the thread, try to join
                    await thread.join()
                    logger.info("Joined thread", thread_id=thread.id, thread_name=thread.name)
            except discord.Forbidden:
                logger.warning("Cannot join thread - insufficient permissions",
                             thread_id=message.channel.id)
                return
            except discord.HTTPException as e:
                logger.error("Failed to join thread",
                           thread_id=message.channel.id, error=str(e))
                return

        # Handle mentions of the bot (works in both channels and threads)
        if self.user in message.mentions:
            await self._handle_mention(message)
            return

        # Handle guild messages (including threads) - check for module markers in non-command messages
        if not message.content.startswith('/'):
            module_markers = self.message_parser.extract_module_markers(message.content)
            if module_markers:
                # Treat as implicit ask command
                await self._handle_implicit_question(message)
                return

        # Process commands
        await self.process_commands(message)

    async def on_command_error(self, ctx, error):
        """Handle command errors."""
        if isinstance(error, commands.CommandNotFound):
            await ctx.send(PromptTemplates.error_prompt("invalid_command"))
        elif isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(f"‚ùå Missing required argument: `{error.param.name}`")
        elif isinstance(error, commands.BadArgument):
            await ctx.send(f"‚ùå Invalid argument: {str(error)}")
        else:
            logger.error("Command error",
                        **LogContext.error("command_error",
                                         command=ctx.command.name if ctx.command else "unknown",
                                         user_id=ctx.author.id,
                                         error=str(error)))
            await ctx.send("‚ùå Something went wrong. Please try again.")

    async def _setup_commands(self):
        """Set up bot commands."""

        @self.command(name='help')
        async def help_command(ctx):
            """Show help information."""
            help_text = PromptTemplates.help_prompt(ModuleConfig.get_all_modules())

            embed = discord.Embed(
                title="ü§ñ AI Tutor Bot",
                description=help_text,
                color=discord.Color.blue()
            )

            await ctx.send(embed=embed)

            logger.info("Help command used",
                       **LogContext.user_action(ctx.author.id, "help"))

        @self.command(name='ask')
        async def ask_command(ctx, module: str = None, *, question: str):
            """Ask a question with optional module code (e.g., /ask m01 What is an Euler tour?)"""
            if module:
                # Prepend module marker to question for parsing
                full_question = f"#{module} {question}"
            else:
                full_question = question
            await self.conversation_handler.handle_user_message(ctx, full_question)

        @self.command(name='chat', aliases=['talk', 'learn'])
        async def chat_command(ctx, *, message: str):
            """Chat with me naturally - no module required! Ask questions, request quizzes, or get help!"""
            await self.conversation_handler.handle_user_message(ctx, message)

        @self.command(name='context', aliases=['ctx'])
        async def context_command(ctx):
            """Show your current learning context."""
            await self.conversation_handler.handle_context_command(ctx)

        @self.command(name='reset')
        async def reset_command(ctx):
            """Reset your conversation history."""
            await self.conversation_handler.handle_reset_command(ctx)

        @self.command(name='quiz')
        async def smart_quiz_command(ctx, module: str = None, *, subject: str = None):
            """Smart quiz that automatically chooses concept-quiz or code-quiz based on your learning needs"""
            await self.conversation_handler.handle_smart_quiz_command(ctx, module, subject)

        @self.command(name='concept-quiz', aliases=['concept_quiz', 'conceptquiz'])
        async def concept_quiz_command(ctx, module: str = None, format: str = "free-form", *, subject: str = None):
            """Request a concept-based quiz with building-block concepts (e.g., /concept-quiz m01 multiple-choice)"""
            await self.conversation_handler.handle_concept_quiz_command(ctx, module, format, subject)

        @self.command(name='code-quiz', aliases=['code_quiz', 'codequiz'])
        async def code_quiz_command(ctx, module_id: str = None, *, subject: str = None):
            """Generate Python code quiz questions (e.g., /code-quiz m01 graph traversal)"""
            await self.conversation_handler.handle_code_quiz_command(ctx, module_id, subject)



        @self.command(name='status')
        async def status_command(ctx):
            """Show bot status and statistics."""
            if not await self._is_admin(ctx.author):
                await ctx.send("‚ùå This command is only available to administrators.")
                return

            try:
                cache_stats = await cache_manager.get_stats()

                embed = discord.Embed(
                    title="üîß Bot Status",
                    color=discord.Color.green()
                )

                embed.add_field(
                    name="System Info",
                    value=f"Guilds: {len(self.guilds)}\nUsers: {sum(g.member_count for g in self.guilds)}\nLatency: {round(self.latency * 1000)}ms",
                    inline=True
                )

                embed.add_field(
                    name="Cache Stats",
                    value=f"Memory Cache: {cache_stats['memory_cache_size']}/{cache_stats['max_memory_size']}\nRedis: {'‚úÖ' if cache_stats['redis_connected'] else '‚ùå'}",
                    inline=True
                )

                await ctx.send(embed=embed)

            except Exception as e:
                logger.error("Status command error", error=str(e))
                await ctx.send("‚ùå Could not retrieve status information.")

    async def _setup_slash_commands(self):
        """Set up Discord slash commands."""
        from discord import app_commands

        @self.tree.command(name="chat", description="Chat naturally with the AI tutor - no module required!")
        @app_commands.describe(message="Your message - ask questions, request quizzes, or just chat naturally")
        async def slash_chat(interaction: discord.Interaction, message: str):
            """Natural chat with conversation handler - no module content required."""
            # Create a mock context for slash commands
            ctx = self._create_slash_context(interaction)

            await interaction.response.defer()
            await self.conversation_handler.handle_user_message(ctx, message)

        @self.tree.command(name="ask", description="Ask a question about the course material")
        @app_commands.describe(
            question="Your question about the course content", 
            module="Optional module code (e.g., m01, m02)"
        )
        async def slash_ask(interaction: discord.Interaction, question: str, module: str = None):
            """Ask a question with optional module specification."""
            try:
                ctx = self._create_slash_context(interaction)
                await interaction.response.defer()
                if module:
                    # Prepend module marker to question for parsing
                    full_question = f"#{module} {question}"
                else:
                    full_question = question
                await self.conversation_handler.handle_user_message(ctx, full_question)
            except discord.errors.NotFound:
                # Interaction expired or already responded to
                logger.warning("Slash ask command interaction expired", user_id=interaction.user.id)
                if not interaction.response.is_done():
                    try:
                        await interaction.response.send_message("‚ùå Request timed out. Please try again.", ephemeral=True)
                    except:
                        pass

        @self.tree.command(name="quiz", description="Smart quiz that automatically chooses the best quiz type for you")
        @app_commands.describe(
            module="Optional module code (e.g., m01, m02)",
            subject="Optional: Specific topic to focus on (e.g., graph algorithms, clustering)"
        )
        async def slash_smart_quiz(interaction: discord.Interaction, module: str = None, subject: str = None):
            """Smart quiz that automatically selects concept-quiz or code-quiz based on learning needs."""
            try:
                ctx = self._create_slash_context(interaction)
                await interaction.response.defer()
                await self.conversation_handler.handle_smart_quiz_command(ctx, module, subject)
            except discord.errors.NotFound:
                logger.warning("Slash smart quiz command interaction expired", user_id=interaction.user.id)
                if not interaction.response.is_done():
                    try:
                        await interaction.response.send_message("‚ùå Request timed out. Please try again.", ephemeral=True)
                    except:
                        pass

        @self.tree.command(name="concept-quiz", description="Request a concept-based quiz with building-block fundamentals")
        @app_commands.describe(
            format="Quiz question format",
            module="Optional module code (e.g., m01, m02)",
            subject="Optional: Specific topic to focus on (e.g., graph algorithms, clustering)"
        )
        @app_commands.choices(format=[
            app_commands.Choice(name="Multiple Choice", value="multiple-choice"),
            app_commands.Choice(name="Free Form", value="free-form"),
            app_commands.Choice(name="Short Answer", value="short-answer"),
            app_commands.Choice(name="True/False", value="true-false"),
            app_commands.Choice(name="Fill in the Blank", value="fill-blank")
        ])
        async def slash_concept_quiz(interaction: discord.Interaction, format: str = "free-form", module: str = None, subject: str = None):
            """Request a concept-based quiz with building-block concepts."""
            try:
                ctx = self._create_slash_context(interaction)
                await interaction.response.defer()
                await self.conversation_handler.handle_concept_quiz_command(ctx, module, format, subject)
            except discord.errors.NotFound:
                logger.warning("Slash concept quiz command interaction expired", user_id=interaction.user.id)
                if not interaction.response.is_done():
                    try:
                        await interaction.response.send_message("‚ùå Request timed out. Please try again.", ephemeral=True)
                    except:
                        pass

        @self.tree.command(name="code-quiz", description="Generate Python code quiz questions")
        @app_commands.describe(
            module_id="Optional module ID (e.g., m01, m02)",
            subject="Optional: Specific topic to focus on (e.g., graph traversal, clustering)"
        )
        async def slash_code_quiz(interaction: discord.Interaction, module_id: str = None, subject: str = None):
            """Generate Python code quiz questions from module code."""
            try:
                ctx = self._create_slash_context(interaction)
                await interaction.response.defer()
                await self.conversation_handler.handle_code_quiz_command(ctx, module_id, subject)
            except discord.errors.NotFound:
                # Interaction expired or already responded to
                logger.warning("Slash code-quiz command interaction expired", user_id=interaction.user.id)
                if not interaction.response.is_done():
                    try:
                        await interaction.response.send_message("‚ùå Request timed out. Please try again.", ephemeral=True)
                    except:
                        pass

        @self.tree.command(name="help", description="Get help and see available commands")
        async def slash_help(interaction: discord.Interaction):
            """Show help."""
            help_text = PromptTemplates.help_prompt(ModuleConfig.get_all_modules())

            embed = discord.Embed(
                title="ü§ñ AI Tutor - Unified Learning Mode",
                description="I can help you learn in a natural, conversational way!",
                color=discord.Color.blue()
            )

            embed.add_field(
                name="üí¨ Natural Conversation",
                value="Use `/chat` to talk naturally - no module required! I'll understand whether you want to:\n"
                      "‚Ä¢ Ask questions: *\"What is a small world network?\"*\n"
                      "‚Ä¢ Request quizzes: *\"Quiz me on graph theory\"*\n"
                      "‚Ä¢ Just chat: *\"Hello! How are you?\"*",
                inline=False
            )

            embed.add_field(
                name="üß† Smart Quiz System",
                value="‚Ä¢ `/quiz` - AI chooses the best quiz type for you!\n"
                      "‚Ä¢ `/concept-quiz` - Theory & building-block concepts\n"
                      "‚Ä¢ `/code-quiz` - Python programming exercises\n"
                      "Building-block concepts help master fundamentals (e.g., degree calculation for Euler paths)",
                inline=False
            )

            embed.add_field(
                name="üîß Slash Commands",
                value="‚Ä¢ `/chat <message>` - Natural conversation\n"
                      "‚Ä¢ `/ask [module] <question>` - Ask about course content\n"
                      "‚Ä¢ `/quiz [module] [subject]` - Smart quiz (auto-chooses best type)\n"
                      "‚Ä¢ `/concept-quiz [module] [format] [subject]` - Concept & building-block quizzes\n"
                      "‚Ä¢ `/code-quiz [module] [subject]` - Python coding exercises\n"
                      "‚Ä¢ `/status [type]` - Check learning progress (summary/concepts/detailed/recent/profile)\n"
                      "‚Ä¢ `/help` - Show this help",
                inline=False
            )

            embed.add_field(
                name="üìö Available Modules",
                value=", ".join([f"**{k.upper()}**" for k in ModuleConfig.get_all_modules().keys()]),
                inline=False
            )

            await interaction.response.send_message(embed=embed)

        # Example of a new app command following the pattern you provided
        @self.tree.command(
            name="status",
            description="Check your current learning status and progress"
        )
        @app_commands.describe(
            type="Status type: 'summary' (quick counts), 'detailed' (comprehensive analysis), 'recent' (latest activity), 'concepts' (learned topics), 'profile' (learning profile)"
        )
        @app_commands.choices(type=[
            app_commands.Choice(name="Summary (Quick Overview)", value="summary"),
            app_commands.Choice(name="Detailed (Comprehensive Analysis)", value="detailed"),
            app_commands.Choice(name="Recent Activity", value="recent"),
            app_commands.Choice(name="Concepts Learned", value="concepts"),
            app_commands.Choice(name="Learning Profile", value="profile")
        ])
        async def slash_status(interaction: discord.Interaction, type: str = "summary"):
            """Check learning status."""
            user_id = interaction.user.id

            try:
                await interaction.response.defer()  # Allow time for processing
                
                if type == "summary":
                    # Quick overview with counts (original functionality)
                    stats = await self.conversation_handler.get_user_learning_stats(user_id)

                    embed = discord.Embed(
                        title="üìä Your Learning Status - Summary",
                        color=discord.Color.green()
                    )

                    embed.add_field(
                        name="Current Module",
                        value=f"`{stats['current_module']}`" if stats['current_module'] else "None selected",
                        inline=True
                    )

                    embed.add_field(
                        name="Questions Asked",
                        value=str(stats['user_stats']['questions_asked']),
                        inline=True
                    )

                    embed.add_field(
                        name="Quiz Questions Answered",
                        value=str(stats['user_stats']['quiz_questions_answered']),
                        inline=True
                    )

                    embed.add_field(
                        name="Concepts Learned",
                        value=str(stats['user_stats']['concepts_learned']),
                        inline=True
                    )

                    embed.add_field(
                        name="Total Interactions",
                        value=str(stats['user_stats']['total_interactions']),
                        inline=True
                    )

                    embed.add_field(
                        name="Active Quiz",
                        value="Yes" if stats['active_quiz'] else "No",
                        inline=True
                    )

                    embed.set_footer(text="üí° Use /status profile to see your learning profile")

                elif type == "detailed":
                    # Show detailed interaction analysis from SQL data
                    from services.learning_tracker import learning_tracker
                    detailed_data = await learning_tracker.get_user_detailed_analysis(str(user_id), limit=10)
                    
                    embed = discord.Embed(
                        title="üîç Detailed Learning Analysis",
                        color=discord.Color.blue()
                    )
                    
                    if not detailed_data:
                        embed.description = "No detailed analysis data available yet. Start learning to see your progress!"
                    else:
                        analysis_text = ""
                        for idx, analysis in enumerate(detailed_data[:5], 1):  # Show top 5
                            timestamp = analysis['timestamp'][:16].replace('T', ' ')
                            interaction_type = analysis['interaction_type'].replace('_', ' ').title()
                            module = analysis['module_id'] or 'General'
                            confidence = analysis['confidence_score'] or 0
                            
                            analysis_text += f"**{idx}. {interaction_type}** ({module})\n"
                            analysis_text += f"üìÖ {timestamp} | Confidence: {confidence}%\n"
                            
                            if analysis['learning_summary']:
                                analysis_text += f"üí° {analysis['learning_summary']}\n"
                            
                            if analysis['concepts_clarified']:
                                concepts = ", ".join(analysis['concepts_clarified'][:3])
                                analysis_text += f"üéØ Concepts: {concepts}\n"
                            
                            analysis_text += "\n"
                        
                        embed.description = analysis_text[:4000]  # Discord limit
                    
                    embed.set_footer(text="Showing your latest learning interactions")

                elif type == "recent":
                    # Show recent learning activity from SQL data
                    from services.learning_tracker import learning_tracker
                    recent_data = await learning_tracker.get_user_recent_learning(str(user_id), limit=8)
                    
                    embed = discord.Embed(
                        title="‚è∞ Recent Learning Activity",
                        color=discord.Color.orange()
                    )
                    
                    if not recent_data:
                        embed.description = "No recent activity found. Start learning to see your progress!"
                    else:
                        activity_text = ""
                        for idx, event in enumerate(recent_data[:8], 1):
                            timestamp = event['timestamp'][:16].replace('T', ' ')
                            event_type = event['event_type'].replace('_', ' ').title()
                            title = event['event_title'] or event_type
                            module = event.get('module_id', 'General')
                            
                            activity_text += f"**{idx}. {title}** ({module})\n"
                            activity_text += f"üìÖ {timestamp}\n"
                            
                            if event['event_description']:
                                activity_text += f"üìù {event['event_description']}\n"
                            
                            activity_text += "\n"
                        
                        embed.description = activity_text[:4000]  # Discord limit
                    
                    embed.set_footer(text="Your recent learning events")

                elif type == "concepts":
                    # Show comprehensive concept mastery status from YAML + database integration
                    from services.learning_tracker import learning_tracker
                    from services.concept_progression import concept_progression
                    
                    mastery_status = await learning_tracker.get_user_concept_mastery_status(str(user_id))
                    recommendations = await concept_progression.get_next_recommended_concepts(str(user_id), limit=3)
                    
                    embed = discord.Embed(
                        title="üéØ Your Concept Mastery Progress",
                        color=discord.Color.purple()
                    )
                    
                    # Overview stats with progression info
                    mastered_count = len(mastery_status["mastered_concepts"])
                    remaining_count = len(mastery_status["remaining_concepts"])
                    total_count = mastery_status["total_concepts"]
                    percentage = mastery_status["mastery_percentage"]
                    
                    # Get building-block progression stats
                    progression_stats = recommendations.get("progression_stats", {})
                    building_blocks_mastered = progression_stats.get("building_blocks_mastered", 0)
                    total_building_blocks = progression_stats.get("total_building_blocks", 0)
                    building_blocks_percentage = progression_stats.get("building_blocks_percentage", 0)
                    ready_for_main = progression_stats.get("ready_for_main_concepts", False)
                    
                    if total_count == 0:
                        embed.description = "No concept definitions found in the course configuration. Please contact an administrator."
                    else:
                        embed.description = f"**Overall Progress: {mastered_count}/{total_count} concepts mastered ({percentage}%)**\n"
                        embed.description += f"**Building Blocks: {building_blocks_mastered}/{total_building_blocks} mastered ({building_blocks_percentage}%)**"
                        
                        if ready_for_main:
                            embed.description += "\nüéâ **Ready for main concepts!**"
                        else:
                            embed.description += "\nüß± **Focus on building blocks first**"
                        
                        # Show next recommended concepts (building-block first approach)
                        next_concepts = recommendations.get("next_concepts", [])
                        if next_concepts:
                            next_text = ""
                            for i, concept in enumerate(next_concepts[:3], 1):
                                emoji = "üîß" if concept["type"] == "coding" else "üìñ"
                                priority_indicator = "üß± NEXT" if concept.get("is_building_block", False) else "üìö READY"
                                difficulty_emoji = {"beginner": "üü¢", "intermediate": "üü°", "advanced": "üî¥"}.get(concept["difficulty"], "‚ö™")
                                next_text += f"{i}. {emoji} **{concept['name']}** {priority_indicator} {difficulty_emoji}\n"
                                next_text += f"   _{concept['description'][:70]}{'...' if len(concept['description']) > 70 else ''}_\n\n"
                            
                            embed.add_field(
                                name="üéØ Your Next Learning Steps",
                                value=next_text[:1024],
                                inline=False
                            )
                        
                        # Mastered concepts section (condensed)
                        if mastered_count > 0:
                            mastered_text = ""
                            for concept in mastery_status["mastered_concepts"][:6]:  # Show fewer to make room
                                emoji = "üîß" if concept["type"] == "coding" else "üìñ"
                                building_block = " üß±" if concept["is_building_block"] else ""
                                mastered_text += f"{emoji} **{concept['name']}**{building_block}\n"
                            
                            if mastered_count > 6:
                                mastered_text += f"... and {mastered_count - 6} more!\n"
                            
                            embed.add_field(
                                name=f"‚úÖ Mastered ({mastered_count})",
                                value=mastered_text[:1024],
                                inline=True
                            )
                        
                        # Show building blocks vs main concepts breakdown
                        if remaining_count > 0:
                            remaining_building_blocks = [c for c in mastery_status["remaining_concepts"] if c["is_building_block"]]
                            remaining_main = [c for c in mastery_status["remaining_concepts"] if not c["is_building_block"]]
                            
                            remaining_text = f"üß± Building blocks: {len(remaining_building_blocks)}\n"
                            remaining_text += f"üìö Main concepts: {len(remaining_main)}\n\n"
                            remaining_text += "**Use `/quiz` to practice your next steps!**"
                            
                            embed.add_field(
                                name=f"üìö Remaining ({remaining_count})",
                                value=remaining_text[:1024],
                                inline=True
                            )
                        
                        embed.set_footer(text="üß± = Building-block | Use /status pathway for detailed progression")

                elif type == "pathway":
                    # Show detailed learning pathway with building-block first approach
                    from services.concept_progression import concept_progression
                    recommendations = await concept_progression.get_next_recommended_concepts(str(user_id))
                    
                    embed = discord.Embed(
                        title="üó∫Ô∏è Your Learning Pathway",
                        color=discord.Color.gold()
                    )
                    
                    learning_pathway = recommendations.get("learning_pathway", [])
                    progression_stats = recommendations.get("progression_stats", {})
                    
                    if not learning_pathway:
                        embed.description = "No learning pathway available. Contact an administrator if this persists."
                    else:
                        embed.description = "**Building-block first learning progression for all modules**"
                        
                        for module_data in learning_pathway[:2]:  # Show up to 2 modules
                            module_name = module_data["module_name"]
                            module_id = module_data["module_id"]
                            building_blocks = module_data["building_blocks"]
                            main_concepts = module_data["main_concepts"]
                            ready_for_main = module_data["ready_for_main"]
                            
                            # Building blocks progress
                            building_blocks_done = sum(1 for c in building_blocks if c["mastered"])
                            building_blocks_total = len(building_blocks)
                            
                            # Main concepts progress
                            main_concepts_done = sum(1 for c in main_concepts if c["mastered"])
                            main_concepts_total = len(main_concepts)
                            
                            module_text = f"**Phase 1 - Building Blocks:** {building_blocks_done}/{building_blocks_total}\n"
                            
                            # Show building blocks status
                            for concept in building_blocks[:3]:
                                status = "‚úÖ" if concept["mastered"] else "‚è≥"
                                type_emoji = "üîß" if concept["type"] == "coding" else "üìñ"
                                difficulty_emoji = {"beginner": "üü¢", "intermediate": "üü°", "advanced": "üî¥"}.get(concept["difficulty"], "‚ö™")
                                module_text += f"  {status} {type_emoji} {concept['name']} {difficulty_emoji}\n"
                            
                            if len(building_blocks) > 3:
                                module_text += f"  ... and {len(building_blocks) - 3} more\n"
                            
                            module_text += f"\n**Phase 2 - Main Concepts:** {main_concepts_done}/{main_concepts_total}"
                            if ready_for_main:
                                module_text += " üéâ\n"
                            else:
                                module_text += " üîí (Complete building blocks first)\n"
                            
                            # Show main concepts status
                            if ready_for_main:
                                for concept in main_concepts[:2]:
                                    status = "‚úÖ" if concept["mastered"] else "‚è≥"
                                    type_emoji = "üîß" if concept["type"] == "coding" else "üìñ"
                                    difficulty_emoji = {"beginner": "üü¢", "intermediate": "üü°", "advanced": "üî¥"}.get(concept["difficulty"], "‚ö™")
                                    module_text += f"  {status} {type_emoji} {concept['name']} {difficulty_emoji}\n"
                                
                                if len(main_concepts) > 2:
                                    module_text += f"  ... and {len(main_concepts) - 2} more\n"
                            
                            embed.add_field(
                                name=f"üìö {module_name} ({module_id.upper()})",
                                value=module_text[:1024],
                                inline=False
                            )
                        
                        if len(learning_pathway) > 2:
                            embed.add_field(
                                name="üìñ More Modules",
                                value=f"... and {len(learning_pathway) - 2} more modules to explore!",
                                inline=False
                            )
                        
                        embed.set_footer(text="‚úÖ = Mastered | ‚è≥ = Next to learn | üîí = Locked until prerequisites complete")

                elif type == "profile":
                    # Show student learning profile
                    from services.student_profiler import student_profiler
                    profile_data = await student_profiler.get_or_create_profile(str(user_id))
                    
                    embed = discord.Embed(
                        title="üß† Your Learning Profile",
                        color=discord.Color.blue()
                    )
                    
                    if not profile_data:
                        embed.description = "Your learning profile is still being developed. Continue learning to see your personalized profile!"
                    else:
                        # Main profile description
                        embed.description = profile_data["current_description"]
                        
                        # Learning trajectory (if available)
                        trajectory = profile_data.get("learning_trajectory", "")
                        if trajectory and trajectory != "Learning trajectory developing...":
                            embed.add_field(
                                name="üìä Learning Trajectory",
                                value=trajectory,
                                inline=False
                            )
                        
                        # Learning characteristics
                        embed.add_field(
                            name="üìà Learning Characteristics",
                            value=f"**Difficulty:** {profile_data['preferred_difficulty'].title()}\n"
                                  f"**Pace:** {profile_data['learning_pace'].title()}\n"
                                  f"**Style:** {profile_data['communication_style'].title()}",
                            inline=True
                        )
                        
                        # Strengths and challenges
                        strengths = profile_data.get('learning_strengths', [])
                        challenges = profile_data.get('learning_challenges', [])
                        
                        if strengths:
                            strengths_text = "‚Ä¢ " + "\n‚Ä¢ ".join(strengths[:3])
                            embed.add_field(
                                name="üí™ Strengths",
                                value=strengths_text,
                                inline=True
                            )
                        
                        if challenges:
                            challenges_text = "‚Ä¢ " + "\n‚Ä¢ ".join(challenges[:3])
                            embed.add_field(
                                name="üéØ Focus Areas",
                                value=challenges_text,
                                inline=True
                            )
                        
                        # Recommendations
                        embed.add_field(
                            name="ü§ñ AI Recommendations",
                            value=f"**Quiz Level:** {profile_data['recommended_quiz_level'].title()}\n"
                                  f"**Explanation Style:** {profile_data['recommended_explanation_style'].replace('_', ' ').title()}",
                            inline=False
                        )
                        
                        # Knowledge gaps
                        gaps = profile_data.get('knowledge_gaps', [])
                        if gaps:
                            gaps_text = "‚Ä¢ " + "\n‚Ä¢ ".join(gaps[:4])
                            embed.add_field(
                                name="üìö Areas to Explore",
                                value=gaps_text,
                                inline=False
                            )
                        
                        # Profile metadata
                        embed.set_footer(
                            text=f"Profile v{profile_data.get('version', 1)} ‚Ä¢ "
                                 f"Confidence: {profile_data.get('confidence_score', 0)}% ‚Ä¢ "
                                 f"Updated: {profile_data.get('last_updated', 'Unknown')[:10]}"
                        )

                await interaction.followup.send(embed=embed)

            except Exception as e:
                logger.error("Status command error",
                           **LogContext.error("status_command", user_id=user_id, error=str(e)))
                try:
                    if interaction.response.is_done():
                        await interaction.followup.send("‚ùå Could not retrieve your status. Please try again.")
                    else:
                        await interaction.response.send_message("‚ùå Could not retrieve your status. Please try again.")
                except:
                    pass  # Fail silently if we can't send error message

        # Example of an app command with parameters


    async def _handle_implicit_question(self, message):
        """Handle messages with module markers as implicit questions."""
        try:
            # Extract the question and module
            module, clean_question = self.message_parser.parse_question(message.content)

            if not module or not clean_question.strip():
                return

            # Create a mock context for the QA handler
            class MockContext:
                def __init__(self, message):
                    self.message = message
                    self.author = message.author
                    self.channel = message.channel
                    self.guild = message.guild

                async def send(self, content=None, **kwargs):
                    if isinstance(content, str) and len(content) > 2000:
                        # Split long messages
                        chunks = [content[i:i+2000] for i in range(0, len(content), 2000)]
                        for i, chunk in enumerate(chunks):
                            if i == 0:
                                # First chunk as reply
                                await self.message.reply(chunk, **kwargs)
                            else:
                                # Subsequent chunks as regular messages
                                await self.channel.send(chunk)
                    else:
                        # Use reply for guild messages
                        await self.message.reply(content, **kwargs)

                def typing(self):
                    return self.channel.typing()

            mock_ctx = self._create_guild_mock_context(message)
            await self.conversation_handler.handle_user_message(mock_ctx, clean_question)

        except Exception as e:
            logger.error("Implicit question handling error",
                        **LogContext.error("implicit_question",
                                         user_id=message.author.id,
                                         error=str(e)))

    async def _handle_dm_message(self, message):
        """Handle direct message from user."""
        try:
            content = message.content.strip()
            user_id = message.author.id

            # Log DM interaction
            logger.info("DM message received",
                       user_id=user_id,
                       content_length=len(content))

            # Handle commands first
            if content.startswith('/'):
                await self.process_commands(message)
                return

            # Handle empty messages
            if not content:
                await message.channel.send("üëã Hi! I'm your AI tutor. You can ask me questions or use commands like `/help` to get started.")
                return

            # Use conversation handler for all DM content
            mock_ctx = self._create_mock_context(message)
            await self.conversation_handler.handle_user_message(mock_ctx, content)

        except Exception as e:
            logger.error("DM handling error",
                        **LogContext.error("dm_message",
                                         user_id=message.author.id,
                                         error=str(e)))
            await message.channel.send("‚ùå Something went wrong. Please try again or use `/help` for assistance.")

    async def _handle_mention(self, message):
        """Handle when the bot is mentioned in a message."""
        try:
            user_id = message.author.id

            # Remove the mention from the content to get the actual message
            content = message.content
            for mention in message.mentions:
                if mention == self.user:
                    # Remove the mention (e.g., "<@123456789>" or "<@!123456789>")
                    content = content.replace(f"<@{mention.id}>", "").replace(f"<@!{mention.id}>", "")

            content = content.strip()

            # Log mention interaction
            logger.info("Bot mentioned",
                       user_id=user_id,
                       guild_id=message.guild.id if message.guild else None,
                       content_length=len(content))

            # Handle empty mentions (just tagging the bot)
            if not content:
                embed = discord.Embed(
                    title="üëã Hi there!",
                    description="I'm your AI tutor! Here's how I can help:",
                    color=discord.Color.blue()
                )

                embed.add_field(
                    name="üí¨ Ask Questions",
                    value="Just mention me with your question:\n`@AITutor What is the main topic of this lesson?`",
                    inline=False
                )

                embed.add_field(
                    name="üìù Request Quizzes",
                    value="Ask for a quiz by mentioning me:\n`@AITutor quiz me on the course material`",
                    inline=False
                )

                embed.add_field(
                    name="üîß Commands",
                    value="Use `/help` to see all available commands and modules!",
                    inline=False
                )

                await message.channel.send(embed=embed)
                return

            # Use conversation handler for mention content
            mock_ctx = self._create_guild_mock_context(message)
            await self.conversation_handler.handle_user_message(mock_ctx, content)

        except Exception as e:
            logger.error("Mention handling error",
                        **LogContext.error("mention_handler",
                                         user_id=message.author.id,
                                         error=str(e)))
            await message.channel.send("‚ùå Something went wrong. Please try again or use `/help` for assistance.")

    async def _handle_dm_question(self, message, question: str, module: str = None):
        """Handle a question in DM."""
        user_id = message.author.id

        try:
            # If no module specified, check user's current module
            if not module:
                module = await context_manager.get_current_module(user_id)

            # If still no module, ask user to specify one
            if not module:
                embed = discord.Embed(
                    title="üìö Module Selection Needed",
                    description=f"To answer your question: *\"{question[:100]}...\"*\n\nPlease specify which module you'd like help with:",
                    color=discord.Color.blue()
                )

                # Add available modules
                modules = ModuleConfig.get_all_modules()
                module_list = []
                for mod_id, mod_info in modules.items():
                    module_list.append(f"‚Ä¢ `{mod_id.upper()}`: {mod_info.get('name', 'Unknown')}")

                embed.add_field(
                    name="Available Modules",
                    value="\n".join(module_list[:5]) + ("\n..." if len(module_list) > 5 else ""),
                    inline=False
                )
                embed.add_field(
                    name="How to specify a module",
                    value="Add a module marker to your question like: `#m01 What is a network?`\nOr use: `/module m01` then ask your question",
                    inline=False
                )

                await message.channel.send(embed=embed)
                return

            # Process the question with module context
            mock_ctx = self._create_mock_context(message)
            await self.conversation_handler.handle_ask_command(mock_ctx, question=question)

        except Exception as e:
            logger.error("DM question handling error",
                        **LogContext.error("dm_question",
                                         user_id=user_id,
                                         error=str(e)))
            await message.channel.send("‚ùå I couldn't process your question. Please try again or use `/help` for assistance.")

    def _create_mock_context(self, message):
        """Create a mock context for DM messages to work with existing handlers."""
        class MockContext:
            def __init__(self, message):
                self.message = message
                self.author = message.author
                self.channel = message.channel
                self.guild = None  # DMs don't have guilds

            async def send(self, content=None, **kwargs):
                if isinstance(content, str) and len(content) > 2000:
                    # Split long messages
                    chunks = [content[i:i+2000] for i in range(0, len(content), 2000)]
                    for chunk in chunks:
                        await self.channel.send(chunk)
                else:
                    await self.channel.send(content, **kwargs)

            def typing(self):
                return self.channel.typing()

        return MockContext(message)

    def _create_guild_mock_context(self, message):
        """Create a mock context for guild messages that uses replies."""
        class GuildMockContext:
            def __init__(self, message):
                self.message = message
                self.author = message.author
                self.channel = message.channel
                self.guild = message.guild

            async def send(self, content=None, **kwargs):
                if isinstance(content, str) and len(content) > 2000:
                    # Split long messages
                    chunks = [content[i:i+2000] for i in range(0, len(content), 2000)]
                    for i, chunk in enumerate(chunks):
                        if i == 0:
                            # First chunk as reply
                            await self.message.reply(chunk, **kwargs)
                        else:
                            # Subsequent chunks as regular messages
                            await self.channel.send(chunk)
                else:
                    # Use reply for guild messages
                    await self.message.reply(content, **kwargs)

            def typing(self):
                return self.channel.typing()

        return GuildMockContext(message)

    def _create_slash_context(self, interaction: discord.Interaction):
        """Create a mock context for slash command interactions."""
        class SlashContext:
            def __init__(self, interaction):
                self.interaction = interaction
                self.author = interaction.user
                self.channel = interaction.channel
                self.guild = interaction.guild

            async def send(self, content=None, **kwargs):
                if isinstance(content, str) and len(content) > 2000:
                    # Split long messages
                    chunks = [content[i:i+2000] for i in range(0, len(content), 2000)]
                    for i, chunk in enumerate(chunks):
                        if i == 0:
                            await self.interaction.followup.send(chunk, **kwargs)
                        else:
                            await self.interaction.followup.send(chunk)
                else:
                    await self.interaction.followup.send(content, **kwargs)

            def typing(self):
                return SlashTyping()

        class SlashTyping:
            async def __aenter__(self):
                return self
            async def __aexit__(self, *args):
                pass

        return SlashContext(interaction)

    async def _is_admin(self, user: discord.User) -> bool:
        """Check if user is an administrator."""
        # Simple admin check - you can customize this logic
        if hasattr(user, 'guild_permissions'):
            return user.guild_permissions.administrator
        return False

    async def _join_existing_threads(self):
        """Join existing threads in all guilds when bot starts up."""
        thread_count = 0
        joined_count = 0

        try:
            for guild in self.guilds:
                # Get all active threads in the guild
                for channel in guild.text_channels:
                    try:
                        # Check if channel supports threads and has active_threads method
                        if hasattr(channel, 'active_threads'):
                            # Get active threads in this channel
                            active_threads = await channel.active_threads()
                            for thread in active_threads.threads:
                                thread_count += 1
                                if not thread.me:  # Bot is not in the thread
                                    try:
                                        await thread.join()
                                        joined_count += 1
                                    except (discord.Forbidden, discord.HTTPException):
                                        pass  # Skip threads we can't join
                    except (discord.Forbidden, discord.HTTPException, AttributeError):
                        continue  # Skip channels we can't access or don't support threads

            logger.info("Thread initialization complete",
                       total_threads=thread_count,
                       joined_threads=joined_count)

        except Exception as e:
            logger.error("Error during thread initialization", error=str(e))

    async def close(self):
        """Clean up when bot is shutting down."""
        logger.info("Shutting down AI Tutor Bot...")

        # Stop context manager
        from bot.utils.context_manager import context_manager
        await context_manager.stop()

        # Cleanup quiz states
        self.conversation_handler.cleanup_expired_quizzes(0)  # Clean up all quizzes

        # Close LLM client
        await self.conversation_handler.llm_client.close()

        # Clear cache
        await cache_manager.clear()

        await super().close()


# Function to run the bot
async def run_bot():
    """Run the Discord bot."""
    bot = AITutorBot()

    try:
        await bot.start(settings.discord_bot_token)
    except KeyboardInterrupt:
        logger.info("Bot shutdown requested")
    except Exception as e:
        logger.error("Bot startup failed", **LogContext.error("bot_startup", error=str(e)))
        raise
    finally:
        await bot.close()


if __name__ == "__main__":
    asyncio.run(run_bot())